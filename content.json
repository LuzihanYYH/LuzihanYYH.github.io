{"meta":{"title":"AustinYAN's Blog","subtitle":"","description":"","author":"染墨灬若流云","url":"https://www.lubaobao.xyz","root":"/"},"pages":[{"title":"所有分类","date":"2020-06-22T12:52:46.285Z","updated":"2020-06-22T12:52:46.285Z","comments":true,"path":"categories/index.html","permalink":"https://www.lubaobao.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-17T15:01:08.273Z","updated":"2020-07-17T15:01:08.273Z","comments":true,"path":"about/index.html","permalink":"https://www.lubaobao.xyz/about/index.html","excerpt":"","text":".center { position: fixed; left: 20%; right: 20%; top: 10%; width: 60%; height: 15%; opacity: 0.95; float: left; background-color: white; } .centerAfterLeft { position: fixed; left: 20%; top: 26%; width: 29.5%; height: 50%; opacity: 0.95; float: left; background-color: white; } .centerAfterRight { position: fixed; right: 20%; top: 26%; width: 29.5%; height: 50%; opacity: 0.95; float: left; background-color: white; } .footer { position: fixed; left: 20%; right: 20%; top: 77%; width: 60%; height: 15%; opacity: 0.95; background-color: white; } .lastfooter { position: fixed; left: 20%; right: 20%; top: 93%; width: 60%; height: 30px; vertical-align: middle; text-align: center; background-color: transparent; } #selfphoto { margin-left: 10px; margin-top: 5px; float: left; } #selfphoto img { border-radius: 50%; vertical-align: middle; -webkit-animation: rotateImg 5s linear infinite; } @keyframes rotateImg { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } @-webkit-keyframes rotateImg { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } } body { background-color: rgb(81, 77, 85); font-family: 楷体; } /*样式二*/ /* 控制下雪 */ function snowFall(snow) { /* 可配置属性 */ snow = snow || {}; this.maxFlake = snow.maxFlake || 400; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */ } /* 兼容写法 */ requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) { setTimeout(callback, 1000 / 60); }; cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame; /* 开始下雪 */ snowFall.prototype.start = function () { /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this) } /* 创建画布 */ function snowCanvas() { /* 添加Dom结点 */ var snowcanvas = document.createElement(\"canvas\"); snowcanvas.id = \"snowfall\"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute(\"style\", \"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;\"); document.getElementsByTagName(\"body\")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext(\"2d\"); /* 窗口大小改变的处理 */ window.onresize = function () { snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ } } /* 雪运动对象 */ function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) { this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */ } flakeMove.prototype.update = function () { var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY = canvas.width || this.x = canvas.height || this.y"}],"posts":[{"title":"WPF-ComboBoxGanged","slug":"WPF-ComboBoxGanged","date":"2020-07-18T05:44:18.806Z","updated":"2020-07-18T05:44:18.806Z","comments":true,"path":"2020/07/18/WPF-ComboBoxGanged/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/18/WPF-ComboBoxGanged/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"WPF的后台数据绑定","slug":"WPF-BackstageBinding","date":"2020-07-16T16:00:00.000Z","updated":"2020-07-17T02:58:51.935Z","comments":true,"path":"2020/07/17/WPF-BackstageBinding/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/17/WPF-BackstageBinding/","excerpt":"有很多时候,自定义控件是由多个不同的系统提供的控件组合起来的,那么在Xaml前端界面上,实例化对象之后,是没有办法访问到内部的控件的(哪怕你命了名),但是又想给他绑定数据源怎么办呢?","text":"有很多时候,自定义控件是由多个不同的系统提供的控件组合起来的,那么在Xaml前端界面上,实例化对象之后,是没有办法访问到内部的控件的(哪怕你命了名),但是又想给他绑定数据源怎么办呢? 情景1234567891011121314151617181920212223&lt;ProgressBar Grid.Row=\"0\" x:Name=\"progressBar\" x:FieldModifier=\"public\" Style=\"&#123;StaticResource ProgressBarStyle2&#125;\" local:EllipseClipper.IsClipping=\"True\" HorizontalAlignment=\"Center\" Height=\"100\" VerticalAlignment=\"Top\" Width=\"100\" Value=\"50\" RenderTransformOrigin=\"0.5,0.5\" Foreground=\"&#123;DynamicResource BodorBkColor&#125;\"&gt; &lt;ProgressBar.Effect&gt; &lt;DropShadowEffect BlurRadius=\"7\" Direction=\"-500\" Color=\"#FF3E3E3E\" RenderingBias=\"Quality\" FrameworkElement.FlowDirection=\"LeftToRight\" ShadowDepth=\"1\" /&gt; &lt;/ProgressBar.Effect&gt; &lt;ProgressBar.Background&gt; &lt;RadialGradientBrush&gt; &lt;GradientStop Color=\"#363636\" Offset=\"1\" /&gt; &lt;GradientStop Color=\"#656666\" /&gt; &lt;/RadialGradientBrush&gt; &lt;/ProgressBar.Background&gt; &lt;ProgressBar.RenderTransform&gt; &lt;TransformGroup&gt; &lt;ScaleTransform/&gt; &lt;SkewTransform/&gt; &lt;RotateTransform Angle=\"-90\"/&gt; &lt;TranslateTransform/&gt; &lt;/TransformGroup&gt; &lt;/ProgressBar.RenderTransform&gt; &lt;/ProgressBar&gt; &lt;Label Grid.Row=\"1\" x:Name=\"labelModelName\" x:FieldModifier=\"public\" Content=\"功率(KW)\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Foreground=\"&#123;StaticResource NormalForeground&#125;\" FontSize=\"15\"/&gt; &lt;Label Grid.Row=\"0\" x:Name=\"labelValue\" x:FieldModifier=\"public\" Content=\"&#123;Binding Value, ElementName=progressBar,Converter=&#123;StaticResource ValueConverter&#125;&#125;\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Foreground=\"&#123;StaticResource NormalForeground&#125;\" FontSize=\"15\" SizeChanged=\"labelValue_SizeChanged\"/&gt; 这段xaml的代码不保证有效,只是举个例子随便截取的一段,这个自定义控件由一个ProgreeBar和两个Label组成,其中Label1的Content绑定的是ProgressBar的Value,那么在外部调用这个自定义控件时 1&lt;local:LocalUserControl x:Name=\"localUserControl\" Grid.Column=\"0\" Width=\"120\" /&gt; 这个时候已经访问不到内部的ProgressBar了,怎么绑定数据就是一个问题了 也不可能在控件里就绑定,那所有的控件绑定的都是一个数据源了 后台绑定之前说xaml里哪怕内部的控件命了名也访问不了,那么命名干什么呢?是为了让后台代码可以访问到 1234567//绑定当前速度CurrentSpeedBall.progressBar.Maximum = 100;SetBindings(CurrentSpeedBall.progressBar, viewModel.motionStatus, \"Data\", BindingMode.OneWay, ProgressBar.ValueProperty);//绑定和初始化进给倍率viewModel.motionStatus.feedRate = BusinessLayerService.CommonControlStatus.FeedRate = 100;SetBindings(FeedRateSlider.slider, viewModel.motionStatus, \"feedRate\", BindingMode.TwoWay, Slider.ValueProperty); 后台是可以通过命名+.+命名的方式访问到内部的控件的 SetBinding &amp; BindingOperations这两者没什么大的区别,只是使用方法略微不同如果需要封装成函数,控件的类型写UserControl会无法转换,所以应该写FrameWorkElement SetBinding使用:UserControl.SetBinding(DependcyProperty dp,BindingBase binding) BindingOperations使用:BindingOperations.SetBinding(Obj, DepProperty, binding); Binding.Source数据源,一般都是一个类 Binding.Path双向绑定的时候或者数据源是类的时候会需要,如果数据源是类,path就是成员变量的名称 Binding.Mode绑定的方式,和xaml里一致,one way/two way/…之类的,UpdateTrigger也是一样的设置方法 12345678910public void SetBindings(FrameworkElement Obj, Object Source, string PropertyPath, BindingMode Mode, DependencyProperty DepProperty)&#123; Binding binding = new Binding(); binding.Source = Source; binding.Path = new PropertyPath(PropertyPath); binding.Mode = Mode; if (Mode == BindingMode.TwoWay) binding.UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged; BindingOperations.SetBinding(Obj, DepProperty, binding);&#125; 可能遇到的问题如果绑定之后,界面UI没有变化,有可能是因为数据源没有通知UI发生了变化数据源的类应该继承INotifyPropertyChanged,并且实现接口 123456789101112131415public class DataSource : INotifyPropertyChanged &#123; private double _Data; public double Data &#123; get &#123; return _Data; &#125; set &#123; _Data = value; if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(\"Data\")); &#125; &#125; public event PropertyChangedEventHandler PropertyChanged; &#125; 效果","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"HTML制作个人简介页面","slug":"HTML-About","date":"2020-07-14T16:00:00.000Z","updated":"2020-07-15T07:06:52.955Z","comments":true,"path":"2020/07/15/HTML-About/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/15/HTML-About/","excerpt":"我的博客是看的大神教程一步步做的,然后所以我的about界面,也准备仿着大佬的做，之前根本没学过web的前端，只接触过xaml这种带标签的设计语言…","text":"我的博客是看的大神教程一步步做的,然后所以我的about界面,也准备仿着大佬的做，之前根本没学过web的前端，只接触过xaml这种带标签的设计语言… 布局设计这个东西还是比较难得,我就直接没有设计,布局是照着别人的抄的,虽然实现是自己实现的，但是如果还是侵权的话，联系我删除大佬的about界面 最上层,旋转的头像、昵称、生日等信息 中间左半部分，技能和占比 中间右半部分，个人的简介 底部，图片链接 最底部，版权信息、博客链接 确定好每个区域的位置，背景色和透明度，颜色我不会弄成渐变的，暂且纯色代替，css我也没学过，写法如果错误请见谅.. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;style&gt; .center &#123; position: fixed; left: 20%; right: 20%; top: 10%; width: 60%; height: 15%; opacity: 0.95; float: left; background-color: white; &#125; .centerAfterLeft &#123; position: fixed; left: 20%; top: 26%; width: 29.5%; height: 50%; opacity: 0.95; float: left; background-color: white; &#125; .centerAfterRight &#123; position: fixed; right: 20%; top: 26%; width: 29.5%; height: 50%; opacity: 0.95; float: left; background-color: white; &#125; .footer &#123; position: fixed; left: 20%; right: 20%; top: 77%; width: 60%; height: 15%; opacity: 0.95; background-color: white; &#125; .lastfooter &#123; position: fixed; left: 20%; right: 20%; top: 93%; width: 60%; height: 30px; vertical-align: middle; text-align: center; background-color: transparent; &#125; body &#123; background-color: rgb(81, 77, 85); font-family: 楷体; &#125; &lt;/style&gt; 头像旋转遇到不会的就要多百度一下，然后我惊讶的发现了大佬也是查询的这篇博客，还留了言..HTML图片旋转 基本上博客上的内容复制过去就直接能用，然后我就不求甚解了.. 文字排版拿最上层举例,昵称和后面的文字是需要在一行的,标签p需要设置display:inline-block;然后空格我也不知道为啥HTML默认不显示,我查到的方法是&amp;nbsp,好像markdown里也是这样的 123456&lt;div style=\"float: left;margin-left: 20px;\"&gt; &lt;p style=\"margin-bottom: 10px;display: inline-block;font-weight: bold;\"&gt;昵称:&lt;/p&gt; &lt;p style=\"margin-bottom: 10px;display: inline-block;\"&gt;&amp;nbsp&amp;nbsp染墨灬若流云&lt;/p&gt;&lt;br&gt; &lt;p style=\"margin-bottom: 15px;display: inline-block;font-weight: bold;\"&gt;最爱:&lt;/p&gt; &lt;p style=\"margin-bottom: 15px;display: inline-block;\"&gt;&amp;nbsp&amp;nbsp迷人又可爱的鹿宝宝~&lt;/p&gt; &lt;/div&gt; 我知道这样写会有问题,如果是xaml布局,我会考虑竖屏下的情况,避免分辨率变化造成的页面显示异常,但是html实在是无能为力… 中间的右半部分,那个黑色的点很容易让人想到markdown的-,那么是不是html可以用markdown语法呢?很遗憾不可以,但是可以把markdown转换成html,Typora或者CSDN的编辑器都支持这个功能 1234567&lt;ul&gt; &lt;li&gt;学历: &lt;/li&gt;&lt;br&gt; &lt;li&gt;现况: &lt;/li&gt;&lt;br&gt; &lt;li&gt;目标: &lt;/li&gt;&lt;br&gt; &lt;li&gt;博客: &lt;/li&gt;&lt;br&gt; &lt;li&gt;兴趣: &gt;&lt;br&gt;&lt;/ul&gt; 导出后最后是没有&lt;br&gt;标签的,我是为了和左边对齐 绘制矩形这个我查了很多,都是用js来做,可惜js我也没学过,我觉得我在window_load事件中写会导致刷新的时候明显感觉矩形闪烁,大佬的博客about界面就没这个问题,所以我觉得这个方法不太对.. 123456789101112/*技能条*/var canvas = document.getElementById(\"SkillCanvas\");if (canvas == null) return;var t = new Array(12, 39, 64, 89, 114);var y = new Array(\"#4AB480\", \"#E1AB3E\", \"#DC595#7390F2\", \"#747DC5\");var l = new Array(120, 150, 40, 60, 30);var content = canvas.getContext(\"2d\");for (var i = 0; i &lt; 5; ++i) &#123; content.fillStyle = y[i]; content.fillRect(0, t[i], l[i], 15);&#125; 这样写维护性很差很差,但是考虑到这个界面过很久很久才可能更新,所以先只追求效果,不追求代码规范(给自己的菜找一找借口) 技能的百分比就还是之前的方法,移到合适的位置就好排版的话我毕竟没学过,追求效果类似我用的margin-left,直接偏移过去,不知道更优雅的做法是怎么样的..大佬的这个界面是禁用左右键和F12的.. 禁用左右键和F12大佬这样做的目的可能是保护自己的代码或者不让自己的界面被人改动,既然我们是仿照大佬的做,这个功能我们也要有 JS也可以禁用左右键,但是网上说禁用JS脚本后这招就没用了,所以这里用html自带的属性 123&lt;body topmargin=\"0\" oncontextmenu=\"return false\" ondragstart=\"return false\" onselectstart=\"return false\" onselect=\"document.selection.empty()\" oncopy=\"document.selection.empty()\" onbeforecopy=\"return false\" onmouseup=\"document.selection.empty()\"&gt; 将这段放入body标签中即可生效 禁用F12我只找到了JS的方法,不知道大佬是怎么做的.. 1234567window.onkeydown = window.onkeyup = window.onkeypress = function (event) &#123; // 判断是否按下F12，F12键码为123 if (event.keyCode = 123) &#123; event.preventDefault(); // 阻止默认事件行为 window.event.returnValue = false; &#125; &#125; 图片链接链接是&lt;a&gt;标签,图片链接就是在这个标签里加入一个&lt;img&gt;标签 1234&lt;a href=\"https://blog.csdn.net/Austin_Yan\" target=\"-blank\" title=\"CSDN\"&gt; &lt;img id=\"blog\" style=\"margin-top: 0px;left: 75%;position: absolute;\" src=\"https://cdn.jsdelivr.net/gh/AustinYANyh/Image@1.1.1/CSDN.png\"&gt; &lt;/a&gt; target设置为-blank表示在浏览器新标签页打开 title替换文字,鼠标移到上方显示的文字 唤醒微信的我没查到,查到的也不能用,但是QQ的可以跳转链接为http://wpa.qq.com/msgrd?v=3 &amp;uin=1241528539 &amp;site=qq&amp;menu=yes里面有空格是因为我不加空格我跳转之后啥也不发生…加了空格貌似发送了点什么但是不太对的样子… 飘雪飘雪的代码来源于大佬的教程https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 将js代码拷贝到script标签下,然后window_load事件调用即可 1234window.onload = function StartSnow() &#123; /* 调用及控制方法 */ var snow = new snowFall(&#123; maxFlake: 60 &#125;); snow.start(); 效果一些小细节比如说,中间左右部分之间的间隔和上下的不一致..背景图没有找用纯色代替..还有大佬的模块背景和技能条的颜色都是渐变的..这些我都没处理好,不过还是先记录下来先做到这个样子吧..","categories":[{"name":"HTML","slug":"HTML","permalink":"https://www.lubaobao.xyz/categories/HTML/"}],"tags":[]},{"title":"WPF的按行高亮显示文本框","slug":"WPF-HightLightTextBox","date":"2020-07-09T16:00:00.000Z","updated":"2020-07-11T06:27:08.057Z","comments":true,"path":"2020/07/10/WPF-HightLightTextBox/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/10/WPF-HightLightTextBox/","excerpt":"之前做Winform的防QQ的通讯程序的时候，用到了文本框高亮显示，现在试试在WPF里试着实现","text":"之前做Winform的防QQ的通讯程序的时候，用到了文本框高亮显示，现在试试在WPF里试着实现 RichTextBox实现思路 利用TextPointer使用GetPositionAtOffst(double offset)方法获取需要高亮的文字开始位置的索引和结尾位置的索引 获取偏移量RichTextBox行结尾处的偏移量为开头的偏移量+文本长度+4,这里的4是”\\r\\n”的长度 利用TextRange内的ApplyPropertyValue方法新建一个TextRange,参数就是刚才的两个索引(TextPointer),然后修改TextElement的附加属性 代码12345678910111213141516171819202122232425262728293031TextRange textrange = new TextRange(OrderShow.Document.ContentStart, OrderShow.Document.ContentEnd);string[] str = textrange.Text.Split(new string[] &#123; \"\\r\\n\" &#125;, StringSplitOptions.RemoveEmptyEntries);int index = 0;for (int i = 0; i &lt; str.Count(); ++i)&#123; Dispatcher.BeginInvoke(new Action(() =&gt; &#123; textrange = new TextRange(OrderShow.Document.ContentStart, OrderShow.Document.ContentEnd); textrange.ApplyPropertyValue(TextElement.ForegroundProperty, System.Windows.Media.Brushes.Black); textrange.ApplyPropertyValue(TextElement.FontWeightProperty, FontWeights.Regular); &#125;)); TextPointer p1 = OrderShow.Selection.Start; p1 = p1.GetPositionAtOffset(index); index += str[i].Length; TextPointer p2 = OrderShow.Selection.Start; p2 = p2.GetPositionAtOffset(index); Dispatcher.BeginInvoke(new Action(() =&gt; &#123; textrange = new TextRange(p1, p2); textrange.ApplyPropertyValue(TextElement.ForegroundProperty, System.Windows.Media.Brushes.Blue); textrange.ApplyPropertyValue(TextElement.FontWeightProperty, FontWeights.Bold); &#125;)); index += 4; Thread.Sleep(1000);&#125;Dispatcher.BeginInvoke(new Action(() =&gt;&#123; textrange = new TextRange(OrderShow.Document.ContentStart, OrderShow.Document.ContentEnd); textrange.ApplyPropertyValue(TextElement.ForegroundProperty, System.Windows.Media.Brushes.Black); textrange.ApplyPropertyValue(TextElement.FontWeightProperty, FontWeights.Regular);&#125;)); 然而有个最严重的问题,RichTextBox的ScollViewer的方法除了ScrollToEnd和ScrollToHome外只有设置水平和垂直的偏移量,根据高亮内容的变化,不太方便控制滚动条到合适的位置..(我不会而已,不代表不可以实现) 效果只改了前景色没修改背景色高亮显示前光标必须在ContentStart,不然之后的index计算不准 TextBox实现思路为了解决上面的问题,所以又想用最开始的这个控件,优点是TextBox有ScrollToLine(int LineIndex)方法,滚动条的位置不需要管,只需要给行号即可,行号可以把TextBox的文本内容按”\\r\\n”分割获得,缺点是,高亮显示没有RichTextBox那么方便 Select(int start,int length)方法使用Select方法,可以选中start位置开始长度为length的字符要有显示效果需要TextBox获得焦点 SelectionBrush(System.Windows.Media.Brush)使用这个方法可以改变文本被选中的颜色,效果肯定不如既可以修改Foreground又可以修改Background的,其他方式我没查出来..(暂且先这样做) 获取偏移量方法和上面的一样,区别是TextBox计算时末尾加的是2,只有”\\n” 代码12345678910111213141516171819string txt = string.Empty;txt = OrderShow.Text;OrderShow.Focus();string[] str = txt.Split(new string[] &#123; \"\\r\\n\" &#125;, StringSplitOptions.None);int index = 0;for (int i = 0; i &lt; str.Count(); ++i)&#123; OrderShow.Focus(); OrderShow.CaretIndex = 0; OrderShow.Select(index, str[i].Length); OrderShow.ScrollToLine(i); Thread t = new Thread(o =&gt; Thread.Sleep(200)); t.Start(this); while (t.IsAlive) System.Windows.Forms.Application.DoEvents(); index += str[i].Length + 2;&#125;Importbtn.Focus(); 遇到的问题之前都是新建了一个线程去做高亮的事情,因为Thread.Sleep()在主线程调用会让界面UI假死,然后遇到了各种什么可能是CLR错误之类的东西,而且换到TextBox之后居然只有调试进断点才能看到效果,直接运行界面没任何变化 避免界面假死在Winform的时候用过DoEvents,所以想了一下直接不使用线程了,就在主线程延时操作 1234Thread t = new Thread(o =&gt; Thread.Sleep(200));t.Start(this);while (t.IsAlive) System.Windows.Forms.Application.DoEvents(); 线程只需要延时即可 文本内容如果有空行,那么在分割的时候StringSplitOptiions选择None,不然索引位置会计算错误造成高亮的不是想要的内容 效果2020-07-11更新 综合两种方法的优缺点,但是又有了新的问题 ListView实现思路TextBox的滚动条可以精确到行,RichTextBox的字体高亮,把这两个结合起来 TextBlock作为Item使用TextBlock的原因是因为他有Forceground、Background、FontWeight和FontSize属性 ScrollToView(Item item)这个方法可以精确的将滚动条跳转到ListView中的控件,与TextBox的ScrollToLine不同的是这个的滚动条位置是将控件显示在最下方 优点ListView本身就有行的概念,放入的TextBlock就是按行排布的,所以不需要计算index来找到需要高亮的文本内容 代码1234567891011121314151617for (int i = 0; i &lt; str.Count(); ++i)&#123; listview.ScrollIntoView(listview.Items[i]); (listview.Items[i] as TextBlock).Foreground = Brushes.Red; (listview.Items[i] as TextBlock).Background = Brushes.Yellow; (listview.Items[i] as TextBlock).FontWeight = FontWeights.Bold; (listview.Items[i] as TextBlock).FontSize = 16; Thread t = new Thread(o =&gt; Thread.Sleep(100)); t.Start(this); while (t.IsAlive) System.Windows.Forms.Application.DoEvents(); (listview.Items[i] as TextBlock).Foreground = Brushes.White; (listview.Items[i] as TextBlock).Background = Brushes.Transparent; (listview.Items[i] as TextBlock).FontWeight = FontWeights.Regular; (listview.Items[i] as TextBlock).FontSize = 13; t.Abort();&#125; 遇到的问题ListView默认的MouseOver和Selected会有巨丑的深蓝色背景Bodor,我们按行高亮只需要演示,不需要这个东西重写样式将对应的Background修改为Transparent 12345678910111213141516171819202122232425262728293031323334&lt;Style TargetType=\"&#123;x:Type ListViewItem&#125;\"&gt; &lt;Setter Property=\"Template\"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=\"&#123;x:Type ListViewItem&#125;\"&gt; &lt;Border Name=\"Bd\" Background=\"&#123;TemplateBinding Background&#125;\" BorderBrush=\"&#123;TemplateBinding BorderBrush&#125;\" BorderThickness=\"&#123;TemplateBinding BorderThickness&#125;\" Padding=\"&#123;TemplateBinding Padding&#125;\" SnapsToDevicePixels=\"true\"&gt; //用于显示本身的Content &lt;ContentPresenter HorizontalHorizontalContentAlignment&#125;\" VerticalAlignment=\"&#123;TemplateBinding VerticalContentAlignment&#125;\" SnapsToDevicePixels=\"&#123;TemplateBinding SnapsToDevicePixels&#125;\"/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;Setter Property=\"FocusVisualStyle\" Value=\"&#123;x:Null&#125;\"/&gt; &lt;Setter Property=\"BorderThickness\" Value=\"0\"/&gt; &lt;Setter Property=\"Foreground\" Value=\"Black\"/&gt; &lt;Setter Property=\"Background\" Value=\"Transparent\"/&gt; &lt;Setter Property=\"VerticalAlignment\" Value=\"Top\"/&gt; &lt;Setter Property=\"FontSize\" Value=\"14\"/&gt; &lt;Style.Triggers&gt; &lt;!--触发器--&gt; &lt;Trigger Property=\"IsMouseOver\" Value=\"True\"&gt; &lt;Setter Property=\"Background\" Value=\"Transparent\"/&gt; &lt;Setter Property=\"BorderBrush\" Value=\"Transparent\"/&gt; &lt;/Trigger&gt; &lt;Trigger Property=\"IsSelected\" Value=\"true\"&gt; &lt;Setter Property=\"Background\" Value=\"Transparent\"/&gt; &lt;Setter Property=\"Foreground\" Value=\"White\"/&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt;&lt;/Style&gt; 但是,如果有编辑需求的就麻烦了,TextBlock不可以编辑,而且ListView也不可以像文本框一样选择一片所以,需要编辑的时间将ListView隐藏,显示一个等大的TextBox去编辑吧#doge (下下策,好的方法我也不会) 效果","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"培养Vim使用习惯，Chrome安装Vimium插件","slug":"Chrome-Vimium","date":"2020-07-07T16:00:00.000Z","updated":"2020-07-08T01:52:06.320Z","comments":true,"path":"2020/07/08/Chrome-Vimium/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/08/Chrome-Vimium/","excerpt":"为了让自己更快的熟练各种快捷键，但是仅仅在日常写代码的情况下，很明显是不够的，于是我在chrome上装了这个插件，使自己无论何时都在使用vim的过程中，达到迅速上手改变自己操作习惯的目的(尽量不使用鼠标)..","text":"为了让自己更快的熟练各种快捷键，但是仅仅在日常写代码的情况下，很明显是不够的，于是我在chrome上装了这个插件，使自己无论何时都在使用vim的过程中，达到迅速上手改变自己操作习惯的目的(尽量不使用鼠标).. Chrome WebStore首先在谷歌的插件商店中搜索Vimium,然后找到下载量最多的那个就是,直接下载安装即可,至于怎么翻墙,以后再写一篇 Vimium常用命令 滚动 j:与Vim一致,向下滚动 k:与Vim一致,向上滚动 d:向下滚动一个屏幕的距离 u:向上滚动一个屏幕的距离 gg:与Vim一致,到达页面顶部 G:与Vim一致,到达页面底部 标签页 J:切换到上一个标签页(为什么J变成向上切换??) K:切换到下一个标签页 页面操作 x:关闭当前页面 X:恢复刚刚关闭的页面 r:重新加载页面 L:与Vim一致,前进 H:与Vim一致,后退 t:打开新标签页，直接可以输入网址 常用的命令好像暂时就这么多,但是如何想要打开某一个连接进去查看怎么办呢? 上面的快捷键只是一些很简单的常用的快捷键,还有很多没有列举,比如Vim是不用鼠标的,那么怎么点击链接就成了问题,我们也不可能不点击链接,所以快捷键f就是专门处理链接的问题的 虽然看上去很傻,而且效率肯定不如鼠标点击快,但是我的目的不是为了操作快,而且为了改变我的使用习惯,等到Vim随心所欲的时候,浏览器Vim插件的作用也就不存在了 突然想到为了发博客的图片能够显示居然还需要先发到CSDN上,CSDN居然变成了图床一样的用法,还是应该把自己以前做的图片服务器搭起来,也当作是复习了","categories":[],"tags":[]},{"title":"WPF的Command传入多参和快捷键设置","slug":"WPF-ShortCutKey","date":"2020-07-06T16:00:00.000Z","updated":"2020-07-08T07:58:07.490Z","comments":true,"path":"2020/07/07/WPF-ShortCutKey/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/07/WPF-ShortCutKey/","excerpt":"多活动活动脖子，多运动运动，拒绝颈椎病，从我做起！","text":"多活动活动脖子，多运动运动，拒绝颈椎病，从我做起！ 多路绑定+转换器使用MVVM模式的时候,多半将view中产生的操作通过command绑定到viewModel下处理,可以使用commandparameter将需要的参数传递过去,但是如果需要的参数超过一个的情况下,该怎么处理呢? 1234567891011121314151617181920212223242526&lt;Button x:Name=\"btyAutoUp\" Content=\"Y+\" Height=\"50\" Canvas.Left=\"101\" Width=\"50\" VerticalContentAlignment=\"Center\" Canvas.Top=\"195\" Margin=\"0,10,210,0\" VerticalAlignment=\"Top\" HorizontalAlignment=\"Right\"&gt; &lt;i:Interaction.Triggers&gt; &lt;i:EventTrigger EventName=\"PreviewMouseDown\"&gt; &lt;i:InvokeCommandAction Command=\"&#123;Binding JogCommand&#125;\"&gt; &lt;i:InvokeCommandAction.CommandParameter&gt; &lt;MultiBinding Converter=\"&#123;StaticResource YourConveter&#125;\"&gt; &lt;Binding ElementName=\"btyAutoUp\" Path=\"Content\"&gt;&lt;/Binding&gt; &lt;Binding ElementName=\"stepbtn\" Path=\"State\"&gt;&lt;/Binding&gt; &lt;Binding ElementName=\"StepDistance\" Path=\"Text\"&gt;&lt;/Binding&gt; &lt;Binding ElementName=\"IncrSpeed\" Path=\"Text\"&gt;&lt;/Binding&gt; &lt;/MultiBinding&gt; &lt;/i:InvokeCommandAction.CommandParameter&gt; &lt;/i:InvokeCommandAction&gt; &lt;/i:EventTrigger&gt; &lt;i:EventTrigger EventName=\"PreviewMouseUp\"&gt; &lt;i:InvokeCommandAction Command=\"&#123;Binding JogStopCommand&#125;\"&gt; &lt;i:InvokeCommandAction.CommandParameter&gt; &lt;MultiBinding Converter=\"&#123;StaticResource YourConveter&#125;\"&gt; &lt;Binding ElementName=\"btyAutoUp\" Path=\"Content\"&gt;&lt;/Binding&gt; &lt;Binding ElementName=\"stepbtn\" Path=\"State\"&gt;&lt;/Binding&gt; &lt;/MultiBinding&gt; &lt;/i:InvokeCommandAction.CommandParameter&gt; &lt;/i:InvokeCommandAction&gt; &lt;/i:EventTrigger&gt; &lt;/i:Interaction.Triggers&gt; &lt;/Button&gt; MultiBinding中可以写很多个Binding,但是标签中必须要有一个转换器,转换器其实也很好写,就是把传入的参数备份一遍,不然传入下一个参数的时候上一个就消失了 与转换器不同的是,多路绑定转换继承的是iMultiValueConverter普通绑定转换继承的iValueConverter 1234567891011public class MultiBindingConverter:iMultiValueConverter&#123; public object Convert(object[] values,Type targetType,object parameter,CultureInfo culture) &#123; return values.Clone(); &#125; public object[] ConverterBack(object[] values,Type targetType,object parameter,CultureInfo culture) &#123; throw new NotlmplementedException(); &#125;&#125; 快捷键设置快捷键可以使用keydown事件也可以使用InputBinding,一个是写在xaml.cs里一个是写在viewModel里,我觉得没啥影响,看个人喜好博客里写Binding的方式 123&lt;Window.InputBindings&gt; &lt;KeyBinding Getsture&#x3D;&quot;Control+Shift+B&quot; Command&#x3D;&quot;&#123;Binding DebugCommand&#125;&quot;&gt;&lt;&#x2F;Window.InputBindings&gt; 123456789101112131415public DelegateCommand DebugCommand &#123;get;set;&#125;public MainWindowViewModel()&#123; DebugCommand = new DelegateCommand(()=&gt; &#123; if(Keyboard.IsKeyDown(Key.LeftCtrl) &amp;&amp; Keyboard.IsKeyDown(Key.LeftShift) &amp;&amp; Keyboard.IsKeyDown(Key.B)) &#123; var window = Application.Current.MainWindow; MainWindow mainWindow = new MainWindow(window); MainWindow.IsOpen = true; mainWindow.Show(); &#125; &#125;);&#125; 但是有个问题暂时解决不了,微软的输入法Ctrl+Shift+B是表情,中文状态下会优先触发微软的输入法快捷键,英文就没问题 2020-07-08更新,问题解决 以下代码和资料来源于:http://www.cppcns.com/ruanjian/csharp/92519.html 先定义一个类,用来调用API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HotKey&#123; /// &lt;summary&gt; /// 如果函数执行成功，返回值不为0。 /// 如果函数执行失败，返回值为0。要得到扩展错误信息，调用GetLastError。.NET方法:Marshal.GetLastWin32Error() /// &lt;/summary&gt; /// &lt;param name=\"hWnd\"&gt;要定义热键的窗口的句柄&lt;/param&gt; /// &lt;param name=\"id\"&gt;定义热键ID（不能与其它ID重复） &lt;/param&gt; /// &lt;param name=\"fsModifiers\"&gt;标识热键是否在按Alt、Ctrl、Shift、Windows等键时才会生效&lt;/param&gt; /// &lt;param name=\"vk\"&gt;定义热键的内容,WinForm中可以使用Keys枚举转换， /// WPF中Key枚举是不正确的,应该使用System.Windows.Forms.Keys枚举，或者自定义正确的枚举或int常量&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [DllImport(\"user32.dll\", SetLastError = true)] public static extern bool RegisterHotKey(IntPtr hWnd, int id, KeyModifiers fsModifiers, int vk); /// &lt;summary&gt; /// 取消注册热键 /// &lt;/summary&gt; /// &lt;param name=\"hWnd\"&gt;要取消热键的窗口的句柄&lt;/param&gt; /// &lt;param name=\"id\"&gt;要取消热键的ID&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [DllImport(\"user32.dll\", SetLastError = true)] public static extern bool UnregisterHotKey( IntPtr hWnd, int id ); /// &lt;summary&gt; /// 向全局原子表添加一个字符串，并返回这个字符串的唯一标识符,成功则返回值为新创建的原子ID,失败返回0 /// &lt;/summary&gt; /// &lt;param name=\"lpString\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [DllImport(\"kernel32\", SetLastError = true)] public static extern short GlobalAddAtom(string lpString); [DllImport(\"kernel32\", SetLastError = true)] public static extern short GlobalDeleteAtom(short nAtom); /// &lt;summary&gt; /// 定义了辅助键的名称（将数字转变为字符以便于记忆，也可去除此枚举而直接使用数值） /// &lt;/summary&gt; [Flags()] public enum KeyModifiers &#123; None = 0, Alt = 1, Ctrl = 2, Shift = 4, WindowsKey = 8 &#125; /// &lt;summary&gt; /// 热键的对应的消息ID /// &lt;/summary&gt; public const int WM_HOTKEY = 0x312; &#125; WPF的处理方法与Winform略微不一致,需要使用HwndSource拦截Window消息,说的简单点也就是自己定义一个消息处理的方法,拦截到的消息如果是定义的快捷键,就执行自己定义的消息处理方法 如果是Contorl+B这种的直接调用即可,Control+Shift+B这种的KeyModifiers需要使用|连接 12345678910private void Window_Loaded(object sender, RoutedEventArgs e)&#123; HwndSource hWndSource; WindowInteropHelper wih = new WindowInteropHelper(this); hWndSource = HwndSource.FromHwnd(wih.Handle); //添加处理程序 hWndSource.AddHook(MainWindowProc); alts = HotKey.GlobalAddAtom(\"Control-Shift-B\"); HotKey.RegisterHotKey(wih.Handle, alts, HotKey.KeyModifiers.Ctrl | HotKey.KeyModifiers.Shift, (int)System.Windows.Forms.Keys.B);&#125; 1234567891011121314151617private IntPtr MainWindowProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)&#123; switch (msg) &#123; case HotKey.WM_HOTKEY: &#123; int sid = wParam.ToInt32(); if (sid == alts) &#123; //按下快捷键需要做的事情 &#125; handled = true; break; &#125; &#125; return IntPtr.Zero;&#125; 现在就已经可以无论中英文状态,按下快捷键都会响应","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"Blend与Ps的交互","slug":"WPF-Blend&Ps","date":"2020-07-03T16:00:00.000Z","updated":"2020-07-04T03:07:46.106Z","comments":true,"path":"2020/07/04/WPF-Blend&Ps/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/04/WPF-Blend&Ps/","excerpt":"每天都学习一点WPF相关的知识，虽然我不太想从事CS前端类的工作，但是其实我也不知道自己想干什么…","text":"每天都学习一点WPF相关的知识，虽然我不太想从事CS前端类的工作，但是其实我也不知道自己想干什么… 获取PS文件的Path1&lt;Path Stroke=\"Black\" StrokeThickness=\"2\" Margin=\"450,20,0,0\" Data=\"M 0,0 C 250,0 50,200 300,200 M 50,50 A 20,20 0 1 0 70,70\"&gt; Path好用,但是Data难求,只要有Data就可以很容易画出复杂图形,虽然自从2015之后的Blend取消了导入Psd文件,但是可以从图层中复制svg,然后粘贴到文本编辑器中,就可以获取Path数据 1234567&lt;svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"3.44cm\" height=\"0.406cm\"&gt;&lt;path fill-rule=\"evenodd\" stroke=\"rgb(0, 0, 0)\" stroke-width=\"1px\" stroke-linecap=\"butt\" stroke-linejoin=\"miter\" fill=\"none\" d=\"M6.500,0.500 L91.500,0.500 C98.873,0.500 97.421,10.500 91.500,10.500 L6.500,10.500 C0.079,10.943 -2.443,1.118 6.500,0.500 Z\"/&gt;&lt;/svg&gt; 前提是PS中图形是使用矩形工具这类路径操作画出来的，不然是没有path的 WPF中使用Data将刚才svg中的标签首字母大写,d改为Data,就是取我们想要的信息然后复制,在WPF下直接放入Grid等容器中即可 1&lt;Path x:Name=\"PART_Track\" Stroke=\"Black\" StrokeThickness=\"1\" Data=\"M18,0 L18,0 137,0 M137,0 A2.5,2.5 0 0 1 130,30 L13,30 A1,1 0 0 1 18,0z\"&gt; 这是用代码画的，两条直线，两个圆弧，结果…不明白为什么L画出的直线和A画出的圆弧粗细不一样PS中画好复制Path在WPF中使用的结果好吧，这类工作还是应该交给专业的设计师来做，没有美工基础画出来的都是垃圾…自己画画简单的不复杂的还行…","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"WPF的DataTrigger遇到的问题","slug":"WPF-DataTrigger","date":"2020-06-30T16:00:00.000Z","updated":"2020-07-01T07:39:18.148Z","comments":true,"path":"2020/07/01/WPF-DataTrigger/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/01/WPF-DataTrigger/","excerpt":"DataTrigger这种在xaml里的东西,因为打不了断点,所以很难找出错误到底在哪里,问题点很难定位,所以只能采取避免的方法暂时规避掉,等以后弄明白了再修改…","text":"DataTrigger这种在xaml里的东西,因为打不了断点,所以很难找出错误到底在哪里,问题点很难定位,所以只能采取避免的方法暂时规避掉,等以后弄明白了再修改… DataTrigger不触发12345678910&lt;TabItem x:Name&#x3D;&quot;Cutfilm_param_item&quot; Style&#x3D;&quot;&#123;DynamicResource VerticalTabItemStyle&#125;&quot; Visibility&#x3D;&quot;Collapsed&quot;&gt; &lt;i:Interaction.Triggers&gt; &lt;ei:DataTrigger Binding&#x3D;&quot;&#123;Binding ElementName&#x3D;EnableCutFilm,Path&#x3D;IsChecked&#125;&quot; Value&#x3D;&quot;true&quot;&gt; &lt;ei:ChangePropertyAction TargetName&#x3D;&quot;Cutfilm_param_item&quot; PropertyName&#x3D;&quot;Visibility&quot; Value&#x3D;&quot;Visible&quot;&gt;&lt;&#x2F;ei:ChangePropertyAction&gt; &lt;&#x2F;ei:DataTrigger&gt; &lt;ei:DataTrigger Binding&#x3D;&quot;&#123;Binding ElementName&#x3D;EnableCutFilm,Path&#x3D;IsChecked&#125;&quot; Value&#x3D;&quot;false&quot;&gt; &lt;ei:ChangePropertyAction TargetName&#x3D;&quot;Cutfilm_param_item&quot; PropertyName&#x3D;&quot;Visibility&quot; Value&#x3D;&quot;Collapsed&quot;&gt;&lt;&#x2F;ei:ChangePropertyAction&gt; &lt;&#x2F;ei:DataTrigger&gt; &lt;&#x2F;i:Interaction.Triggers&gt;&lt;&#x2F;TabItem&gt; 上面这部分xaml的目的是,通过一个名为EnableCutFilm的CheckBox的IsChecked属性控制一个名为Cutfilm_param_item的TabItem的显示与隐藏,但是很尴尬,界面初始化结束后,DataTrigger没有触发,再此后切换Tab页,然后DataTrigger才可以正常被触发 解决方法这个问题以前并不存在,但是在我弄了一个数据缓冲区使得点击确定之后(没有保存),下次界面上显示的是上次确定的数据(底层的数据被没有被修改)之后,这个DataTrigger就有问题了,解决办法是写一个转换器直接绑定&lt;TabItem x:Name=&quot;Cutfilm_param_item&quot; Style=&quot;{DynamicResource VerticalTabItemStyle}&quot; Visibility=&quot;{Binding ElementName=EnableCutFilm,Path=IsChecked,Converter={StaticResource FilmCuttingConverter}}&quot;&gt; 123456789101112131415161718public class FilmCuttingConverter : IValueConverter &#123; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; if ((bool)value == true) return Visibility.Visible; else return Visibility.Collapsed; &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; if (Visibility.Visible == (Visibility)value) return true; else return false; &#125; &#125; 这样界面初始化结束,就会根据从下面读到的状态直接控制TabItem的显示隐藏,不会出现不触发的情况","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"WPF绘制坐标系,实现折线编辑","slug":"WPF-CoordinateSystem","date":"2020-06-29T16:00:00.000Z","updated":"2020-06-30T01:30:44.751Z","comments":true,"path":"2020/06/30/WPF-CoordinateSystem/","link":"","permalink":"https://www.lubaobao.xyz/2020/06/30/WPF-CoordinateSystem/","excerpt":"三个月之前做的一个控件,功能是实现曲线编辑(折线,光滑未实现),因为开发经验不足并且那个控件的位置大小几乎都是确定的,所以当时没考虑到移到别的地方,很多地方都是写死的,后期修改工作量太大…所以现在将其修改为大小可变的坐标系…","text":"三个月之前做的一个控件,功能是实现曲线编辑(折线,光滑未实现),因为开发经验不足并且那个控件的位置大小几乎都是确定的,所以当时没考虑到移到别的地方,很多地方都是写死的,后期修改工作量太大…所以现在将其修改为大小可变的坐标系… 绘制坐标轴和刻度WPF的坐标系是从左上角为原点,向右的方向为x轴,向下的方向为y轴,所以使用canvas容器布局需要进行旋转,将坐标系旋转为正常的笛卡尔坐标系…因为要动态的修改大小,所以刻度和刻度线就不可以都画在xaml里… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/// &lt;summary&gt;/// 绘制坐标轴和刻度/// &lt;/summary&gt;private void DrawAxisAndText()&#123; for (int i = 0; i &lt; 10; ++i) &#123; //左右两条线xaml里面画 if (i != 0 || i != 9) &#123; //坐标线 Line lineX = new Line() &#123; Stroke = new SolidColorBrush(Colors.White), StrokeDashArray = new DoubleCollection(6), StrokeThickness = 1, &#125;; Canvas.SetZIndex(lineX, 0); Line lineY = new Line() &#123; Stroke = new SolidColorBrush(Colors.White), StrokeDashArray = new DoubleCollection(6), StrokeThickness = 1, &#125;; Canvas.SetZIndex(lineY, 0); lineX.X1 = (double)((decimal)CanvasInPath.Width / 10) * i; lineX.X2 = (double)((decimal)CanvasInPath.Width / 10) * i; lineX.Y1 = 0; lineX.Y2 = CanvasInPath.Height; lineY.X1 = 0; lineY.X2 = CanvasInPath.Width; lineY.Y1 = (double)((decimal)CanvasInPath.Height / 10) * i; lineY.Y2 = (double)((decimal)CanvasInPath.Height / 10) * i; CanvasInPath.Children.Add(lineX); CanvasInPath.Children.Add(lineY); &#125; //刻度 if (i &lt; 9) &#123; TextBlock xblock = new TextBlock(); xblock.Foreground = new SolidColorBrush(Colors.White); xblock.FontSize = 10; TranslateTransform translateTransform = new TranslateTransform(0, xblock.ActualHeight); ScaleTransform scaleTransform = new ScaleTransform(); scaleTransform.ScaleY = -1; TransformGroup transformGroup = new TransformGroup(); transformGroup.Children.Add(translateTransform); transformGroup.Children.Add(scaleTransform); xblock.RenderTransform = transformGroup; xblock.Text = (i + 1) * 10 + \"%\"; Canvas.SetLeft(xblock, TransFromX((i + 1) * 10)); Canvas.SetTop(xblock, 15); CanvasInPath.Children.Add(xblock); Canvas.SetZIndex(xblock, 1); TextBlock yblock = new TextBlock(); yblock.Foreground = new SolidColorBrush(Colors.White); yblock.FontSize = 10; translateTransform = new TranslateTransform(0, yblock.ActualHeight); scaleTransform = new ScaleTransform(); scaleTransform.ScaleY = -1; transformGroup = new TransformGroup(); transformGroup.Children.Add(translateTransform); transformGroup.Children.Add(scaleTransform); yblock.RenderTransform = transformGroup; yblock.Text = (i + 1) * 10 + \"%\"; Canvas.SetLeft(yblock, 5); Canvas.SetTop(yblock, TransFromY((i + 1.5) * 10)); CanvasInPath.Children.Add(yblock); Canvas.SetZIndex(yblock, 1); &#125; &#125;&#125; 把整个画布的宽和高分成十份,均匀的画线,然后在线的中间画上刻度… 效果图 坐标转换输入小球对应的刻度,转换为canvas容器里对应的坐标,也就是leftproperty和topproperty,另外left和top属性设置的位置是小球的左下角,想设置为小球正中心需要减去小球的长度的1/2 12345678910111213/// &lt;summary&gt;/// 转换Canvas坐标/// &lt;/summary&gt;/// &lt;param value=\"坐标轴的刻度\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private double TransFromX(double value)&#123; return (double)(((decimal)value / 10) * (decimal)(CanvasInPath.Width) / 10 - (decimal)XOffset);&#125;private double TransFromY(double value)&#123; return (double)(((decimal)value / 10) * (decimal)(CanvasInPath.Height) / 10 - (decimal)YOffset);&#125; 如果需要DataGrid实时显示小球的位置,需要将小球的对应的刻度更新到ViewModel,所以还需要根据小球对象获取小球对应的刻度 1234567891011/// &lt;summary&gt;/// 获取小球的坐标轴刻度/// &lt;/summary&gt;/// &lt;param dot=\"小球对象\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private double[] GetValueOfAxis(Ellipse dot)&#123; double x1 = (double)((decimal)(Canvas.GetLeft(dot) + XOffset) / (decimal)(CanvasInPath.Width / 100)); double y1 = (double)((decimal)(Canvas.GetTop(dot) + YOffset) / (decimal)(CanvasInPath.Height / 100)); return new double[2] &#123; x1, y1 &#125;;&#125; 根据上面的方法,封装一个设置小球位置的函数,这里小球我直接用的Ellipse,正确做法应该是做成一个单独的控件,以后要想改小球的大小和颜色只需要改动小球控件 12345678910111213/// &lt;summary&gt;/// 设置点的位置/// &lt;/summary&gt;/// &lt;param dot=\"小球对象\"&gt;&lt;/param&gt;/// &lt;param x=\"x轴刻度\"&gt;&lt;/param&gt;/// &lt;param y=\"y轴刻度\"&gt;&lt;/param&gt;private void SetDotPosition(Ellipse dot, double x, double y)&#123; double xpoint = TransFromX(x); double ypoint = TransFromY(y); Canvas.SetLeft(dot, xpoint); Canvas.SetTop(dot, ypoint);&#125; 然后加上小球的拖动,更新线段的位置,就实现了小球在坐标系里的移动,然后实现窗口大小改变,坐标轴更新,小球位置更新,线段更新即可 改变窗口大小①保存改变之前小球对应的刻度(位置)②canvas内所有元素移除③canvas的大小根据改变后的窗口大小重新赋值,坐标轴最大值也根据窗口大小赋值④canvas加入小球和线段⑤画坐标系,根据保存的刻度设置小球位置,更新线段 1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 尺寸改变,重绘/// &lt;/summary&gt;private void Window_SizeChanged(object sender, SizeChangedEventArgs e)&#123; if (this.Width != 500 || this.Height != 600) &#123; double[] dot1value = GetValueOfAxis(DutyCycleCurveDot1); double[] dot2value = GetValueOfAxis(DutyCycleCurveDot2); CanvasInPath.Children.Clear(); CanvasInPath.Height = this.ActualHeight - 100; CanvasInPath.Width = this.ActualWidth; MaxCoordinateAxisX = this.ActualWidth; MaxCoordinateAxisY = this.ActualHeight - 100; CanvasInPath.Children.Add(DutyCycleCurveDot1); CanvasInPath.Children.Add(DutyCycleCurveDot2); CanvasInPath.Children.Add(DutyCycleLineList[0]); CanvasInPath.Children.Add(DutyCycleLineList[1]); CanvasInPath.Children.Add(DutyCycleLineList[2]); DrawAxisAndText(); SetDotPosition(DutyCycleCurveDot1, dot1value[0], dot1value[1]); SetDotPosition(DutyCycleCurveDot2, dot2value[0], dot2value[1]); UpdateLineAndDot(DutyCycleDotList, DutyCycleLineList); &#125;&#125; 效果演示","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"C#复杂类型的深拷贝,并解决CodeRunner的输出窗口乱码","slug":"CSharp-deepcopy","date":"2020-06-22T12:54:04.418Z","updated":"2020-06-22T12:54:04.418Z","comments":true,"path":"2020/06/22/CSharp-deepcopy/","link":"","permalink":"https://www.lubaobao.xyz/2020/06/22/CSharp-deepcopy/","excerpt":"C#中的等号和C++的等号,并不相同因为=在引用类型中的使用，仅仅是创建了一个新的引用变量，并没有复制真正的内容，所以我们需要深拷贝","text":"C#中的等号和C++的等号,并不相同因为=在引用类型中的使用，仅仅是创建了一个新的引用变量，并没有复制真正的内容，所以我们需要深拷贝 引用类型使用“=”12345678910111213141516static void Main(string[] args) &#123; Person p1 = new Person(); p1.Name = \"Luzihan\"; p1.Job = \"在家玩游戏\"; Person p2 = new Person(); p2 = p1; p1.Name = \"Lubaobao\"; p1.Job = \"还是在家打游戏\"; Console.WriteLine(p1.Name); Console.WriteLine(p1.Job); Console.WriteLine(p2.Name); Console.WriteLine(p2.Job); &#125; 这样的最直接后果就是，修改了p1的内容，导致p2的内容也被修改了很显然这不是我们想要的，这是因为=在引用类型中的使用，仅仅是创建了一个新的引用变量，并没有复制真正的内容，所以我们需要深拷贝 XML序列化反序列化完成深拷贝12345678910111213public static T DeepCopyByXml&lt;T&gt;(T obj)&#123; object result; using (MemoryStream ms = new MemoryStream()) &#123; XmlSerializer xmlSerializer = new XmlSerializer(typeof(T)); xmlSerializer.Serialize(ms, obj); ms.Seek(0, SeekOrigin.Begin); result = xmlSerializer.Deserialize(ms); ms.Close(); &#125; return (T)result;&#125; 使用深拷贝之后的结果，很明显，p2的内容不会因为p1的修改而修改 VsCode中CodeRunner插件输出窗口中文乱码还是之前的代码,打印”在家玩游戏”和”还是在家打游戏”出现乱码修改VsCode右下角的通过编码打开，通过编码保存设置为gbk什么的都不行 网上大多数说的确实是对的，确实是因为cmd的编码格式造成的，但是我只想要VsCode的输出窗口正常，调试也正常，所以我不需要去设置cmd，cmd和我有什么关系？设置cmd或者全部使用utf-8也可能会导致其他的问题 ①网上建议的,CodeRunner使用终端确实可以解决,但是我不喜欢终端的字体,我就喜欢输出窗口的风格,和设置的字体统一example:&quot;csharp&quot;:&quot;clear &amp;&amp; cd $dir &amp;&amp; csc /nologo $fileName &amp;&amp; ./$fileNameWithoutExt&quot;,&quot;code-runner.runInTerminal&quot;: true ②如果是Windows平台：SettingJson中code-runner.executorMap里Csharp相关的前面加上chcp 65001，不需要修改cmd只需要修改vscode这里example：&quot;csharp&quot;: &quot;chcp 65001 &amp;&amp; cd $dir &amp;&amp; echo= &amp;&amp; csc /nologo /utf8output $fileName &amp;&amp; $fileNameWithoutExt&quot;, ③Linux下就不存在乱码,但是如果是RemoteSSH连接到服务器,怎么使用CodeRunner呢?还是刚才的设置,服务器提前安装monoexample:&quot;csharp&quot;: &quot;csc /nologo /utf8output $fileName &amp;&amp; mono $fileNameWithoutExt.exe&quot;, 一些问题经过上面的操作，C#的话，无论CodeRunner还是F5都没有乱码的问题但是C++的话，CodeRunner没有问题，但是调试会乱码 ①cpp代码中加入控制台代码12system(\"chcp 65001\"); system(\"cls\"); 虽然能解决，但是这么麻烦所以一般都不会这么做的，想一个办法把这两句代码自动先运行 ②使用attribute((constructor))使用attribute((constructor)),放在函数声明后，表示在main函数调用前，先调用此函数，同样的还有attribute((destructor))，表示在main函数调用exit（）之后调用此函数 在.vscode文件夹下创建一个head.h头文件 1234567#include &lt;stdlib.h&gt;static void before(void) __attribute__((constructor));static void before()&#123; system(\"chcp 65001\"); system(\"cls\");&#125; 然后把task.json中的参数修改一下&quot;args&quot;: [&quot;-g&quot;,&quot;${file}&quot;,&quot;-include&quot;,&quot;${workspaceRoot}\\\\.vscode\\\\head.h&quot;,&quot;-o&quot;,&quot;${fileBasenameNoExtension}.exe&quot;],其他不需要什么操作了，直接F5试一下","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"C#三维坐标转换为二维坐标","slug":"CSharp-translate","date":"2020-03-09T16:00:00.000Z","updated":"2020-06-22T12:54:32.805Z","comments":true,"path":"2020/03/10/CSharp-translate/","link":"","permalink":"https://www.lubaobao.xyz/2020/03/10/CSharp-translate/","excerpt":"刚开始学习图形跟随模块的时候,观察不仔细,只想着平面实现,导致以后的实现越来越困难,代码量越来越多,其实本来不需要那么麻烦,输入的都是三维的坐标,呈现上界面上的才是二维坐标…","text":"刚开始学习图形跟随模块的时候,观察不仔细,只想着平面实现,导致以后的实现越来越困难,代码量越来越多,其实本来不需要那么麻烦,输入的都是三维的坐标,呈现上界面上的才是二维坐标… 三维坐标转换为二维坐标矩阵变换什么的最烦了…我先写下来以防以后忘记… 123456mixtrl是一个矩阵[1 0 0 0 1 0 0 0 1]下面这个函数是我用来画三维坐标系的 1234567891011121314151617181920public POINT2D Transform3DTo2D(POINT3D pt3d)&#123; POINT2D result = new POINT2D(); double x = pt3d.x; double y = pt3d.y; double z = pt3d.z; double xTOx = (mixtrl[0] * x + mixtrl[1] * y + mixtrl[2] * z) * needXReverxe; double yTox = (mixtrl[3] * x + mixtrl[4] * y + mixtrl[5] * z) * needYReverxe; double zTox = (mixtrl[6] * x + mixtrl[7] * y + mixtrl[8] * z) * needZReverxe; double xx = -1 * Math.Cos(150 * 0.017453) * xTOx - Math.Cos(150 * 0.017453) * yTox; double yy = Math.Sin(150 * 0.017453) * xTOx - Math.Sin(150 * 0.017453) * yTox - zTox; result.x = orginPoint.X + xx; result.y = orginPoint.Y + yy; return result;&#125; 三维坐标(或二维坐标)的旋转以某个轴为旋转轴,实际上,只在垂直于坐标轴的平面做二维旋转 二维12x &#x3D; xcosα - ysinαy &#x3D; xsinα + ycosα 三维1234567891011121314绕x轴旋转x1 &#x3D; x;y1 &#x3D; ycosα - zsinα;z1 &#x3D; zcosα + ysinα;绕y轴旋转x1 &#x3D; xcosα - zsinα;y1 &#x3D; y;z1 &#x3D; zcosα + xsinα;绕z轴旋转x1 &#x3D; xcosα - ysinα;y1 &#x3D; ycosα + xsinα;z1 &#x3D; z; 角度自己设定,我自己设置每次转20° C#中的三角函数计算传入的参数为弧度… 1234567891011121314151617181920212223242526272829303132333435363738394041424344public POINT3D TransRoll(POINT3D pt3d,int RollFlag,double angle)&#123; POINT3D result = new POINT3D(); double x = pt3d.x; double y = pt3d.y; double z = pt3d.z; double cos = Math.Cos(angle * (Math.PI / 180)); double sin = Math.Sin(angle * (Math.PI / 180)); //绕x轴 if (RollFlag == 0) &#123; double x1 = x; double y1 = y * cos - z * sin; double z1 = z * cos + y * sin; result.x = x1; result.y = y1; result.z = z1; &#125; else if(RollFlag == 1) &#123; double x1 = x * cos - z * sin; double y1 = y; double z1 = z * cos + x * sin; result.x = x1; result.y = y1; result.z = z1; &#125; else &#123; double x1 = x * cos - y * sin; double y1 = y * cos + x * sin; double z1 = z; result.x = x1; result.y = y1; result.z = z1; &#125; return result;&#125; 绘制椎体一条由坐标原点到空间某点的线段，绕某个轴旋转一周，就形成了一个圆锥体 画圆同理，BresenHam画圆算法也可以 12345678910111213141516171819202122232425262728public void paintCone(POINT3D pt3d)&#123; POINT2D pt2d = new POINT2D(); Graphics graphics = this.CreateGraphics(); Pen pen = new Pen(Color.Yellow, 2); for (double i = 1; i &lt;= 360; ++i) &#123; pt2d = Transform3DTo2D(TransRoll(pt3d, 2, i)); graphics.DrawLine(pen, orginPoint, new Point((int)pt2d.x, (int)pt2d.y)); &#125; pen = new Pen(Color.Red, 2); POINT3D circlePT3D = new POINT3D(0, pt3d.y, pt3d.z); POINT2D circlePT2D = new POINT2D(); circlePT2D = Transform3DTo2D(circlePT3D); for (double i = 1; i &lt;= 360; ++i) &#123; pt2d = Transform3DTo2D(TransRoll(circlePT3D, 2, i)); graphics.DrawLine(pen, new Point((int)circlePT2D.x, (int)circlePT2D.y), new Point((int)pt2d.x, (int)pt2d.y)); &#125; graphics.Dispose();&#125; 最终效果x，y轴反向 绕z轴旋转20°和绕z轴旋转-20° 三角形绕z轴旋转z轴反向（带椎体）","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"C#聊天气泡框","slug":"CSarp-chatmessagebox","date":"2020-02-22T16:00:00.000Z","updated":"2020-06-23T00:31:01.186Z","comments":true,"path":"2020/02/23/CSarp-chatmessagebox/","link":"","permalink":"https://www.lubaobao.xyz/2020/02/23/CSarp-chatmessagebox/","excerpt":"气泡虽然是用的别人写好的方法,自己做的东西很少,大多是学习但是完成了学习编程以来一直的梦想,做一个好看点的聊天界面…","text":"气泡虽然是用的别人写好的方法,自己做的东西很少,大多是学习但是完成了学习编程以来一直的梦想,做一个好看点的聊天界面… 思路：借鉴自C# winform socket 初学者示例大佬的示例下载链接: https://pan.baidu.com/s/1i6r0Sa1JNp0-BCMEX1L6Hw 提取码:v751 注释及说明:https://www.cnblogs.com/qiaoke/p/6358050.html 界面组成：头像+气泡头像使用PictureBox，绘制成圆形图片气泡使用圆角矩形+尖角，创建panel使用bitemap填充 最终效果： 界面布局：panel+pictureBox 主要方法:绘制圆角矩形和圆图片:(学习自上面示例)12345678910111213141516171819202122232425262728public static GraphicsPath DrawRoundRect(int x, int y, int width, int height, int radius)&#123; //四边圆角 GraphicsPath gp = new GraphicsPath(); gp.AddArc(x, y, radius, radius, 180, 90); gp.AddArc(width - radius, y, radius, radius, 270, 90); gp.AddArc(width - radius, height - radius, radius, radius, 0, 90); gp.AddArc(x, height - radius, radius, radius, 90, 90); gp.CloseAllFigures(); return gp;&#125; //绘制圆图片private Image CutEllipse(Image img, Rectangle rec, Size size)&#123; Bitmap bitmap = new Bitmap(size.Width, size.Height); using (Graphics g = Graphics.FromImage(bitmap)) &#123; using (TextureBrush br = new TextureBrush(img, System.Drawing.Drawing2D.WrapMode.Clamp, rec)) &#123; br.ScaleTransform(bitmap.Width / (float)rec.Width, bitmap.Height / (float)rec.Height); g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias; g.FillEllipse(br, new Rectangle(Point.Empty, size)); &#125; &#125; return bitmap;&#125; 搜索框界面思路:窗体的resize属性修改窗体大小根据目前的窗体大小调整 窗体大小先设置为不可更改,以后在完善 12345678910111213141516171819202122232425262728private void button2_Click(object sender, EventArgs e) &#123; if(Form1.form1.Size.Width == 654) &#123; Form1.form1.Size = new System.Drawing.Size(954, 558); Form1.form1.REDI_HISTORY.Visible = true; Form1.form1.LAB_SEARCH.Visible = true; Form1.form1.EDI_SEARCH.Visible = true; Form1.form1.BTN_SEARCH.Visible = true; Form1.form1.EDI_SEARCH.Focus(); //显示在最下方 Form1.form1.REDI_HISTORY.Select(Form1.form1.REDI_HISTORY.TextLength, 0); Form1.form1.REDI_HISTORY.ScrollToCaret(); &#125; else &#123; Form1.form1.REDI_HISTORY.Visible = false; Form1.form1.LAB_SEARCH.Visible = false; Form1.form1.EDI_SEARCH.Visible = false; Form1.form1.BTN_SEARCH.Visible = false; Form1.form1.Size = new System.Drawing.Size(654, 558); EDI_SEARCH.Clear(); Form1.form1.REDI_MESSAGE.Focus(); &#125; &#125; 搜索框界面布局: 搜索框最终效果:服务端使用mono放在Linux下文字搜索数字搜索 搜索框代码实现:倒排索引什么的不会弄,所以只能用正则将就一下了… 数字的搜素区别不大,只是正则表达式变一下“\\w{3}:\\d{4}/\\d{1,2}/\\d{1,2} \\d{1,2}:\\d{2}:\\d{2}” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152List&lt;string&gt; info = new List&lt;string&gt;(); //string pattern = @\"\\w&#123;0,&#125;[\" + searchInfo + @\"]&#123;\" + searchInfo.Length + @\"&#125;\\w&#123;0,&#125;\"; string pattern = @\"\\w&#123;0,&#125;\" + searchInfo + @\"\\w&#123;0,&#125;\"; foreach (Match each in Regex.Matches(history, pattern)) &#123; info.Add(each.Value); &#125; //获取索引 List&lt;int&gt; indexList = new List&lt;int&gt;(); for (int i=0;i&lt;info.Count;++i) &#123; indexList.Add(getIndex(info[i], history)); &#125; //获取用户名和时间信息 ArrayList nameAndTime = new ArrayList(); ArrayList tempList = new ArrayList(); for (int i = 0; i &lt; indexList.Count; ++i) &#123; if((int)indexList[i] == -1) &#123; continue; &#125; string temp = history.Substring(0, (int)indexList[i]); foreach (Match each in Regex.Matches(temp, @\"\\w&#123;3&#125;\\:\\d&#123;4&#125;\\/\\d&#123;1,2&#125;\\/\\d&#123;1,2&#125; \\d&#123;2&#125;\\:\\d&#123;2&#125;\\:\\d&#123;2&#125;\")) &#123; tempList.Add(each.Value); &#125; nameAndTime.Add(tempList[tempList.Count - 1]); tempList.Clear(); &#125; //刷新历史记录框 REDI_HISTORY.Clear(); for(int i=0;i&lt;info.Count;++i) &#123; REDI_HISTORY.AppendText(nameAndTime[i].ToString() + \"\\r\\n\"); REDI_HISTORY.AppendText(info[i] + \"\\r\\n\"); if (nameAndTime[i].ToString().Substring(0, 3) == user.username) &#123; chatm.changeColorHistory(nameAndTime[i].ToString(), Color.Green); &#125; else &#123; chatm.changeColorHistory(nameAndTime[i].ToString(), Color.Blue); &#125; chatm.changeColorHistory(searchInfo, Color.Red); &#125;","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"C#中调用C++dll","slug":"CSarp-interaction","date":"2019-12-19T16:00:00.000Z","updated":"2020-06-23T10:27:24.383Z","comments":true,"path":"2019/12/20/CSarp-interaction/","link":"","permalink":"https://www.lubaobao.xyz/2019/12/20/CSarp-interaction/","excerpt":"校招是肯定没戏了..19年是20界的校招…","text":"校招是肯定没戏了..19年是20界的校招… C#中调用C++dll C++代码 123456789101112131415161718192021222324252627282930313233343536#ifdef MATH_EXPORTS#define MATH_API __declspec(dllexport)#else#define MATH_API __declspec(dllimport)#endifextern \"C\"&#123; class MATH_API CMath &#123; public: CMath(void); int Math_Add(int a, int b) &#123; return a + b; &#125; int Math_Sub(int a, int b) &#123; return a - b; &#125; int Math_Col(int a, int b) &#123; return a * b; &#125; int Math_Dev(int a, int b) &#123; return a / b; &#125; &#125;;&#125;extern MATH_API int nMath;MATH_API int fnMath(void); C#代码 1234567891011121314151617181920212223242526272829303132333435363738using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Runtime.InteropServices;using System.Threading.Tasks;namespace test&#123; public class func &#123; [DllImport(@\"C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll\",EntryPoint=\"?Math_Add@CMath@@QAEHHH@Z\")] public static extern int Math_Add(int a,int b); [DllImport(@\"C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll\", EntryPoint = \"?Math_Sub@CMath@@QAEHHH@Z\")] public static extern int Math_Sub(int a, int b); [DllImport(@\"C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll\", EntryPoint = \"?Math_Col@CMath@@QAEHHH@Z\")] public static extern int Math_Col(int a, int b); [DllImport(@\"C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll\", EntryPoint = \"?Math_Dev@CMath@@QAEHHH@Z\")] public static extern int Math_Dev(int a, int b); &#125; class Program &#123; static void Main(string[] args) &#123; int a = func.Math_Add(5, 6); Console.WriteLine(a); a = func.Math_Sub(6, 5); Console.WriteLine(a); a = func.Math_Col(6, 5); Console.WriteLine(a); a = func.Math_Dev(12, 3); Console.WriteLine(a); &#125; &#125;&#125; 遇到的问题 dll引用添加不成功,报错如下：无法加载DLL”**.dll”:找不到指定的模块 建议使用vs 2013创建win32程序—&gt;下一步—&gt;dll,然后编辑,不要创建windows控制台程序然后修改配置类型为动态库,如果不成功,调到第三个问题 找不到程序入口点 使用dumpbin工具查看C++中函数编译之后的名称,C#中EntryPoint中填入 引用添加不成功 有效解决办法就是使用DllImport,不要添加引用了[DllImport(@”C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll”,EntryPoint=”?Math_Add@CMath@@QAEHHH@Z”)]正常应该放在bin目录下,这里是错误的编码习惯,懒 很久没写了,偶尔来两篇吧,都懒得改颜色了,想想以前,唉","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"VSCodeRemote SSH公钥免密登录，远离xshell，摆脱vim","slug":"VSCode-remotessh","date":"2019-08-30T16:00:00.000Z","updated":"2020-06-24T09:30:25.641Z","comments":true,"path":"2019/08/31/VSCode-remotessh/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/31/VSCode-remotessh/","excerpt":"比起VIM的纯键盘操作,我更喜欢鼠标加键盘的操作方式…所以能想办法替代VIM就想办法替代..虽然我也不是服务器开发..","text":"比起VIM的纯键盘操作,我更喜欢鼠标加键盘的操作方式…所以能想办法替代VIM就想办法替代..虽然我也不是服务器开发.. 安装插件：微软的宇宙第一IDE让人使用之后欲罢不能，那么Linux编程有没有好用的IDE呢？ 最近VS Code出了一个插件，对我这种vim使用很不舒服的人来说简直是爱极了！~ 注意： 要想完全不使用xshell，vs code必须安装编译器 否则写完代码无法编译，毕竟vs code只是编辑器 要想让vs code的C/C++自动补全更加智能，需要安装llvm 但是，萝卜青菜，各有所爱，vs code对我而言只是一款编辑代码的工具，我不想为了编译代码再花更多时间，我只是不喜欢vim而已，xshell上使用gcc和g++那么方便为什么不呢？ 首先，搜索Remote SSH，安装然后左下角多了一个按钮 生成公钥：配置好之后，就可以连接服务器了，但是问题来了，每次都要输入两次密码很烦 所以我们使用ssh生成一份公钥，openssh组件是windows 1809之后的版本推出的 如果不想升级系统，也不想安装openssh，那么请往下看~ 使用过github的小伙伴看到下面这个东西是不是很亲切？ git 安装完后，bash 、 ssh 、 ssh-keygen 等一些常用的 linux 命令工具都已经安装 打开Git Bash Here进入命令行 切换到目录 cd C:/Users/你电脑的用户名/.ssh/ 生成密钥 ssh-keygen -t rsa -b 4096，回车表示存到当前文件夹 pub文件就是生成的公钥 到这个时候，就快要和vim说拜拜了~ 服务器操作：rz或者直接拖动，将公钥上传到服务器，然后cat显示在屏幕上，复制 然后在服务器键入如下命令：(来源于：https://blog.csdn.net/zhangpeterx/article/details/97375233） 123456789mkdir -p ~&#x2F;.ssh chmod 700 ~&#x2F;.ssh nano ~&#x2F;.ssh&#x2F;authorized_keys 在nano界面 ctrl+v，然后ctrl+x退出，回车表示不更改文件名chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys 可以把xshell关闭了，打开vs code，就会连接服务器，不需要手动输密码 效果截图：","categories":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.lubaobao.xyz/categories/VsCode/"}],"tags":[]},{"title":"【针对性复习】选择排序和归并排序","slug":"Cpp-sort1","date":"2019-08-14T16:00:00.000Z","updated":"2020-06-24T09:30:18.987Z","comments":true,"path":"2019/08/15/Cpp-sort1/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/15/Cpp-sort1/","excerpt":"之前相关内容的博客,只有简略的思路和代码,起不到复习的作用…现在把思路整理清楚,过程图示也画出来,再把代码重新写一遍,争取把排序遗留的问题彻底解决…","text":"之前相关内容的博客,只有简略的思路和代码,起不到复习的作用…现在把思路整理清楚,过程图示也画出来,再把代码重新写一遍,争取把排序遗留的问题彻底解决… 选择排序的思路:从头到尾遍历,找最大的元素的下标,找到之后把最大的元素和最后一个位置的元素交换 易错点: max作为保存最大元素下标的存在,每次使用完应该清零 找到值去交换,最大的元素位置是没有发生变化的 过程图示: 代码示例:1234567891011121314151617181920212223//普通的未经过优化的选择排序void selectSort(int* array, int size)&#123; int end = size - 1; while (end != 0) &#123; int max = 0; int begin =0; for (begin; begin &lt;= end; ++begin) &#123; if (array[max] &lt; array[begin]) &#123; max = begin; &#125; continue; &#125; swap(array[max], array[end]); end--; &#125;&#125; 优化后的选择排序:将一次选择一个最大值变为一次选择一个最大值和最小值 最大值放在最后面的end位置,最小值放在最前面的begin位置 普通选择排序缺陷: 存在大量的重复比较 易错点: index的值每次遍历查找前要重置 minpos和maxpos使用完之后的值也要重置 过程图示: 代码示例:1234567891011121314151617181920212223242526272829303132333435363738void selectSortD(int* array, int size)&#123; int begin = 0; int end = size - 1; while (begin &lt; end) &#123; int index = begin + 1; int minpos = begin; int maxpos = begin; for (index; index &lt;= end; ++index) &#123; if (array[index]&gt;array[maxpos]) &#123; maxpos = index; &#125; if (array[index] &lt; array[minpos]) &#123; minpos = index; &#125; &#125; //如果minpos在最后的位置,把minpos的位置与maxpos互换即可 if (minpos == end) &#123; minpos = maxpos; &#125; swap(array[begin], array[minpos]); swap(array[end], array[maxpos]); begin++; end--; &#125;&#125; 归并排序(递归)的思路:对一组数据,一直均分到一组只有一个元素,然后将其归并,逐步变为有序 易错点: 只有元素有序才可以归并 begin2是以mid开始,如果以mid+1开始,会越界 先处理左半部分,在处理右半部分,都有序之后,归并,写回原数组 归并的时候申请辅助空间如果是在函数里,函数调用结束会释放,所以使用参数传递进去 空间只需要一份,所以不能当作mergeData的参数,因为递归进来每次都会创建 归并数据过程图示:长短不一时,一方写完,另一方还未完,直接把另一方直接写入到后面 归并数据思路: 使用两个指针来依次对比左半部分和右半部分的第一个元素,先把小的放进去 放进去的那部分指针后移,继续比较,一直比到放完为止,长度不一致的情况循环结束单独处理 1234567891011121314151617181920212223242526272829303132333435363738394041void mergeData(int* array,int left,int mid,int right,int* tmp)&#123; int begin1 = left; int end1 = mid; int begin2 = mid; int end2 = right; int index = left; while (begin1 &lt; end1 &amp;&amp; begin2&lt;end2) &#123; if (array[begin1] &lt; array[begin2]) &#123; tmp[index] = array[begin1]; begin1++; index++; &#125; else &#123; tmp[index] = array[begin2]; begin2++; index++; &#125; &#125; //处理长度不一致的情况 while (begin1 &lt; end1) &#123; tmp[index] = array[begin1]; begin1++; index++; &#125; while (begin2&lt;end2) &#123; tmp[index] = array[begin2]; begin2++; index++; &#125;&#125; 为了方便调用,进行一下封装,其实不封装也无所谓,那时候还没学C++所以用malloc,现在自然用new 12345678void mergeSort(int* array, int size)&#123; int* tmp = new int[size]; _mergeSort(array, 0, size, tmp); delete[] tmp;&#125; 说真的,我不是很喜欢递归的归并排序代码,我觉得memcpy那里需要加left真的很难理解 123456789101112131415void _mergeSort(int* array, int left, int right,int* tmp)&#123; if (right - left &gt; 1) &#123; int mid = left + ((right - left) &gt;&gt; 1); _mergeSort(array, left, mid, tmp); _mergeSort(array, mid, right, tmp); mergeData(array, left, mid, right, tmp); memcpy(array + left, tmp + left, sizeof(int)*(right - left)); &#125;&#125; 不加left每次拷贝都会拷贝到左半部分,右半部分永远是空的 0-5这一整体,分组0-1 2-5,处理右边的部分的时候left是2,如果处理完了往回拷贝的时候不加left array默认指向数组第一个元素,等于2-5这边的数据没有接在前两个元素后面,而是有两个把之前的左半部分覆盖了 归并排序(递归)过程图示:其实应该34一组,291一组,但是看思路就行了,这里画的严格按照代码来说是有问题的 归并排序(循环)的思路:与递归不同的是,循环不需要先分组了,因为每个元素都是单独的,可以看作已经分好组了,直接开始归并 易错点: 需要在循环里手动赋予left的值 i应该+=2*gap gap可以看作一组元素的个数,所以left,mid,right的值用gap表示 mid和right有可能会超出size的范围造成越界,需要单独处理 归并排序(循环)过程图示: 归并排序(循环)代码:12345678910111213141516171819202122232425262728293031323334void mergeSortN(int* array, int size)&#123; int* tmp = new int[size]; int gap = 1; while (gap &lt; size) &#123; for (int i = 0; i &lt; size; i += 2 * gap) &#123; int left = i; int mid = left + gap; int right = mid + gap; if (mid &gt; size) &#123; mid = size; &#125; if (right &gt; size) &#123; right = size; &#125; mergeData(array, left, mid, right, tmp); &#125; memcpy(array, tmp, sizeof(int)*size); gap *= 2; &#125; delete[] tmp;&#125; 至此,排序所有的内容基本都搞清楚了,短时间也不太可能会忘,忘了再过来看看就行了,开始新的篇章~","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]},{"title":"【针对性复习】选择排序和归并排序","slug":"Cpp-sort0","date":"2019-08-02T16:00:00.000Z","updated":"2020-06-24T09:33:13.771Z","comments":true,"path":"2019/08/03/Cpp-sort0/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/03/Cpp-sort0/","excerpt":"针对选择题中排序过程的复习","text":"针对选择题中排序过程的复习 快排递归框架：123456789void QuickDSort(int* array, int left, int right)&#123; if (right - left &gt; 1) &#123; int div = partion(array, left, right); QuickDSort(array, left, div); QuickDSort(array, div + 1, right); &#125;&#125; 划分区间:先想办法拿到一个基准值,进而才可以划分,但是直接把right-1的位置的元素作为基准值有可能极端情况下性能爆炸差,所以引入特殊的取值方法 三值取中法:顾名思义,就是取三个值,选出一个中间值作为基准值,能极大程度避免取的基准值太极端 a b,如果c比a还小,那a就是中间值 a b,如果c比b还大,那b就是中间值 如果都不是,说明c就是中间值 b a,情况同上处理 12345678910111213141516171819202122232425262728293031323334353637383940int GetMidIndex(int* array, int left, int right)&#123; int mid = left + ((right - left) &gt;&gt; 1); //a b if (array[left] &lt; array[right - 1]) &#123; //c&lt;a ,a就是mid if (array[mid] &lt; array[left]) &#123; return left; &#125; //c&gt;b,b就是mid else if (array[mid]&gt;array[right - 1]) &#123; return right - 1; &#125; else &#123; return mid; &#125; &#125; else &#123; //b a,c&lt;b,b就是mid if (array[mid] &lt; array[right - 1]) &#123; return right - 1; &#125; //b a,c&gt;a,a就是mid else if (array[mid]&gt;array[left]) &#123; return left; &#125; else &#123; return mid; &#125; &#125;&#125; 取好基准值之后,就可以进行元素的比较了,把左侧元素调整为都比基准值小,右侧都比基准值大 比较方法:定义两个指针,一个在前,一个在后,因为对数组操作,所以可以用数组下标代替 begin从前找比基准值大的元素,没有就begin++,直到找到 end同理,从后找比基准值小的元素,没有就end–,直到找到 找到的话,begin和end的位置如果不一样,就交换元素 最终将基准值放好(因为一开始把基准值和right-1位置的元素互换了) 要和right-1位置换,因为end是变化的 12345678910111213141516171819202122232425262728293031323334353637383940int partion(int* array, int left, int right)&#123; int mid = GetMidIndex(array, left, right); swap(array[mid], array[right - 1]); int begin = left; int end = right - 1; int key = array[right - 1]; while (begin&lt;end) &#123; //从左往右找比基准值大的元素 while (begin &lt; end&amp;&amp;array[begin] &lt;= key) &#123; begin++; &#125; //从右往左找比基准值小的元素 while (begin &lt; end&amp;&amp;array[end] &gt;= key) &#123; end--; &#125; //找到之后 if (begin != end) &#123; swap(array[begin], array[end]); &#125; &#125; //放置基准值 if (begin != right - 1) &#123; swap(array[begin], array[right - 1]); &#125; return begin;&#125; 流程示意图:","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]}],"categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"},{"name":"HTML","slug":"HTML","permalink":"https://www.lubaobao.xyz/categories/HTML/"},{"name":"VsCode","slug":"VsCode","permalink":"https://www.lubaobao.xyz/categories/VsCode/"},{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]}