{"meta":{"title":"AustinYAN's Blog","subtitle":"","description":"","author":"染墨灬若流云","url":"https://www.lubaobao.xyz","root":"/"},"pages":[{"title":"","date":"2021-05-16T09:11:59.861Z","updated":"2021-05-16T09:11:59.859Z","comments":true,"path":"about/index.html","permalink":"https://www.lubaobao.xyz/about/index.html","excerpt":"","text":".center { position: fixed; left: 20%; right: 20%; top: 10%; width: 60%; height: 15%; opacity: 0.95; float: left; background-color: white; } .centerAfterLeft { position: fixed; left: 20%; top: 26%; width: 29.5%; height: 50%; opacity: 0.95; float: left; background-color: white; } .centerAfterRight { position: fixed; right: 20%; top: 26%; width: 29.5%; height: 50%; opacity: 0.95; float: left; background-color: white; } .footer { position: fixed; left: 20%; right: 20%; top: 77%; width: 60%; height: 15%; opacity: 0.95; background-color: white; } .lastfooter { position: fixed; left: 20%; right: 20%; top: 93%; width: 60%; height: 30px; vertical-align: middle; text-align: center; background-color: transparent; } #selfphoto { margin-left: 10px; margin-top: 5px; float: left; } #selfphoto img { border-radius: 50%; vertical-align: middle; -webkit-animation: rotateImg 5s linear infinite; } @keyframes rotateImg { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } @-webkit-keyframes rotateImg { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } } body { background-color: rgb(81, 77, 85); font-family: 楷体; } /*样式二*/ /* 控制下雪 */ function snowFall(snow) { /* 可配置属性 */ snow = snow || {}; this.maxFlake = snow.maxFlake || 400; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */ } /* 兼容写法 */ requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) { setTimeout(callback, 1000 / 60); }; cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame; /* 开始下雪 */ snowFall.prototype.start = function () { /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this) } /* 创建画布 */ function snowCanvas() { /* 添加Dom结点 */ var snowcanvas = document.createElement(\"canvas\"); snowcanvas.id = \"snowfall\"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute(\"style\", \"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;\"); document.getElementsByTagName(\"body\")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext(\"2d\"); /* 窗口大小改变的处理 */ window.onresize = function () { snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ } } /* 雪运动对象 */ function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) { this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */ } flakeMove.prototype.update = function () { var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY = canvas.width || this.x = canvas.height || this.y"},{"title":"所有分类","date":"2021-03-24T04:02:13.750Z","updated":"2020-06-22T12:52:46.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.lubaobao.xyz/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C#复杂类型的深拷贝,并解决CodeRunner的输出窗口乱码","slug":"CSharp-deepcopy","date":"2021-03-24T04:02:14.197Z","updated":"2020-06-22T12:54:04.000Z","comments":true,"path":"2021/03/24/CSharp-deepcopy/","link":"","permalink":"https://www.lubaobao.xyz/2021/03/24/CSharp-deepcopy/","excerpt":"C#中的等号和C++的等号,并不相同因为=在引用类型中的使用，仅仅是创建了一个新的引用变量，并没有复制真正的内容，所以我们需要深拷贝","text":"C#中的等号和C++的等号,并不相同因为=在引用类型中的使用，仅仅是创建了一个新的引用变量，并没有复制真正的内容，所以我们需要深拷贝 引用类型使用“=”12345678910111213141516static void Main(string[] args) &#123; Person p1 = new Person(); p1.Name = \"Luzihan\"; p1.Job = \"在家玩游戏\"; Person p2 = new Person(); p2 = p1; p1.Name = \"Lubaobao\"; p1.Job = \"还是在家打游戏\"; Console.WriteLine(p1.Name); Console.WriteLine(p1.Job); Console.WriteLine(p2.Name); Console.WriteLine(p2.Job); &#125; 这样的最直接后果就是，修改了p1的内容，导致p2的内容也被修改了很显然这不是我们想要的，这是因为=在引用类型中的使用，仅仅是创建了一个新的引用变量，并没有复制真正的内容，所以我们需要深拷贝 XML序列化反序列化完成深拷贝12345678910111213public static T DeepCopyByXml&lt;T&gt;(T obj)&#123; object result; using (MemoryStream ms = new MemoryStream()) &#123; XmlSerializer xmlSerializer = new XmlSerializer(typeof(T)); xmlSerializer.Serialize(ms, obj); ms.Seek(0, SeekOrigin.Begin); result = xmlSerializer.Deserialize(ms); ms.Close(); &#125; return (T)result;&#125; 使用深拷贝之后的结果，很明显，p2的内容不会因为p1的修改而修改 VsCode中CodeRunner插件输出窗口中文乱码还是之前的代码,打印”在家玩游戏”和”还是在家打游戏”出现乱码修改VsCode右下角的通过编码打开，通过编码保存设置为gbk什么的都不行 网上大多数说的确实是对的，确实是因为cmd的编码格式造成的，但是我只想要VsCode的输出窗口正常，调试也正常，所以我不需要去设置cmd，cmd和我有什么关系？设置cmd或者全部使用utf-8也可能会导致其他的问题 ①网上建议的,CodeRunner使用终端确实可以解决,但是我不喜欢终端的字体,我就喜欢输出窗口的风格,和设置的字体统一example:&quot;csharp&quot;:&quot;clear &amp;&amp; cd $dir &amp;&amp; csc /nologo $fileName &amp;&amp; ./$fileNameWithoutExt&quot;,&quot;code-runner.runInTerminal&quot;: true ②如果是Windows平台：SettingJson中code-runner.executorMap里Csharp相关的前面加上chcp 65001，不需要修改cmd只需要修改vscode这里example：&quot;csharp&quot;: &quot;chcp 65001 &amp;&amp; cd $dir &amp;&amp; echo= &amp;&amp; csc /nologo /utf8output $fileName &amp;&amp; $fileNameWithoutExt&quot;, ③Linux下就不存在乱码,但是如果是RemoteSSH连接到服务器,怎么使用CodeRunner呢?还是刚才的设置,服务器提前安装monoexample:&quot;csharp&quot;: &quot;csc /nologo /utf8output $fileName &amp;&amp; mono $fileNameWithoutExt.exe&quot;, 一些问题经过上面的操作，C#的话，无论CodeRunner还是F5都没有乱码的问题但是C++的话，CodeRunner没有问题，但是调试会乱码 ①cpp代码中加入控制台代码12system(\"chcp 65001\"); system(\"cls\"); 虽然能解决，但是这么麻烦所以一般都不会这么做的，想一个办法把这两句代码自动先运行 ②使用attribute((constructor))使用attribute((constructor)),放在函数声明后，表示在main函数调用前，先调用此函数，同样的还有attribute((destructor))，表示在main函数调用exit（）之后调用此函数 在.vscode文件夹下创建一个head.h头文件 1234567#include &lt;stdlib.h&gt;static void before(void) __attribute__((constructor));static void before()&#123; system(\"chcp 65001\"); system(\"cls\");&#125; 然后把task.json中的参数修改一下&quot;args&quot;: [&quot;-g&quot;,&quot;${file}&quot;,&quot;-include&quot;,&quot;${workspaceRoot}\\\\.vscode\\\\head.h&quot;,&quot;-o&quot;,&quot;${fileBasenameNoExtension}.exe&quot;],其他不需要什么操作了，直接F5试一下","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"使用WPF制作打包、安装工具","slug":"WPF-Package&Install","date":"2021-01-28T16:00:00.000Z","updated":"2021-01-29T02:02:30.000Z","comments":true,"path":"2021/01/29/WPF-Package&Install/","link":"","permalink":"https://www.lubaobao.xyz/2021/01/29/WPF-Package&Install/","excerpt":"在安装软件时，发现人家的安装界面跟msi和一些打包工具做出来的不太一样，主要是人家的有自己定制的界面，就感觉很棒很酷炫，加上最近刚好需要一个打包的功能，我就做了一个类似的，美观程度还没有优化，只是验证了方案的可行性","text":"在安装软件时，发现人家的安装界面跟msi和一些打包工具做出来的不太一样，主要是人家的有自己定制的界面，就感觉很棒很酷炫，加上最近刚好需要一个打包的功能，我就做了一个类似的，美观程度还没有优化，只是验证了方案的可行性 打包核心功能目前有两个，第一个是把本地运行的软件压缩成资源，第二个是把本地的参数压缩成资源，这个很容易实现，微软自己提供的zipfile类十分的不好用，主要是没办法一个文件一个文件添加到zip文件中，同样解压的时候也是，没办法一个一个解压出来，之后制作安装的进度条的时候就不太方便 所以使用Nutget包管理器安装DotNetZip库，这个提供的方法就比较完美，符合我的需求，同时对于同名的文件提供四种方式的处理，如抛出异常、询问覆盖、静默覆盖等，微软提供的只有抛出异常好像#doge 进度条的前半段是把程序和参数全部复制到一个临时目录，然后压缩，因为直接在本地文件夹下压缩会因为占用而抛出异常，后半段是动态编译，生成一个安装程序 编译嵌入资源与dll资源都准备好的情况下，需要生成一个exe，同时这个exe还需要携带我们的资源，不然这个exe放到其他的环境中岂不是没办法用了，也因为这个原因，这个生成的exe需要自己携带所需的dll，在加载dll失败时，会通过自身程序集来加载所需的dll 先解决软件无法单独启动的问题，将所需的dll的放到项目下的一个文件夹内，然后右键选择生成操作为嵌入的资源，同时在软件启动前加入处理dll的方法这个方法csdn上随处可见，我针对自己的需求没有像网上那样，TestInstall是程序默认的命名空间名 123456789101112131415161718//找不到dll时, 从自身嵌入的资源中加载public static Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)&#123; string name = \"TestInstall.Resources.\" + new AssemblyName(args.Name).Name + \".dll\"; name = name.Replace(\".resources\", \"\"); Assembly result = null; using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(name)) &#123; try &#123; byte[] array = new byte[manifestResourceStream.Length]; manifestResourceStream.Read(array, 0, array.Length); result = Assembly.Load(array); &#125; catch &#123; &#125; &#125; return result;&#125; 或者也可以不使用这个方法，根据Assembly自己提供的Load方法，从程序集自己获取dll资源的二进制数组（内嵌的dll会被保存成byte[]），然后直接加载 1Assembly.Load(TestInstall.Properties.Resources.DotNetZip); 动态编译C#提供CSharpCodeProvider这个类，可以使我们拿到代码生成器和代码编译器的访问权限，CompilerParameters可以设置编译参数，如程序名、程序类型、程序所需的dll指定等 CompilerOptions 生成的exe的类型，如控制台程序、win32程序等 GenerateExecutable 是否生成exe，true表示生成exe，false表示只生成到内存中 EmbeddedResources 是一个Collection类的东西，表示嵌入的资源的集合，通过Add方法添加 1234567891011121314151617// 设置编译参数CompilerParameters options = new CompilerParameters( new string[] &#123; \"Microsoft.CSharp.dll\", \"PresentationCore.dll\", \"PresentationFramework.dll\", \"System.dll\", \"System.Windows.Forms.dll\", \"System.Xaml.dll\", \"System.Xml.dll\", \"WindowsBase.dll\", \"InstallHelper.dll\" &#125;, \"InstallPack.exe\", false);options.CompilerOptions = \"/target:winexe\";options.GenerateExecutable = true; CompileAssemblyFromSource 通过源码编译，第一个参数是CompilerParameters的对象，第二个参数是源码的string1234567CompilerResults cr = provider.CompileAssemblyFromSource(options, strSource);if (cr.Errors.HasErrors)&#123; var msg = string.Join(Environment.NewLine, cr.Errors.Cast&lt;CompilerError&gt;().Select(err =&gt; err.ErrorText)); System.Windows.Forms.MessageBox.Show(msg);&#125; 编译通过后会生成一个exe，将其move到桌面 安装前面的操作都没问题后，安装的界面由exe中嵌入的dll提供，这个dll是一个WPF控件库，提供一个Window，在exe启动时只需要将其Show出来即可 遇到的问题 1.WPF组件遇到无法访问的uri 遇到这个问题的原因我认为是App.xaml中的StartUri被我删掉后，Window自己的InitializeComponent方法会找不到Uri，也就是说Window不知道它是哪个界面，解决方法是通过后台来指定,LoadViewFromUri的方法也是csdn上随处可见，嫖过来直接用,第一个参数网上的是UserControl，我根据自己的需求改为了Window，其实也只需要替换两个参数而已，没什么难度 1234567891011121314151617181920//动态加载uripublic static void LoadViewFromUri(this Window window, string baseUri)&#123; try &#123; var resourceLocater = new Uri(baseUri, UriKind.Relative); var exprCa = (PackagePart)typeof(System.Windows.Application).GetMethod(\"GetResourceOrContentPart\", BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, new object[] &#123; resourceLocater &#125;); var stream = exprCa.GetStream(); var uri = new Uri((Uri)typeof(BaseUriHelper).GetProperty(\"PackAppBaseUri\", BindingFlags.Static | BindingFlags.NonPublic).GetValue(null, null), resourceLocater); var parserContext = new ParserContext &#123; BaseUri = uri &#125;; typeof(XamlReader).GetMethod(\"LoadBaml\", BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, new object[] &#123; stream, parserContext, window, true &#125;); &#125; catch (Exception) &#123; //log &#125;&#125; 1ResourcesHelper.LoadViewFromUri(this, \"/InstallHelper;component/MainWindow.xaml\"); 2.图片等资源造成Window的ShowDialog()报错，导致窗体不显示 正常情况下，这样写没有问题，资源绝对找的到，但是如果生成为dll被其他程序调用，这样子的ImageSource是不可能被找到的，这种写法是从项目的目录结构中指定路径去寻找的，生成为exe也会有目录结构，但是生成为dll的目录结构与解决方案的目录不一致 12345&lt;Window.Resources&gt; &lt;!--资源--&gt; &lt;ImageBrush x:Key=\"BackGrundIMGBrush\" ImageSource=\"/InstallHelper;component/Resources/SplashScreen.png\" Stretch=\"Fill\"&gt;&lt;/ImageBrush&gt; &lt;ImageBrush x:Key=\"MoreBtnBrush\" ImageSource=\"/InstallHelper;component/Resources/More.png\" Stretch=\"Fill\"&gt;&lt;/ImageBrush&gt;&lt;/Window.Resources&gt; 解决方法和上面那个一样，xaml中解决不了的就通过后台代码实现，将图片资源嵌入后，会被直接保存成bitmap，所以只需要把bitmap转换为brush就可以后台直接使用了 转换的方法是System.Windows.Interop.Imaging直接提供的，使用的时候只需要引入命名空间 123456789var bitmap = BodorThinkerInstallHelper.Properties.Resources.SplashScreen;var bitmapSource = Imaging.CreateBitmapSourceFromHBitmap(bitmap.GetHbitmap(), IntPtr.Zero, Int32Rect.Empty, BitmapSizeOptions.FromEmptyOptions() );bitmap.Dispose();var brush = new ImageBrush(bitmapSource);BackGroundIMG.Fill = brush;","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"【CPP】C++的boost学习","slug":"C++Boost","date":"2020-10-29T16:00:00.000Z","updated":"2020-11-03T02:35:03.000Z","comments":true,"path":"2020/10/30/C++Boost/","link":"","permalink":"https://www.lubaobao.xyz/2020/10/30/C++Boost/","excerpt":"学习C++的boost库,了解其中的一些方法","text":"学习C++的boost库,了解其中的一些方法 boost库的学习学习字符串处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#define _CRT_SECURE_NO_WARNINGS#define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING//学习字符串处理#if 0 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;boost/algorithm/string.hpp&gt;int main()&#123; std::cout &lt;&lt; \"Hello World!\\n\"; std::string s = \"Hello World!\"; //使用boost库,将字符串转为大写 std::cout &lt;&lt; boost::algorithm::to_upper_copy(s) &lt;&lt; std::endl; //使用STL标准算法库,将字符串转为大写 transform(s.begin(), s.end(), s.begin(), towupper); std::cout &lt;&lt; s &lt;&lt; std::endl; //删除出现的第一个\"O\" //std::cout &lt;&lt; boost::algorithm::erase_first_copy(s, \"O\") &lt;&lt; std::endl; //删除第二个出现的\"O\",索引是1 //std::cout &lt;&lt; boost::algorithm::erase_nth_copy(s, \"O\", 1) &lt;&lt; std::endl; //删除所有的\"O\" //std::cout &lt;&lt; boost::algorithm::erase_all_copy(s, \"O\") &lt;&lt; std::endl; //auto r = boost::algorithm::find_first(s, \"WO\"); //std::cout &lt;&lt; r &lt;&lt; std::endl; //将第一个出现的\"O\"替换成\"o\" //std::cout &lt;&lt; boost::algorithm::replace_first_copy(s, \"O\", \"o\") &lt;&lt; std::endl; //boost库将vector中的字符串拼接 std::vector&lt;std::string&gt; v; v.push_back(\"He\"); v.push_back(\"LLO\"); std::cout &lt;&lt; boost::algorithm::join(v, \" \") &lt;&lt; std::endl; //拼接char* char S[50] = \"lubaobao\"; char aa[8] = \" xihuan\"; char bb[10] = \" fujunjun\"; //sprintf(S, \"%s%s%s\", S, aa, bb); //std::cout &lt;&lt; S &lt;&lt; std::endl; strcat(S, aa); strcat(S, bb); std::cout &lt;&lt; S &lt;&lt; std::endl; //string的拼接 std::string aaa = \"lubaobao\"; std::string bbb = \" xihuan\"; std::string ccc = \" fujunjun\"; aaa.append(bbb); aaa.append(ccc); std::cout &lt;&lt; aaa &lt;&lt; std::endl; //判断字符串中是否含有子串 bool res = boost::algorithm::contains(s, \"HE\");&#125;#endif 学习文件系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//学习文件系统#if 0#include &lt;boost/filesystem.hpp&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;double TransToG(double kb)&#123; return kb / 1024 / 1024 / 1024;&#125;int main()&#123; boost::filesystem::path path1(\"C:\\\\Windows\"); //boost::filesystem::path* path1 = new boost::filesystem::path(\"C:\\\\\"); //判断path是不是目录 std::cout &lt;&lt; boost::filesystem::is_directory(path1) &lt;&lt; std::endl; boost::filesystem::file_status filestatus = boost::filesystem::status(path1); std::cout &lt;&lt; boost::filesystem::is_directory(filestatus) &lt;&lt; std::endl; try &#123; //获得文件的最后修改时间 boost::filesystem::path path2(\"C:\\\\Users\\\\29572\\\\Desktop\\\\vsbg.jpg\"); std::time_t time = boost::filesystem::last_write_time(path2); std::cout &lt;&lt; ctime(&amp;time) &lt;&lt; std::endl; //获取磁盘空间信息 boost::filesystem::path path3(\"C:\\\\\"); boost::filesystem::space_info pathinfo = boost::filesystem::space(path3); //设置小数精度 std::cout &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(1); std::cout &lt;&lt; TransToG(pathinfo.capacity) &lt;&lt; std::endl; std::cout &lt;&lt; TransToG(pathinfo.free) &lt;&lt; std::endl; std::cout &lt;&lt; TransToG(pathinfo.available) &lt;&lt; std::endl; //获取程序当前目录 std::cout &lt;&lt; boost::filesystem::current_path() &lt;&lt; std::endl; &#125; catch (boost::filesystem::filesystem_error e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125;#endif 学习智能指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//学习智能指针#if 0#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;class Window_Handle&#123;public: Window_Handle(HANDLE h) :_handle(h) &#123; &#125; ~Window_Handle() &#123; CloseHandle(_handle); &#125; Window_Handle(const Window_Handle* data) &#123; _handle = data-&gt;_handle; &#125; //通过成员函数访问到private的成员变量 HANDLE handle() const &#123; return _handle; &#125;private: HANDLE _handle;&#125;;int main()&#123; //通过 OpenProcess() 打开的资源不需要显示的调用 CloseHandle() 来关闭。 //当然，应用程序终止时资源也会随之关闭。 //然而，在更加复杂的应用程序里， windows_handle 类确保当一个资源不再使用时就能正确的关闭。 //某个资源一旦离开了它的作用域——上例中 h 的作用域在 main() 函数的末尾——它的析构函数会被自动的调用， //相应的资源也就释放掉了 Window_Handle h(OpenProcess(PROCESS_SET_INFORMATION, false, GetCurrentProcessId())); //_handle不可访问,需要通过成员函数访问 SetPriorityClass(h.handle(), HIGH_PRIORITY_CLASS); auto_ptr&lt;string&gt; p1(new string(\"lubaobao love fujunjun\")); auto_ptr&lt;string&gt; p2; p2 = p1; //此时,p1的所有权已被剥夺,p1变为empty,访问p1会报错 //p1-&gt;append(\" heihei\"); unique_ptr&lt;string&gt; p3(new string(\"lubaobao\")); unique_ptr&lt;string&gt; p4; //此时编译器会报错(尝试引用已删除的函数),因为p3、p4是单独占用模式 //p3 = p4; //但如果是临时右值,编译器允许 p3 = unique_ptr&lt;string&gt;(new string(\"fujunjun\")); string tmp = \"luzihan is lubaobao\"; shared_ptr&lt;string&gt; p5(&amp;tmp); shared_ptr&lt;string&gt; p6; p6 = p5; cout &lt;&lt; p5.use_count() &lt;&lt; endl; cout &lt;&lt; p6.use_count() &lt;&lt; endl; cout &lt;&lt; p5.unique() &lt;&lt; endl; shared_ptr&lt;string&gt; p7(new string(\"yanyunhao is funjunjun\")); cout &lt;&lt; p5.get() &lt;&lt; endl; cout &lt;&lt; p7.get() &lt;&lt; endl; swap(p5, p7); cout &lt;&lt; p5.get() &lt;&lt; endl; cout &lt;&lt; p7.get() &lt;&lt; endl; cout &lt;&lt; p5.use_count() &lt;&lt; endl; cout &lt;&lt; p6.use_count() &lt;&lt; endl; p6 = p5; cout &lt;&lt; p5.use_count() &lt;&lt; endl; cout &lt;&lt; p6.use_count() &lt;&lt; endl; //在VS 2017以上版本,将引用计数置为0 p5.reset(); cout &lt;&lt; p5.use_count() &lt;&lt; endl; cout &lt;&lt; p6.use_count() &lt;&lt; endl; return 0;&#125;#endif 一个简单理解多态的Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//一个简单理解多态的Demo#if 0#include &lt;iostream&gt;using namespace std;class softbanker&#123;public: softbanker() &#123; &#125;; virtual void DoSomething() &#123; cout &lt;&lt; \"save money\" &lt;&lt; endl; &#125;&#125;;class softbanker1 :public softbanker&#123;public: virtual void DoSomething() &#123; cout &lt;&lt; \"take money\" &lt;&lt; endl; &#125;&#125;;class softbanker2 :public softbanker&#123;public: virtual void DoSomething() &#123; cout &lt;&lt; \"change money\" &lt;&lt; endl; &#125;&#125;;int main()&#123; softbanker* sbanker = new softbanker(); sbanker-&gt;DoSomething(); sbanker = new softbanker1(); sbanker-&gt;DoSomething(); sbanker = new softbanker2(); sbanker-&gt;DoSomething(); delete sbanker; return 0;&#125;#endif 学习函数对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//学习函数对象#if 0 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;boost/bind.hpp&gt;using namespace std;void Print(int i)&#123; cout &lt;&lt; i &lt;&lt; endl;&#125;//for_each中要求的函数仅能接受一个参数void Add(int i, int j)&#123; cout &lt;&lt; i + j &lt;&lt; endl;&#125;bool Compare(int i, int j)&#123; return i &lt; j;&#125;class add :public binary_function&lt;int, int, void&gt;&#123;public: void operator()(int i, int j)const &#123; cout &lt;&lt; i + j &lt;&lt; endl; &#125;&#125;;int main()&#123; vector&lt;int&gt; v&#123; 1,2,3 &#125;; //for_each(v.begin(), v.end(), Print); //遍历打印v中的每个数+10 for_each(v.begin(), v.end(), bind1st(add(), 10)); //使用boost库中的bind方法 //_1,_2,_3这些都是占位符,Add是二元函数,传入参数10 ,_1将v数组中的元素传入 for_each(v.begin(), v.end(), boost::bind(Add, 10, _1)); swap(v[0], v[1]); for_each(v.begin(), v.end(), Print); //Compare是一个二元函数,_1,_2一次传入v数组中两个数 sort(v.begin(), v.end(), boost::bind(Compare, _1, _2)); for_each(v.begin(), v.end(), Print); //不像for_each只能使用一元函数作为参数 //sort中的比较方法可以是多元,上面的bind方法其实不需要 sort(v.begin(), v.end(), Compare); //不需要改变Compare的定义,就可以改变是升序还是降序 sort(v.begin(), v.end(), boost::bind(Compare, _2, _1)); for_each(v.begin(), v.end(), Print); return 0;&#125;#endif 学习事件处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//学习事件处理#if 0#include &lt;boost/signals2.hpp&gt;#include &lt;iostream&gt;//为了将信号槽函数的返回值写出至标准输出流#include &lt;boost/optional/optional_io.hpp&gt;using namespace std;void Func()&#123; cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;&#125;void Func1()&#123; cout &lt;&lt; \"Func1 Called\" &lt;&lt; endl;&#125;int Func2()&#123; return 2;&#125;int Func3()&#123; return 3;&#125;namespace my_max_element&#123; template&lt;typename T&gt; struct max_element &#123; typedef T result_type; template&lt;typename InputIterator&gt; //max_element的返回值为_Fwdlt#if 0 T operator()(InputIterator first, InputIterator last)const &#123; return *std::max_element(first, last); &#125;#endif T operator()(InputIterator first, InputIterator last)const &#123; return T(first, last); &#125; &#125;;&#125;int main()&#123; boost::signals2::signal&lt;void()&gt; sig; //sig.connect(Func); //sig.connect(Func1); //重载方式指定执行顺序 sig.connect(1, Func); sig.connect(0, Func1); sig(); //释放与绑定信号的关联 sig.disconnect(Func1); sig(); //清除所有关联的信号 sig.disconnect_all_slots(); //函数被关联至信号执行后的返回值会被覆盖,只保留最后一个 //注意signal&lt;&gt;函数的返回值类型 boost::signals2::signal&lt;int()&gt; new_sig; new_sig.connect(Func3); new_sig.connect(Func2); cout &lt;&lt; new_sig() &lt;&lt; endl; //保留每个返回值,重载()操作符,返回最大的其中一个返回值 //boost::signals2::signal&lt;int(), my_max_element::max_element&lt;int&gt;&gt; max_sig; boost::signals2::signal&lt;int(), my_max_element::max_element&lt;vector&lt;int&gt;&gt;&gt; max_sig; max_sig.connect(Func3); max_sig.connect(Func2); //cout &lt;&lt; max_sig() &lt;&lt; endl; vector&lt;int&gt; sig_return_value; sig_return_value = max_sig(); for (auto e : sig_return_value) cout &lt;&lt; e &lt;&lt; endl; return 0;&#125;#endif 学习多线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241//学习多线程#if 0#include &lt;boost/thread.hpp&gt;#include &lt;iostream&gt;void Wait(int seconds)&#123; //sleep函数区别于Sleep,位于this_thread命名空间 //seconds函数用于获得一个精确的时间,位于boost库的DateTime boost::this_thread::sleep(boost::posix_time::seconds(seconds));&#125;#if 0boost::mutex mutex;void Thread_thread()&#123; try &#123; for (int i = 1; i &lt;= 5; ++i) &#123; Wait(1); //mutex.lock(); //lock_guard类的构造函数中自动调用lock() //lock_guard类的析构函数中自动调用unlock() boost::lock_guard&lt;boost::mutex&gt; lock(mutex); std::cout &lt;&lt; i &lt;&lt; std::endl; //mutex.unlock(); //lock_guard的生命周期为for循环进入到结束 &#125; std::cout &lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl; &#125; //中断后会抛出一个thread_interrupted异常 catch (boost::thread_interrupted&amp;) &#123; &#125;&#125;#endifboost::timed_mutex mutex;void Thread_thread()&#123; for (int i = 1; i &lt;= 5; ++i) &#123; Wait(1); boost::unique_lock&lt;boost::timed_mutex&gt; lock(mutex, boost::try_to_lock); if (!lock.owns_lock()) lock.timed_lock(boost::get_system_time() + boost::posix_time::seconds(1)); std::cout &lt;&lt; boost::this_thread::get_id() &lt;&lt; \": \" &lt;&lt; i &lt;&lt; std::endl; boost::timed_mutex* m = lock.release(); m-&gt;unlock(); &#125;&#125;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;std::vector&lt;int&gt; random_numbers;boost::shared_mutex shared_mutex;#if 0void Fill()&#123; std::srand(static_cast&lt;unsigned int&gt;(std::time(0))); for (int i = 0; i &lt; 3; ++i) &#123; //这里改变了random_numers的内容,需要独占资源,使用独占锁 boost::unique_lock&lt;boost::shared_mutex&gt; lock(shared_mutex); random_numbers.push_back(std::rand()); //独占锁需要显式调用unlock lock.unlock(); //等待时间放在最后为了确保random_numbers里至少有一个数据 Wait(1); &#125;&#125;void Print()&#123; for (int i = 0; i &lt; 3; ++i) &#123; Wait(1); //虽然写到了标准输出,但是不操作random_numbers,所以可以共享互斥体 boost::shared_lock&lt;boost::shared_mutex&gt; lock(shared_mutex); std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl; &#125;&#125;#endifboost::mutex r_mutex;boost::condition_variable_any condition;#if 0void Fill()&#123; std::srand(static_cast&lt;unsigned int&gt; (std::time(0))); for (int i = 0; i &lt; 3; ++i) &#123; boost::unique_lock&lt;boost::mutex&gt; lock(r_mutex); random_numbers.push_back(std::rand()); //数据放完后,size相等,跳出循环,唤醒wait线程 condition.notify_all(); //这边进入等待,直到print出数据,size增加,唤醒这边的wait condition.wait(r_mutex); &#125;&#125;void Print()&#123; std::size_t next_size = 1; for (int i = 0; i &lt; 3; ++i) &#123; boost::unique_lock&lt;boost::mutex&gt; lock(r_mutex); //数据没拿到一直wait while (random_numbers.size() != next_size) condition.wait(r_mutex); //size相等,被唤醒 std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl; ++next_size; //唤醒插入数据的线程的wait condition.notify_all(); &#125;&#125;int sum = 0;void Sum()&#123; for (int i = 0; i &lt; 3; ++i) &#123; Wait(1); //只有读操作, boost::shared_lock&lt;boost::shared_mutex&gt; lock(shared_mutex); sum += random_numbers.back(); &#125;&#125;#endif#if 0//静态变量done,srand执行了只一次,生成的随机数2/3是同一个void InitNumber()&#123; //第二次进来done已经变成true了 static bool done = false; if (!done) &#123; done = true; std::srand(static_cast&lt;unsigned int&gt;(std::time(0))); &#125;&#125;#endif//同一时间完成初始化的话,随机数还是有可能一样void InitNumber()&#123; boost::thread_specific_ptr&lt;bool&gt; tls; if (!tls.get()) //reset参数是指针,C++ 的new出来的是指针,C# 的new出来的是对象 tls.reset(new bool(false)); if (!*tls) &#123; *tls = true; std::srand(static_cast&lt;unsigned int&gt;(std::time(0))); &#125;&#125;void GenerateNumber()&#123; InitNumber(); int i = std::rand(); boost::unique_lock&lt;boost::mutex&gt; lock(r_mutex); std::cout &lt;&lt; i &lt;&lt; std::endl;&#125;int main()&#123;#if 0 boost::thread t(Thread_thread); Wait(3); //获得当前线程的线程ID std::cout &lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl; //3秒后t线程被终止,打印结果为1,2,3 t.interrupt(); //join的作用是阻塞调用,直到调用join的线程运行结束 t.join();#endif#if 0 //如果函数内不加mutex,可能输出如下: //11 //2 //2 //... //如果函数内加mutex,输出如下: //1 //1 //2 //2 //... boost::thread t1(Thread_thread); boost::thread t2(Thread_thread); t1.join(); t2.join();#endif#if 0 boost::thread thread1(Fill); boost::thread thread2(Print); //boost::thread thread3(Sum); thread1.join(); thread2.join(); //thread3.join();#endif boost::thread thread[3]; for (int i = 0; i &lt; 3; ++i) thread[i] = boost::thread(GenerateNumber); for (int i = 0; i &lt; 3; ++i) thread[i].join(); return 0;&#125;#endif 学习异步输入输出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//学习异步输入输出#if 0#include &lt;boost/asio.hpp&gt;#include &lt;boost/thread.hpp&gt;#include &lt;iostream&gt;using namespace std;boost::asio::io_service service;//参数好像必须要传一个boost库提供的错误码(引用类型)void Async_Cout(const boost::system::error_code&amp; ec)&#123; cout &lt;&lt; \"lubaobao shigezhu\" &lt;&lt; endl;&#125;void Async_Cout1(const boost::system::error_code&amp; ec)&#123; cout &lt;&lt; \"lubaobao nengchi nengshui\" &lt;&lt; endl;&#125;void Myrun()&#123; service.run();&#125;int main()&#123; boost::asio::deadline_timer timer(service, boost::posix_time::seconds(5));#if 0 timer.async_wait(Async_Cout); cout &lt;&lt; \"async is right\" &lt;&lt; endl; //这里调用的run是阻塞式的,如果不是阻塞的,main函数结束调用后程序退出会把异步的方法中断掉 service.run();#endif boost::asio::deadline_timer timer1(service, boost::posix_time::seconds(5)); timer.async_wait(Async_Cout); timer1.async_wait(Async_Cout1); boost::thread thread1(Myrun); boost::thread thread2(Myrun); thread1.join(); thread2.join(); return 0;&#125;#endif 学习boost的网络编程(未完)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//学习boost的网络编程(未完)#if 0#include &lt;boost/asio.hpp&gt;#include &lt;boost/array.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;boost::asio::io_service io_service; //io对象boost::asio::ip::tcp::resolver resolver(io_service); //解析器boost::asio::ip::tcp::socket sock(io_service); //socket对象boost::array&lt;char, 4096&gt; buffer; //缓冲区void Read_Handler(const boost::system::error_code&amp; ec, std::size_t bytes_transferred)&#123; if (!ec) &#123; std::cout &lt;&lt; std::string(buffer.data(), bytes_transferred) &lt;&lt; std::endl; sock.async_read_some(boost::asio::buffer(buffer), Read_Handler); &#125;&#125;void Connect_Handler(const boost::system::error_code&amp; ec)&#123; if (!ec) &#123; boost::asio::write(sock, boost::asio::buffer(\"GET / HTTP 1.1\\r\\nHost: baidu.com\\r\\n\\r\\n\")); sock.async_read_some(boost::asio::buffer(buffer), Read_Handler); &#125;&#125;void Resolve_Handler(const boost::system::error_code&amp; ec, boost::asio::ip::tcp::resolver::iterator it)&#123; if (!ec) &#123; sock.async_connect(*it, Connect_Handler); &#125;&#125;int main()&#123; boost::asio::ip::tcp::resolver::query query(\"www.baidu.com\", \"8080\"); resolver.async_resolve(query, Resolve_Handler); io_service.run(); return 0;&#125;#endif 学习进程间通讯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192//学习进程间通讯#if 0#include &lt;boost/interprocess/shared_memory_object.hpp&gt;#include &lt;boost/interprocess/mapped_region.hpp&gt;#include &lt;iostream&gt;#include &lt;boost/bind.hpp&gt;#include &lt;boost/interprocess/windows_shared_memory.hpp&gt;#include &lt;boost/interprocess/managed_shared_memory.hpp&gt;#include &lt;boost/interprocess/containers/string.hpp&gt;#include &lt;boost/interprocess/allocators/allocator.hpp&gt;#include &lt;boost/interprocess/sync/named_mutex.hpp&gt;boost::interprocess::managed_shared_memory* atomic_sharedmemory;void Construct_func()&#123; atomic_sharedmemory-&gt;construct&lt;int&gt;(\"Integer_1\")(37); atomic_sharedmemory-&gt;construct&lt;float&gt;(\"Float_1\")(37.13);&#125;void (*pf)();#if 1int main()&#123; //boost提供的共享内存类，第一个参数指定存在时打开，不存在就创建，第二个参数是共享内存的名字，第三个参数指定共享内存是否可读可写 boost::interprocess::shared_memory_object shared_memeroy(boost::interprocess::open_or_create, \"lubaobao\", boost::interprocess::read_write); //申请共享内存的大小,如果共享内存不是可读可写状态下使用会抛出异常 shared_memeroy.truncate(1024); //获取共享内存的名字 std::cout &lt;&lt; shared_memeroy.get_name() &lt;&lt; std::endl; boost::interprocess::offset_t size; if (shared_memeroy.get_size(size)) &#123; std::cout &lt;&lt; size &lt;&lt; std::endl; &#125; //同一个共享内存,映射两个map,地址不同,大小一样#if 0 boost::interprocess::mapped_region region1(shared_memeroy, boost::interprocess::read_write); //hex用来进行十六进制表示,十进制输出 std::cout &lt;&lt; std::hex &lt;&lt; \"0x\" &lt;&lt; region1.get_address() &lt;&lt; std::endl; std::cout &lt;&lt; std::dec &lt;&lt; region1.get_size() &lt;&lt; std::endl; //dec用来进行八进制表示,十进制输出 boost::interprocess::mapped_region region2(shared_memeroy, boost::interprocess::read_write); std::cout &lt;&lt; std::hex &lt;&lt; \"0x\" &lt;&lt; region2.get_address() &lt;&lt; std::endl; std::cout &lt;&lt; std::dec &lt;&lt; region2.get_size() &lt;&lt; std::endl;#endif boost::interprocess::mapped_region region1(shared_memeroy, boost::interprocess::read_write); boost::interprocess::mapped_region region2(shared_memeroy, boost::interprocess::read_only); //区域1的开头被写入数字37 int* it1 = static_cast&lt;int*&gt;(region1.get_address()); *it1 = 37; //读取区域2开头位置,内容也是37 //两个区域其实访问的是同一块共享内存 int* it2 = static_cast&lt;int*&gt;(region2.get_address()); std::cout &lt;&lt; *it2 &lt;&lt; std::endl; //remove函数用来删除开辟出的共享内存,位于shared_memory_object命名空间内,重新启动后会自动删除,windows情况下不会删除,所以windows下必须remove bool remove = boost::interprocess::shared_memory_object::remove(\"lubaobao\"); std::cout &lt;&lt; remove &lt;&lt; std::endl; //windows专用的共享内存类,第四个参数为共享内存的大小,最后一个程序终止后会自动删除 boost::interprocess::windows_shared_memory windows_sharedmemory(boost::interprocess::open_or_create, \"fujunjun\", boost::interprocess::read_write, 1024); boost::interprocess::shared_memory_object::remove(\"fujunjun\"); boost::interprocess::shared_memory_object::remove(\"lubaobao\"); //不需要指定是否可读可写 boost::interprocess::managed_shared_memory managed_sharedmemory(boost::interprocess::open_or_create, \"lubaobao\", 1024); //construct后必须指定类型 int* i = managed_sharedmemory.construct&lt;int&gt;(\"Integer\")(80); std::cout &lt;&lt; *i &lt;&lt; std::endl; //find方法作用是在共享内存中找到名为Integer的变量,返回类型是pair //pair是将两个(不同类型)数据组合成一个数据,通常在函数需要返回两个数据时使用,数组也可以返回多个数据但是类型必须一致 std::pair&lt;int*, std::size_t&gt; pair = managed_sharedmemory.find&lt;int&gt;(\"Integer\"); if (pair.first) &#123; std::cout &lt;&lt; pair.first &lt;&lt; std::endl; std::cout &lt;&lt; *pair.first &lt;&lt; std::endl; &#125; //second用于判断申请出的是变量还是数组,如果是变量second为1,如果是数组,second是数组元素的个数,所有元素都被初始化为99 int* ii = managed_sharedmemory.construct&lt;int&gt;(\"Integer_array\")[10](99); pair = managed_sharedmemory.find&lt;int&gt;(\"Integer_array\"); if (pair.first) &#123; std::cout &lt;&lt; *pair.first &lt;&lt; std::endl; std::cout &lt;&lt; pair.second &lt;&lt; std::endl; &#125; //如果对象已存在,construct会失败,或者申请的数组长度大于共享内存的大小,会抛出bad alloc异常 try &#123; int* iii = managed_sharedmemory.construct&lt;int&gt;(\"Integer_more\")[4096](99); &#125; catch (const boost::interprocess::bad_alloc&amp; ec) &#123; std::cout &lt;&lt; ec.what() &lt;&lt; std::endl; &#125; //destroy函数用于删除在共享内存中创建的对象,使用方法为 共享内存对象名+.访问 managed_sharedmemory.destroy&lt;int&gt;(\"Integer_array\"); //如果不重新find,pair不会更新 pair = managed_sharedmemory.find&lt;int&gt;(\"Integer_array\"); //对象已被删除,返回nullptr,不可以解引用 std::cout &lt;&lt; pair.first &lt;&lt; std::endl; //在共享内存上使用string boost::interprocess::shared_memory_object::remove(\"lubaobao\"); boost::interprocess::managed_shared_memory str_sharedmemory(boost::interprocess::open_or_create, \"luer\", 1024); //根据boost库的提示,传入对应的参数 typedef boost::interprocess::allocator&lt;char, boost::interprocess::managed_shared_memory::segment_manager&gt; CharAllocator; typedef boost::interprocess::basic_string&lt;char, std::char_traits&lt;char&gt;, CharAllocator&gt; string; //find_or_construct函数作用是存在对象就找,不存在就构建&lt;&gt;中传入类型,最后一个()中第一个参数是内容,第二个参数是共享内存的段管理器 string* s = str_sharedmemory.find_or_construct&lt;string&gt;(\"Str\")(\"lu baobao love\", str_sharedmemory.get_segment_manager()); s-&gt;insert(14, \" fu jun jun\"); std::cout &lt;&lt; *s &lt;&lt; std::endl; //使用完必须清掉,否则会持续写入 boost::interprocess::shared_memory_object::remove(\"luer\"); atomic_sharedmemory = new boost::interprocess::managed_shared_memory(boost::interprocess::open_or_create, \"luer\", 1024); pf = Construct_func; //atomic_func的要求是无参,无返回值,所以使用boost库的bind方法把参数传递 //但是,boost库提供的示例源码编译不过,尝试修改无果,将函数指针传入atomic_func,函数修改为无参,控制共享内存对象的指针操作 atomic_sharedmemory-&gt;atomic_func(pf); std::cout &lt;&lt; *atomic_sharedmemory-&gt;find&lt;int&gt;(\"Integer_1\").first &lt;&lt; std::endl; std::cout &lt;&lt; *atomic_sharedmemory-&gt;find&lt;float&gt;(\"Float_1\").first &lt;&lt; std::endl; boost::interprocess::shared_memory_object::remove(\"luer\"); return 0;&#125;#endif#if 0int main()&#123; //boost库中thread里的mutex同步方法,适用于同一进程,不同进程的数据同步需要使用nameed_mutex,此类位于interprocess/sync下 boost::interprocess::managed_shared_memory mutex_sharedmemory(boost::interprocess::open_or_create, \"luer\", 1024);#if 0 //第一个参数指定打开/创建,第二个参数是锁的名字,知道锁名称的应用程序都能访问到锁 boost::interprocess::named_mutex mutex(boost::interprocess::open_or_create, \"mtx\"); int* iiii = mutex_sharedmemory.find_or_construct&lt;int&gt;(\"Mutex_Integer\")(); mutex.lock(); ++(*iiii); std::cout &lt;&lt; *iiii &lt;&lt; std::endl; mutex.unlock();#endif //interprocess_mutex可以由共享内存对象构建出来,返回指针 boost::interprocess::interprocess_mutex* mutex = mutex_sharedmemory.find_or_construct&lt;boost::interprocess::interprocess_mutex&gt;(\"mtx\")(); int* iiii = mutex_sharedmemory.find_or_construct&lt;int&gt;(\"Mutex_Integer\")(); mutex-&gt;lock(); ++(*iiii); std::cout &lt;&lt; *iiii &lt;&lt; std::endl; mutex-&gt;unlock(); return 0;&#125;#endif#endif 学习boost的容器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//学习boost的容器#if 0 #include &lt;iostream&gt;#include &lt;string&gt;//#include &lt;boost/array.hpp&gt;#include &lt;boost/unordered_set.hpp&gt;#include &lt;boost/unordered_map.hpp&gt;#include &lt;boost/bimap.hpp&gt;#include &lt;boost/bimap/multiset_of.hpp&gt;//如果是自定义的类型,boost不能识别,需要自己提供==运算符和hash_value函数计算哈希值class person&#123;public: person(std::string name, int age) :_name(name), _age(age) &#123; &#125; bool operator==(const person&amp; p)const &#123; return p._name == _name &amp;&amp; p._age == _age; &#125; //boost库示例代码为person const&amp; p,本质没有区别,个人习惯而已 //const放在指针左右才有区别,左值右向 size_t hash_value(const person&amp; p) &#123; size_t result = 0; boost::hash_combine(result, p._name); boost::hash_combine(result, p._age); return result; &#125;private: std::string _name; int _age;&#125;;int main()&#123;#if 0 typedef boost::array&lt;std::string, 3&gt; array; //C++初始化方式 array a&#123; \"lubaobao\",\"love\",\"lubaobao\" &#125;;#if 0 a[0] = \"lubaobao\"; a.at(1) = \"love\"; a[2] = \"lubaobao\";#endif //rend()不可以赋值,反向迭代器返回数组第一个元素前面的位置 //rbegin()指向数组最后一个元素的位置 //end()指向数组最后一个元素后面的位置 //begin()指向数组第一个元素的位置 * a.rbegin() = \"fujunjun\"; for (auto e : a) std::cout &lt;&lt; e &lt;&lt; std::endl;#endif#if 0 typedef boost::unordered_set&lt;std::string&gt; un_set; un_set* s = new un_set(); s-&gt;insert(\"lubaobao\"); s-&gt;insert(\"taixihuan\"); s-&gt;insert(\"fujunjun le\"); //此处的iterator是un_set下的,不是boost::unordered_set命名空间下的 //::作用域限定符,表示作用域和所属关系 for (un_set::iterator it = s-&gt;begin(); it != s-&gt;end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; std::endl; &#125;#if 0 for (auto e : *s) &#123; std::cout &lt;&lt; e &lt;&lt; std::endl; &#125;#endif#endif#if 0 typedef boost::unordered_map&lt;std::string, int&gt; un_map; un_map* um = new un_map(); //此处的value_type是un_map所属,不是命名空间所属 um-&gt;insert(un_map::value_type(\"lubaobao\", 0)); um-&gt;insert(un_map::value_type(\"fujunjun\", 1)); for (auto e : *um) &#123; std::cout &lt;&lt; e.first &lt;&lt; \",\" &lt;&lt; e.second &lt;&lt; std::endl; &#125; std::cout &lt;&lt; (um-&gt;find(\"lubaobao\") != um-&gt;end()) &lt;&lt; std::endl;#endif typedef boost::bimap&lt;std::string, int&gt; bi_map; bi_map* bm = new bi_map(); bm-&gt;insert(bi_map::value_type(\"lubaobao\", 18)); bm-&gt;insert(bi_map::value_type(\"fujunjun\", 24)); //auto for中使用:,C#中的auto使用in for (auto e : *bm) &#123; std::cout &lt;&lt; e.left &lt;&lt; \" is \" &lt;&lt; e.right &lt;&lt; \" years old\" &lt;&lt; std::endl; &#125; typedef boost::bimap&lt;boost::bimaps::set_of&lt;std::string&gt;, boost::bimaps::multiset_of&lt;int&gt;&gt; multi_bi_map; multi_bi_map* mbm = new multi_bi_map(); mbm-&gt;insert(multi_bi_map::value_type(\"lubaobao\", 18)); mbm-&gt;insert(multi_bi_map::value_type(\"fujunjun\", 18)); std::cout &lt;&lt; mbm-&gt;right.count(18) &lt;&lt; std::endl; return 0;&#125;#endif 学习boost的数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//学习boost的数据结构#if 1#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;boost/tuple/tuple.hpp&gt;//此头文件用于将tuple写入流中#include &lt;boost/tuple/tuple_io.hpp&gt;//类似于python的弱类型#include &lt;boost/any.hpp&gt;#include &lt;boost/variant.hpp&gt;boost::tuple&lt;std::string, int&gt; Func()&#123; //使用boost命名空间下的make_tuple也可以创建一个元组 return boost::make_tuple(\"Error_message\", 1024);&#125;#if 0int main()&#123;#if 0 //元组,与pair不同的是,pair只能存两个不同类型的变量,而tuple可以存无限个 boost::tuple &lt;std::string, std::string, int&gt; tp(\"lubaobao\", \"fujunjun\", 9999999); std::cout &lt;&lt; tp &lt;&lt; std::endl; //使用对象+.访问get函数,&lt;&gt;中为索引号 //使用boost命名空间下的get函数,&lt;&gt;中索引号,参数为元组对象 //索引值的合法性会在编译时检查 std::cout &lt;&lt; tp.get&lt;0&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; boost::get&lt;1&gt;(tp) &lt;&lt; std::endl;#endif#if 0 typedef boost::tuple &lt;std::string&amp;, std::string&amp;, int&amp;&gt; tp; string my_name = \"fujunjun\"; string my_wife_name = \"lubaobao\"; int we_together_time = 9999999; tp _tp = boost::tie(my_name, my_wife_name, we_together_time); we_together_time = 999999999; std::cout &lt;&lt; _tp &lt;&lt; std::endl;#endif //boost库的拆箱操作 std::string error_msg; int error_code; boost::tie(error_msg, error_code) = Func(); std::cout &lt;&lt; error_msg &lt;&lt; std::endl; std::cout &lt;&lt; error_code &lt;&lt; std::endl; return 0;&#125;#endifint main()&#123; boost::any any_type_a = 1; any_type_a = true; //any_type_a = \"lu he tu\"; //但是不能直接输出,还是需要类型转换 //类型转换错误的话,会抛出bad_any_cast的异常 try &#123; std::cout &lt;&lt; boost::any_cast&lt;int&gt;(any_type_a) &lt;&lt; std::endl; &#125; catch (const boost::bad_any_cast&amp; ec) &#123; std::cerr &lt;&lt; ec.what() &lt;&lt; std::endl; &#125; //用any_cast指向一个any类型 boost::any any_int = 1; //为了便于理解,此处写为 *i,事实上int* i和int *i是一样的,i是一个int型的指针,*i是一个int变量 //any_cast的&lt;&gt;中为要转换后的变量类型,此处为int,()中为参数,传入的是any类型变量的地址 int *i = boost::any_cast&lt;int&gt;(&amp;any_int); std::cout &lt;&lt; *i &lt;&lt; std::endl; boost::variant&lt;double, int, std::string&gt; v; v = 37.13; v = 37; v = \"lubaobao love fujunjun\"; std::cout &lt;&lt; boost::get&lt;std::string&gt;(v) &lt;&lt; std::endl; return 0;&#125;#endif 学习boost的序列化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;boost/archive/text_oarchive.hpp&gt;#include &lt;boost/archive/text_iarchive.hpp&gt;#include &lt;boost/archive/xml_oarchive.hpp&gt;#include &lt;boost/archive/xml_iarchive.hpp&gt;//ios::app： //以追加的方式打开文件 //ios::ate： //文件打开后定位到文件尾，ios:app就包含有此属性 //ios::binary： //以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文 //ios::in： //文件以输入方式打开（文件数据输入到内存） //ios::out： //文件以输出方式打开（内存数据输出到文件） //ios::nocreate： //不建立文件，所以文件不存在时打开失败 //ios::noreplace： //不覆盖文件，所以打开文件时如果文件存在失败 //ios::trunc： //如果文件存在，把文件长度设为0#if 0void Save()&#123; //std::ios::out 文件不存在则创建,存在则打开 std::fstream fs(\"text.txt\", std::ios::out); if (fs.is_open()) &#123; boost::archive::text_oarchive oa(fs); int i = 1; oa &lt;&lt; i; &#125;&#125;void Load()&#123; std::fstream fs(\"text.txt\", std::ios::in); if (fs.is_open()) &#123; boost::archive::text_iarchive ia(fs); int i = 0; ia &gt;&gt; i; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125;&#125;#endifstd::stringstream ss;class Person&#123;public: Person() &#123; &#125; Person(int age, std::string name) :_age(age), _name(name) &#123; &#125; //此处的const本质是给成员函数的this指针加const限定,不允许修改成员变量,除非成员变量使用mutable修饰 int age()const &#123; return _age; &#125; std::string name()const &#123; return _name; &#125;private: friend class boost::serialization::access; template&lt;typename Archive&gt; void serialize(Archive&amp; ar, const unsigned int version) &#123; //ar&amp; _age; ar&amp; BOOST_SERIALIZATION_NVP(_age); ar&amp; BOOST_SERIALIZATION_NVP(_name); &#125; std::string _name; int _age;&#125;;void Save()&#123;#if 0 boost::archive::text_oarchive oa(ss); Person p(18, \"lubaobao\"); oa &lt;&lt; p;#endif std::fstream fs(\"text.xml\", std::ios::out); boost::archive::xml_oarchive oa(fs); Person p(18, \"lubaobao\"); oa &lt;&lt; BOOST_SERIALIZATION_NVP(p);&#125;void Load()&#123;#if 0 boost::archive::text_iarchive ia(ss); Person p; ia &gt;&gt; p; std::cout &lt;&lt; p.age() &lt;&lt; std::endl;#endif std::fstream fs(\"text.xml\", std::ios::in); boost::archive::xml_iarchive ia(fs); Person p; ia &gt;&gt; BOOST_SERIALIZATION_NVP(p); std::cout &lt;&lt; p.age() &lt;&lt; std::endl; std::cout &lt;&lt; p.name() &lt;&lt; std::endl;&#125;int main()&#123;#if 0 boost::archive::text_oarchive oa(std::cout); int i = 1; oa &lt;&lt; 1;#endif Save(); Load(); return 0;&#125; Linux下的编译123456789101112131415161718192021all:string_boost filesystem_boost asio_boost socket_boost sharedmemory_boost container_boost datastructure_boost serialize_boostLIB=-I /home/luzihan/boost_1_74_0/include -L /home/luzihan/boost_1_74_0/lib string_boost:string_boost.cpp g++ -std=c++11 $^ -o $@filesystem_boost:filesystem_boost.cpp g++ -std=c++11 $^ -o $@ $(LIB) -lboost_system -lboost_filesystemasio_boost:asio_boost.cpp g++ -std=c++11 $^ -o $@ $(LIB) -lboost_system-mt -lboost_thread-mt -lpthreadsocket_boost:socket_boost.cpp g++ -std=c++11 $^ -o $@ $(LIB) -lpthreadsharedmemory_boost:sharedmemory_boost.cpp g++ $^ -o $@ $(LIB) -pthread -lrtcontainer_boost:container_boost.cpp g++ -std=c++11 $^ -o $@ $(LIB)datastructure_boost:datastructure_boost.cpp g++ -std=c++11 $^ -o $@ $(LIB)serialize_boost:serialize_boost.cpp g++ -std=c++11 $^ -o $@ $(LIB) -lboost_serializationclean: rm string_boost filesystem_boost asio_boost socket_boost sharedmemory_boost container_boost datastructure_boost serialize_boost","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]},{"title":"使用Blend For VS制作WPF动画","slug":"WPF-Blend&Animation","date":"2020-10-15T16:00:00.000Z","updated":"2020-10-21T05:12:23.000Z","comments":true,"path":"2020/10/16/WPF-Blend&Animation/","link":"","permalink":"https://www.lubaobao.xyz/2020/10/16/WPF-Blend&Animation/","excerpt":"WPF的强势之处在于不但可以很方便的画出漂亮的静态界面，也可以很方便的做出动画效果","text":"WPF的强势之处在于不但可以很方便的画出漂亮的静态界面，也可以很方便的做出动画效果 连续动画基础的Storyboard、时间线什么的概念就不在这里写了，因为这个博客也就是我自己记录自己学习的历程，我还没到可以教别人的程度用C#代码或者Xaml画一条线是很容易，但是要让线慢慢的一点点变长呢？用Timer计时器每隔一段时间修改line的宽度吗？不说Timer的时间精度问题，这样做出来想必也没有那么流畅的效果 目标效果 Blend实现先创建一个Line的对象，放入Canvas容器内 1&lt;Line x:Name=\"line\" X1=\"50\" Y1=\"150\" X2=\"500\" Y2=\"150\" Stroke=\"Green\" StrokeThickness=\"1\" Width=\"500\"/&gt; 然后在对象和时间线窗口中，点击图中的按钮，创建一个新的Stroyboard 在时间点0秒处，创建关键帧，最右侧的line对象属性窗口中设置width属性为0 同理,时间点5秒处,创建关键帧,width属性设置为line的最终宽度,点播放按钮预览效果 动画的调用两种方法调用动画,一种在后台找到对应的storyboard资源使用start方法调用,另一种使用Blend直接在xaml中调用触发器 后台代码 12var storyboard = (Storyboard)this.FindResources(\"Storyboard1\");storyboard.Start(); xaml触发器 如下代码是Blend帮忙生成的 1234567&lt;Window.Triggers&gt; &lt;EventTrigger RoutedEvent=\"FrameworkElement.Loaded\"&gt; &lt;BeginStoryboard Storyboard=\"&#123;StaticResource openStoryboard&#125;\"/&gt; &lt;BeginStoryboard Storyboard=\"&#123;StaticResource Storyboard1&#125;\"/&gt; &lt;BeginStoryboard Storyboard=\"&#123;StaticResource pathStoryboard&#125;\"/&gt; &lt;/EventTrigger&gt;&lt;/Window.Trigger&gt; 等待效果使用上次一模一样的操作,从阿里矢量图标库选取一个进度条的图片,然后时间点0设置角度为0,时间点3设置角度360,也可以设置相同的时间间隔转动不同的角度达到变速效果 123456789101112131415&lt;Storyboard x:Key=\"proStoryboard\" RepeatBehavior=\"Forever\" AutoReverse=\"False\"&gt; &lt;DoubleAnimationUsingKeyFrames Storyboard.TargetProperty=\"(UIElement.RenderTransform).(TransformGroup.Children)[2].(RotateTransform.Angle)\" Storyboard.TargetName=\"proimage\"&gt; &lt;EasingDoubleKeyFrame KeyTime=\"0\" Value=\"0\"/&gt; &lt;EasingDoubleKeyFrame KeyTime=\"0:0:0.2\" Value=\"60\"/&gt; &lt;EasingDoubleKeyFrame KeyTime=\"0:0:0.4\" Value=\"180\"/&gt; &lt;EasingDoubleKeyFrame KeyTime=\"0:0:0.6\" Value=\"240\"/&gt; &lt;EasingDoubleKeyFrame KeyTime=\"0:0:0.8\" Value=\"300\"/&gt; &lt;EasingDoubleKeyFrame KeyTime=\"0:0:1.0\" Value=\"360\"/&gt; &lt;!--&lt;EasingDoubleKeyFrame KeyTime=\"0:0:1.2\" Value=\"360\"/&gt;--&gt; &lt;/DoubleAnimationUsingKeyFrames&gt; &lt;ObjectAnimationUsingKeyFrames Storyboard.TargetProperty=\"(UIElement.Visibility)\" Storyboard.TargetName=\"proimage\"&gt; &lt;DiscreteObjectKeyFrame KeyTime=\"0\" Value=\"&#123;x:Static Visibility.Visible&#125;\"/&gt; &lt;DiscreteObjectKeyFrame KeyTime=\"0:0:1.0\" Value=\"&#123;x:Static Visibility.Hidden&#125;\"/&gt; &lt;/ObjectAnimationUsingKeyFrames&gt;&lt;/Storyboard&gt; 路径动画要想自己创建的对象按照某种路线移动，有两种方法，一种是上面提到的关键帧，某一时间点设置起始位置，然后设置不同的时间点拖动到不同的位置，造成可以移动的动画，但是这种方法弊端在于不能随心所欲的控制移动的位置，比如要想绕个圈那得设置多少个关键帧，而且弧度还不平滑，因为它只是针对TranslateTransform.X/Y属性，第二种方法就是使用路径动画，这种可以自己画好path，可以精确控制 Blend实现1&lt;PathGeometry x:Key=\"PathGeometry1\" Figures=\"M711.5,124 C711.5,124 628.5,257 766.5,221 904.5,185 1255.5025,96.499919 936.00088,146.00007 616.49922,195.50021 883.50077,102.49994 883.50077,102.49994 883.50077,102.49994 734.99988,-76.000585 771.00009,82.999882 807.00031,242.00035 942.00112,230.00031 942.00112,230.00031\"/&gt; 上面的代码是使用Blend的钢笔工具画出的一段路径,如下图 DoubleAnimationUsingPath 路径动画的标签 Duration 动画的时间间隔 TargetName 动画操作的对象名 TargetProperty 动画操作的属性,如放入Canvas容器内,可以为Canvs.Left/Top,不是的话属性设置为TranslateTransform.X/Y Source 绑定的Path的X或者Y PathGeometry 路径动画的路径 记不得标签的话,随便输入一个x或者y后Blend生成的代码中修改即可 12345678&lt;Storyboard x:Name=\"storyboard\" x:Key=\"pathStoryboard\" AutoReverse=\"True\" RepeatBehavior=\"Forever\"&gt; &lt;!--两种方法实现路径动画--&gt; &lt;!--&lt;DoubleAnimationUsingPath Storyboard.TargetProperty=\"(Canvas.Left)\" Duration=\"0:0:3\" PathGeometry=\"&#123;StaticResource PathGeometry1&#125;\" Storyboard.TargetName=\"movebtn\" Source=\"X\"/&gt;--&gt; &lt;!--&lt;DoubleAnimationUsingPath Storyboard.TargetProperty=\"(Canvas.Top)\" Duration=\"0:0:3\" PathGeometry=\"&#123;StaticResource PathGeometry1&#125;\" Storyboard.TargetName=\"movebtn\" Source=\"Y\"/&gt;--&gt; &lt;DoubleAnimationUsingPath Storyboard.TargetProperty=\"(UIElement.RenderTransform).(TransformGroup.Children)[3].(TranslateTransform.X)\" Duration=\"0:0:3\" PathGeometry=\"&#123;StaticResource PathGeometry1&#125;\" Storyboard.TargetName=\"movebtn\" Source=\"X\"/&gt; &lt;DoubleAnimationUsingPath Storyboard.TargetProperty=\"(UIElement.RenderTransform).(TransformGroup.Children)[3].(TranslateTransform.Y)\" Duration=\"0:0:3\" PathGeometry=\"&#123;StaticResource PathGeometry1&#125;\" Storyboard.TargetName=\"movebtn\" Source=\"Y\"/&gt;&lt;/Storyboard&gt; 效果演示大方块使用第一种方法,小方块使用第二种方法 启动、关闭动画Blend实现也是使用连续动画的方式,操作的对象变成了window,操作的属性是width,控制窗体达到一个慢慢向右铺开的效果,但是如果设置窗体居中,铺开后窗体不会再正中,这个暂时没有解决 1234567&lt;!--控制window的旋转和缩放--&gt;&lt;Window.RenderTransform&gt; &lt;TransformGroup&gt; &lt;ScaleTransform x:Name=\"scale\" ScaleX=\"1\" ScaleY=\"1\"&gt;&lt;/ScaleTransform&gt; &lt;RotateTransform x:Name=\"rotate\" Angle=\"0\"&gt;&lt;/RotateTransform&gt; &lt;/TransformGroup&gt;&lt;/Window.RenderTransform&gt; 对于Window来说,右侧的属性窗口没有转换选项,但其实可以转换操作,不过要用代码实现,操作属性width可以实现铺开效果,而且右侧属性窗口是有width属性的,控制ScaleX和Scale Y属性从0-1控制缩放 12345&lt;Storyboard x:Key=\"openStoryboard\"&gt; &lt;DoubleAnimation Storyboard.TargetProperty=\"(FrameworkElement.Width)\" From=\"0\" To=\"1200\" Duration=\"0:0:1\" Storyboard.TargetName=\"window\"/&gt; &lt;!--&lt;DoubleAnimation Storyboard.TargetProperty=\"ScaleX\" From=\"0.1\" To=\"1\" Duration=\"0:0:1\" Storyboard.TargetName=\"scale\"/&gt;--&gt; &lt;!--&lt;DoubleAnimation Storyboard.TargetProperty=\"ScaleY\" From=\"0.1\" To=\"1\" Duration=\"0:0:1\" Storyboard.TargetName=\"scale\"/&gt;--&gt;&lt;/Storyboard&gt; 关闭也是操作width,不过是从展开后的宽度变为0,然后加上旋转,1秒转动720度(2圈),操作Opacity属性控制渐隐渐显效果,从1-0为渐隐 12345&lt;Storyboard x:Key=\"closeStoryboard\"&gt; &lt;DoubleAnimation Storyboard.TargetProperty=\"(FrameworkElement.Width)\" From=\"1200\" To=\"0\" Duration=\"0:0:1\" Storyboard.TargetName=\"window\"/&gt; &lt;DoubleAnimation Storyboard.TargetProperty=\"Angle\" From=\"0\" To=\"720\" Duration=\"0:0:1\" Storyboard.TargetName=\"rotate\"/&gt; &lt;DoubleAnimation Storyboard.TargetProperty=\"Opacity\" From=\"1\" To=\"0\" Duration=\"0:0:1\" Storyboard.TargetName=\"grid\"/&gt;&lt;/Storyboard&gt; 启动动画Loaded事件加载,关闭动画需要在Closing事件中加载关闭动画然后阻止窗体关闭,在关闭动画执行结束后关闭窗体 123456789101112public MainWindow()&#123; InitializeComponent(); closeStoryboard = (Storyboard)this.FindResource(\"closeStoryboard\"); closeStoryboard.Completed += (c, d) =&gt; Application.Current.Shutdown(); ;&#125;private void window_Closing(object sender, System.ComponentModel.CancelEventArgs e)&#123; closeStoryboard.Begin(); e.Cancel = true;&#125; 如果启动动画、关闭动画出现黑色背景，多半是因为window的style没有设置为None，而且AllowsTransparency设置为true，标题栏需要自己画 效果演示","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"WPF中ListView加载大量数据","slug":"WPF-ListViewBigDataBinding","date":"2020-08-25T16:00:00.000Z","updated":"2020-08-26T05:53:04.000Z","comments":true,"path":"2020/08/26/WPF-ListViewBigDataBinding/","link":"","permalink":"https://www.lubaobao.xyz/2020/08/26/WPF-ListViewBigDataBinding/","excerpt":"使用情景 使用ListView加数据绑定 使用ListView的GridView作为View显示元素 效果演示","text":"使用情景 使用ListView加数据绑定 使用ListView的GridView作为View显示元素 效果演示 使用情景在此之前,做了一个显示日志信息的模块,当时使用的是RichTextBox,但是我不会绑定,因为它是FlowDocument,所以我是直接将数据转换为对应的Paragraph然后Add进去,这样很慢,大概2000条日志就会造成界面卡顿 后来改为异步加载,其他线程中操作控件需要使用Dispatcher.BeginInvoke,这种lamuda表达式中途不允许return,所以还是把所有的Paragraph完全加载到Documents.Blocks中才会刷新UI,解决的方法是创建一个线程先加载500条,然后完成后,在重新创建线程,继续500条,这种做法可以解决界面假死,但是滑动条的体验不太令人满意(未加载完时拖动,此时又添加了数据,滑动条的位置会变化) 12345678910111213141516171819task = new Task(() =&gt;&#123; while (true) &#123; lock (lockobj) &#123; if (paragraphs.Count == 0) break; if (completed) &#123; completed = false; thread = new Thread(new ThreadStart(UpdateTimeRangeLog)); thread.IsBackground = true; thread.Start(); &#125; &#125; &#125;&#125;);task.Start(); 如果在线程中加入System.Windows.Forms.Application.DoEvents(),可以丝滑流畅,但是这种做法会导致效率下降三倍左右,也就是说多线程异步加载需要5秒,使用这种方法需要15秒,数据才能完全加载完毕,不推荐使用,虽然很流畅,但是如果用户就是想看这个时间段末尾的日志,你加载这么慢肯定不行 1234567891011121314151617private void UpdateTimeRangeLog()&#123; int count = onetimecount &lt;= paragraphs.Count ? onetimecount : paragraphs.Count; lock (lockobj) &#123; LogInfo.Document.Dispatcher.BeginInvoke(new Action(() =&gt; &#123; for (int i = 0; i &lt; count; ++i) &#123; if (paragraphs.Count != 0) LogInfo.Document.Blocks.Add(paragraphs.Dequeue()); //System.Windows.Forms.Application.DoEvents() &#125; &#125;), System.Windows.Threading.DispatcherPriority.Background); completed = true; &#125;&#125; 使用ListView加数据绑定然后,我考虑换一种控件试试,看用数据绑定的方式能不能行,然而,我用下面的方式绑定上去,依旧很慢,这边怀疑Binding是同步的,使用异步Binding后结局依旧没有改变(数据量7000条,10s) 1234567&lt;ListView x:Name=\"_LogInfo\" ItemsSource=\"&#123;Binding LogList&#125;\" VirtualizingPanel.IsVirtualizing=\"True\" VirtualizingPanel.ScrollUnit=\"Pixel\" VirtualizingPanel.VirtualizationMode=\"Recycling\"&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=\"&#123;Binding LogMsg&#125;\"&gt;&lt;/TextBlock&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt;&lt;/ListView&gt; 使用ListView的GridView作为View显示元素后来从百度上搜索看到别人是这样加载大量数据的,据博主所说42000行520多列10秒,如果真的是那可太棒了 然后根据这篇文章,试了一下,可行,下面提供一个Demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;Window.Resources&gt; &lt;local:ColorConvert x:Key=\"ColorConvert\"/&gt; &lt;Style x:Key=\"myHeaderStyle\" TargetType=\"&#123;x:Type GridViewColumnHeader&#125;\"&gt; &lt;Setter Property=\"Visibility\" Value=\"Collapsed\" /&gt; &lt;/Style&gt; &lt;Style x:Key=\"myListitemStyle\" TargetType=\"&#123;x:Type ListViewItem&#125;\"&gt; &lt;Style.Setters&gt; &lt;Setter Property=\"SnapsToDevicePixels\" Value=\"True\" /&gt; &lt;Setter Property=\"Template\"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=\"&#123;x:Type ListViewItem&#125;\"&gt; &lt;Border x:Name=\"bd\" Padding=\"&#123;TemplateBinding Padding&#125;\" SnapsToDevicePixels=\"True\"&gt; &lt;GridViewRowPresenter Margin=\"3\" Columns=\"&#123;TemplateBinding GridView.ColumnCollection&#125;\" Content=\"&#123;TemplateBinding Content&#125;\" /&gt; &lt;/Border&gt; &lt;ControlTemplate.Triggers&gt; &lt;Trigger Property=\"IsSelected\" Value=\"True\"&gt; &lt;Trigger.Setters&gt; &lt;Setter TargetName=\"bd\" Property=\"Background\" Value=\"transparent\"/&gt; &lt;/Trigger.Setters&gt; &lt;/Trigger&gt; &lt;/ControlTemplate.Triggers&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style.Setters&gt; &lt;/Style&gt; &lt;DataTemplate x:Key=\"myTimeCellStyle\"&gt; &lt;TextBlock Text=\"&#123;Binding Time&#125;\" Foreground=\"Black\"&gt;&lt;/TextBlock&gt; &lt;/DataTemplate&gt; &lt;DataTemplate x:Key=\"myTypeCellStyle\"&gt; &lt;TextBlock Text=\"&#123;Binding Type&#125;\" Foreground=\"Black\" Visibility=\"Collapsed\"&gt;&lt;/TextBlock&gt; &lt;/DataTemplate&gt; &lt;DataTemplate x:Key=\"myMesgCellStyle\"&gt; &lt;TextBlock Text=\"&#123;Binding Mesg&#125;\" Foreground=\"&#123;Binding Type,Converter=&#123;StaticResource ColorConvert&#125;&#125;\"&gt;&lt;/TextBlock&gt; &lt;/DataTemplate&gt;&lt;/Window.Resources&gt;&lt;Grid&gt; &lt;ListView x:Name=\"Loginfo\" ItemContainerStyle=\"&#123;StaticResource myListitemStyle&#125;\" HorizontalAlignment=\"Stretch\" VerticalAlignment=\"Stretch\" ScrollViewer.VerticalScrollBarVisibility=\"Visible\" ScrollViewer.CanContentScroll=\"True\"/&gt;&lt;/Grid&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465string normalLogFileName = \"20200818.Normal.txt\";List&lt;string&gt; dataList = new List&lt;string&gt;();List&lt;Paragraph&gt; list = new List&lt;Paragraph&gt;();//插入数据DataTable table = new DataTable();//时间、种类、信息列DataColumn timeCol = new DataColumn(\"Time\", typeof(string));DataColumn typeCol = new DataColumn(\"Type\", typeof(string));DataColumn mesgCol = new DataColumn(\"Mesg\", typeof(string));table.Columns.Add(timeCol);table.Columns.Add(typeCol);table.Columns.Add(mesgCol);using (StreamReader sr = new StreamReader(System.IO.Path.Combine(LogFilePath, normalLogFileName), Encoding.UTF8))&#123; string time = string.Empty; string type = string.Empty; string mesg = string.Empty; while (!sr.EndOfStream) &#123; try &#123; string text = sr.ReadLine(); string[] str = text.Split(new string[] &#123; \" \" &#125;, StringSplitOptions.RemoveEmptyEntries); if (str.Count() &gt; 4) &#123; time = string.Format(\"&#123;0&#125; &#123;1&#125;\", str[0], str[1]); type = str[2]; mesg = string.Format(\"&#123;0&#125; &#123;1&#125;\", str[3], str[4]); &#125; else &#123; time = string.Format(\"&#123;0&#125; &#123;1&#125;\", str[0], str[1]); type = str[2]; mesg = str[3]; &#125; DataRow row = table.NewRow(); row[0] = time; row[1] = type; row[2] = mesg; table.Rows.Add(row); &#125; catch &#123; &#125; &#125; sr.Close();&#125;GridView gv = new GridView();gv.ColumnHeaderContainerStyle = (Style)this.FindResource(\"myHeaderStyle\");foreach (DataColumn dc in table.Columns)&#123; GridViewColumn columnRowNum = new GridViewColumn(); //columnRowNum.DisplayMemberBinding = new Binding(dc.ColumnName); columnRowNum.Header = dc.ColumnName; if (dc.ColumnName == \"Time\") columnRowNum.CellTemplate = (DataTemplate)this.FindResource(\"myTimeCellStyle\"); else if (dc.ColumnName == \"Type\") columnRowNum.CellTemplate = (DataTemplate)this.FindResource(\"myTypeCellStyle\"); else columnRowNum.CellTemplate = (DataTemplate)this.FindResource(\"myMesgCellStyle\"); gv.Columns.Add(columnRowNum);&#125;Loginfo.View = gv;Loginfo.DataContext = table;Loginfo.SetBinding(ListView.ItemsSourceProperty, new Binding()); 效果演示使用上面的方法,不使用异步操作的情况下,7200条日志秒加载,比之前已经好太多了,刚工作不久,代码风格和规范都不是太好,各位大佬见谅,会努力学习改正的","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"WPF的Treeview和Menuitem的层级数据绑定","slug":"WPF-TreeViewBinding","date":"2020-08-06T16:00:00.000Z","updated":"2020-08-26T05:53:18.000Z","comments":true,"path":"2020/08/07/WPF-TreeViewBinding/","link":"","permalink":"https://www.lubaobao.xyz/2020/08/07/WPF-TreeViewBinding/","excerpt":"使用情景 树形类 数据准备 数据绑定 效果演示 2020-08-08更新 xml效果演示 xml数据绑定 xml绑定效果演示","text":"使用情景 树形类 数据准备 数据绑定 效果演示 2020-08-08更新 xml效果演示 xml数据绑定 xml绑定效果演示 使用情景 如果我们需要这种多层级的控件，比如Menu或者TreeView，后台代码添加需要大量操作空间，且每次Loaded的时候都需要这样，重复大量效率很差的操作，数据量要是不小，就会造成界面明显的卡顿，同时也不符合MVVM的数据驱动程序的思想，换成数据就不一样了，界面启动时加载一次，以后再也不需要重复加载，控件初始化通过Binding生成，效率肯定比我们自己写好很多 树形类既然是多层级，那么单单使用List存放就不太现实，所以我们需要一种类似链表的结构，可以找到节点的双亲和孩子TreeView绑定时必须要有两个东西，NodeID和ParentID，名字和类型可以随便，但类似的东西要有，反正大家都是这么做的，我也不知道是不是微软的规定 12345678public class TreeNode&#123; public int NodeID &#123; get; set; &#125; public int ParentID &#123; get; set; &#125; public string NodeName &#123; get; set; &#125; public List&lt;TreeNode&gt; ChildNodes &#123; get; set; &#125; public TreeNode() =&gt; ChildNodes = new List&lt;TreeNode&gt;();&#125; 数据准备之前博客上写的是错的 先随便创建点数据，NodeID的计算需要知道第一级的总个数，第二级的起始NodeID是第一个总个数+1,然后自增,同理第三级起始NodeID是第一级个数+第二级个数+1,然后自增,第三级的ParentID是第二级的当前NodeID-1(因为add之后NodeID已经自增) 12345678910111213int seconditemID = date.Count + 1;int thirditemID = date.Count + logFileList.Count + 1;...node = new TreeNode() &#123; ParentID = i + 1, NodeID = seconditemID++, NodeName = stringBuilder.ToString() &#125;;nodes.Add(node);for (int l = 0; l &lt; lauchTimeList.Count; ++l)&#123; node = new TreeNode() &#123; ParentID = seconditemID - 1, NodeID = thirditemID++, NodeName = lauchTimeList[l].ToString() + \" Test.exe\" &#125;; nodes.Add(node);&#125; 将节点全部创建完之后存放在一个List中,插入完数据之后的nodes 此时,nodes还只是一个List,并不是层级结构,因为ChildNode还没有初始化,GetNodes递归查询子节点,当前节点的子节点的ParentID等于当前节点的NodeID 微软提供的where查询语句比for快,比foreach更快 以下代码来源于:https://www.cnblogs.com/larissa-0464/p/10227483.html 12345678public List&lt;TreeNode&gt; getNodes(int parentID, List&lt;TreeNode&gt; nodes)&#123; List&lt;TreeNode&gt; mainNodes = nodes.Where(x =&gt; x.ParentID == parentID).ToList(); List&lt;TreeNode&gt; otherNodes = nodes.Where(x =&gt; x.ParentID != parentID).ToList(); foreach (TreeNode node in mainNodes) node.ChildNodes = getNodes(node.NodeID, otherNodes); return mainNodes;&#125; GetNodes之后得到的层级结构,就是TreeView需要绑定的Itemsource 数据绑定Resources里放的Brush是为了改变Item丢失焦点后Backgroud变成白色,那样巨丑 12345678910111213141516171819&lt;TreeView x:Name=\"tree\" Background=\"&#123;StaticResource PageDeepBackground&#125;\" BorderThickness=\"0,0,1,0\" SelectedItemChanged=\"tree_SelectedItemChanged\"&gt; &lt;TreeView.ItemTemplate&gt; &lt;HierarchicalDataTemplate ItemsSource=\"&#123;Binding Path=ChildNodes&#125;\"&gt; &lt;StackPanel&gt; &lt;Label Content=\"&#123;Binding Path=NodeName&#125;\" Foreground=\"White\"/&gt; &lt;/StackPanel&gt; &lt;/HierarchicalDataTemplate&gt; &lt;/TreeView.ItemTemplate&gt; &lt;TreeView.ItemContainerStyle&gt; &lt;Style TargetType=\"&#123;x:Type TreeViewItem&#125;\"&gt; &lt;Style.Resources&gt; &lt;SolidColorBrush x:Key=\"&#123;x:Static SystemColors.HighlightBrushKey&#125;\" Color=\"DodgerBlue\"/&gt; &lt;SolidColorBrush x:Key=\"&#123;x:Static SystemColors.HighlightTextBrushKey&#125;\" Color=\"White\"/&gt; &lt;SolidColorBrush x:Key=\"&#123;x:Static SystemColors.InactiveSelectionHighlightBrushKey&#125;\" Color=\"DodgerBlue\"/&gt; &lt;SolidColorBrush x:Key=\"&#123;x:Static SystemColors.InactiveSelectionHighlightTextBrushKey&#125;\" Color=\"White\"/&gt; &lt;/Style.Resources&gt; &lt;/Style&gt; &lt;/TreeView.ItemContainerStyle&gt;&lt;/TreeView&gt; 效果演示 2020-08-08更新:Xml完成层级数据 2020-08-08更新上面的方法是我从百度上查到的,可以直接用,但是NodeID和ParentID很容易把人搞懵,然后我自己试着看能不能满足我自己的需求 采用xml的方式制定层级结构,加载时也只需要将xml反序列化就好 xml的内存结构(随手写的demo,绑定时不可以这样) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[XmlRoot(\"LogClass\")]public class LogClass&#123; [XmlElement(\"Year\")] public List&lt;Year&gt; Year &#123; get; set; &#125; public LogClass() &#123; Year = new List&lt;Year&gt;(); &#125;&#125;public class Year&#123; [XmlElement(\"Date\")] public List&lt;Date&gt; date &#123; get; set; &#125; [XmlAttribute(\"year\")] public string year &#123; get; set; &#125; public Year() &#123; date = new List&lt;Date&gt;(); year = string.Empty; &#125;&#125;public class Date&#123; [XmlElement(\"Time\")] public List&lt;Time&gt; time &#123; get; set; &#125; [XmlAttribute(\"date\")] public string data &#123; get; set; &#125; public Date() &#123; data = string.Empty; time = new List&lt;Time&gt;(); &#125;&#125;public class Time&#123; [XmlElement(\"LauchTime\")] public List&lt;string&gt; data &#123; get; set; &#125; public Time() &#123; data = new List&lt;string&gt;(); &#125;&#125; 使用时,完成初始化,就可以得到一个层级结构,初始化的操作就不多写了 12345678910111213static void Main(string[] args)&#123; LogClass lll = GetLogConfig(); string xml = XmlHelper.XMLHelper.WriteXml&lt;LogClass&gt;(lll, \"./lll.xml\"); Console.WriteLine(xml); using (StreamWriter sw = new StreamWriter(new FileStream(\"./Alll.xml\", FileMode.Create))) &#123; sw.Write(xml); sw.Close(); &#125;&#125; xml效果演示 xml数据绑定到上面为止,层级结构我们就很容易的有了,但是如果绑定的话,就不能像demo里那样随手一写,想要绑定到Menu上还是要规矩一点 需要把所有要显示的都使用属性(XmlAttribute)表示,属性也需要统一,剩下的事情交给分层模板处理 1234567891011&lt;Window.Resources&gt; &lt;XmlDataProvider x:Key=\"menudata\" Source=\"Resources/Alll.xml\" XPath=\"/Menu/MenuItem\"&gt;&lt;/XmlDataProvider&gt; &lt;HierarchicalDataTemplate DataType=\"MenuItem\" ItemsSource=\"&#123;Binding XPath=MenuItem&#125;\"&gt; &lt;StackPanel Orientation=\"Vertical\" &gt; &lt;TextBlock Width=\"150\" Height=\"35\" Foreground=\"Black\" Text=\"&#123;Binding XPath=@Data&#125;\" HorizontalAlignment=\"Left\"&gt;&lt;/TextBlock&gt; &lt;/StackPanel&gt; &lt;/HierarchicalDataTemplate&gt;&lt;/Window.Resources&gt;&lt;Grid&gt; &lt;Menu x:Name=\"item\" Width=\"150\" Height=\"35\" Background=\"White\" ItemsSource=\"&#123;Binding Source=&#123;StaticResource menudata&#125;&#125;\" HorizontalAlignment=\"Left\" VerticalAlignment=\"Top\"/&gt;&lt;/Grid&gt; 绑定的xml数据源示例(节点或属性名随意,只要统一就好),手动写好或者每次加载动态生成取决于自己的需求 encoding=”utf-16”问题是由于使用streamwriter完成序列化，所以encoding的设置不生效换成memorystream最后return Encoding.UTF8.GetString(memorystream.ToArray())即可 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-16\"?&gt;&lt;Menu&gt; &lt;MenuItem Data=\"2020-08\"&gt; &lt;MenuItem Data=\"2020-08-08\"&gt; &lt;MenuItem Data=\"08:59:37\" /&gt; &lt;/MenuItem&gt; &lt;MenuItem Data=\"2020-08-07\"&gt; &lt;MenuItem Data=\"09:22:14\" /&gt; &lt;MenuItem Data=\"09:24:23\" /&gt; &lt;MenuItem Data=\"09:47:44\" /&gt; &lt;MenuItem Data=\"09:49:23\" /&gt; &lt;MenuItem Data=\"09:54:09\" /&gt; &lt;MenuItem Data=\"10:00:53\" /&gt; &lt;MenuItem Data=\"10:23:38\" /&gt; &lt;MenuItem Data=\"10:43:55\" /&gt; &lt;MenuItem Data=\"10:50:06\" /&gt; &lt;MenuItem Data=\"11:25:52\" /&gt; &lt;MenuItem Data=\"11:28:18\" /&gt; &lt;MenuItem Data=\"13:10:11\" /&gt; &lt;MenuItem Data=\"13:28:06\" /&gt; &lt;MenuItem Data=\"13:46:26\" /&gt; &lt;MenuItem Data=\"13:52:14\" /&gt; &lt;MenuItem Data=\"13:54:22\" /&gt; &lt;MenuItem Data=\"14:43:07\" /&gt; &lt;MenuItem Data=\"14:44:06\" /&gt; &lt;/MenuItem&gt; &lt;/MenuItem&gt;&lt;/Menu&gt; 每次启动前生成最新的xml,动态加载 1234567private void Window_Loaded(object sender, RoutedEventArgs e)&#123; XmlDataProvider dd = this.FindResource(\"menudata\") as XmlDataProvider; dd.Source = new Uri(System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Alll.xml\")); this.item.DataContext = dd; this.item.SetBinding(ItemsControl.ItemsSourceProperty, new Binding() &#123; Source = dd &#125;);&#125; xml绑定效果演示","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"WPF一键更换单位","slug":"WPF-OneKeyToChangeUnit","date":"2020-07-29T16:00:00.000Z","updated":"2020-07-31T05:25:51.000Z","comments":true,"path":"2020/07/30/WPF-OneKeyToChangeUnit/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/30/WPF-OneKeyToChangeUnit/","excerpt":"页面布局 单位转换 数值转换 效果演示 [2020-7-31更新]","text":"页面布局 单位转换 数值转换 效果演示 [2020-7-31更新] 页面布局123456789101112131415161718192021222324252627&lt;Window x:Class=\"testUnit.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:local=\"clr-namespace:testUnit\" mc:Ignorable=\"d\" Loaded=\"Window_Loaded\" Unloaded=\"Window_Unloaded\" Title=\"MainWindow\" Height=\"450\" Width=\"800\"&gt; &lt;Grid&gt; &lt;ComboBox x:Name=\"UnitCombox\" Width=\"150\" Height=\"35\" Margin=\"0,-200,0,0\" SelectedIndex=\"0\" SelectionChanged=\"UnitCombox_SelectionChanged\"&gt; &lt;ComboBoxItem Content=\"mm/s\"/&gt; &lt;ComboBoxItem Content=\"mm/min\" /&gt; &lt;/ComboBox&gt; &lt;StackPanel Orientation=\"Horizontal\" HorizontalAlignment=\"Center\" Height=\"100\"&gt; &lt;TextBox x:Name=\"Input1\" Text=\"100\" Width=\"150\" Height=\"35\" Background=\"Black\" Foreground=\"White\" HorizontalContentAlignment=\"Center\" VerticalContentAlignment=\"Center\" Margin=\"15\"&gt;&lt;/TextBox&gt; &lt;TextBox x:Name=\"Input2\" Text=\"100\" Width=\"150\" Height=\"35\" Background=\"Black\" Foreground=\"White\" HorizontalContentAlignment=\"Center\" VerticalContentAlignment=\"Center\" Margin=\"15\"&gt;&lt;/TextBox&gt; &lt;TextBox x:Name=\"Input3\" Text=\"100\" Width=\"150\" Height=\"35\" Background=\"Black\" Foreground=\"White\" HorizontalContentAlignment=\"Center\" VerticalContentAlignment=\"Center\" Margin=\"15\"&gt;&lt;/TextBox&gt; &lt;TextBox x:Name=\"Input4\" Text=\"100\" Width=\"150\" Height=\"35\" Background=\"Black\" Foreground=\"White\" HorizontalContentAlignment=\"Center\" VerticalContentAlignment=\"Center\" Margin=\"15\"&gt;&lt;/TextBox&gt; &lt;/StackPanel&gt; &lt;StackPanel Orientation=\"Horizontal\" Height=\"100\" HorizontalAlignment=\"Center\" Margin=\"0,150,0,0\"&gt; &lt;Label x:Name=\"Unit1\" Content=\"&#123;Binding SpeedUnit&#125;\" Width=\"150\" Height=\"35\" HorizontalContentAlignment=\"Center\" VerticalContentAlignment=\"Center\" Margin=\"15\"&gt;&lt;/Label&gt; &lt;Label x:Name=\"Unit2\" Content=\"&#123;Binding SpeedUnit&#125;\" Width=\"150\" Height=\"35\" HorizontalContentAlignment=\"Center\" VerticalContentAlignment=\"Center\" Margin=\"15\"&gt;&lt;/Label&gt; &lt;Label x:Name=\"Unit3\" Content=\"&#123;Binding SpeedUnit&#125;\" Width=\"150\" Height=\"35\" HorizontalContentAlignment=\"Center\" VerticalContentAlignment=\"Center\" Margin=\"15\"&gt;&lt;/Label&gt; &lt;Label x:Name=\"Unit4\" Content=\"&#123;Binding SpeedUnit&#125;\" Width=\"150\" Height=\"35\" HorizontalContentAlignment=\"Center\" VerticalContentAlignment=\"Center\" Margin=\"15\"&gt;&lt;/Label&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 单位转换 思路一 利用一个循环刷新的线程,根据UnitCombox的索引,动态赋值给UnitLable 缺点明显,需要知道控件名,利用FindName查找,线程中操作UI控件需要Dispatcher 关闭窗体后循环中可能还在查找控件,FindName会抛出异常 思路二 创建一个具有通知UI属性的变量,根据UnitCombox的索引,将选中的单位赋值给变量,将变量绑定到UnitLable的Content属性 123456789101112131415161718192021222324public MainWindowViewModel()&#123; Task task = new Task(() =&gt;RefrushData()); task.Start();&#125;List&lt;string&gt; UnitList = new List&lt;string&gt;() &#123; \"mm/s\", \"mm/min\" &#125;;private string _SpeedUnit;public string SpeedUnit&#123; get &#123; return _SpeedUnit; &#125; set &#123; _SpeedUnit = value; RaisePropertyChanged(\"SpeedUnit\"); &#125;&#125;public void RefrushData()&#123; while (true) &#123; SpeedUnit = UnitList[MainWindow.SpeedUnitSelectMode]; Thread.Sleep(100); &#125;&#125; 数值转换单位已经更新了,那么数值也必须要更新,全部以速度的基本单位举例 思路一 只有在UnitCombox的索引变了的情况下才需要更新 保存上一次的索引,将上一次的数值统计转换为mm/s 将以mm/s为单位的数值,转换为UnitCombox选中的单位数值 思路二 创建一个具有通知UI属性的变量,根据从下位读取上来的速度单位，转为界面选择的单位，绑定 基于MVVM的原则,能不直接操作控件,就不要直接操作控件,尽量以数据驱动程序 但是,这个Demo是纯界面的单位转换,界面上的单位转换要多一次,需要记录之前是什么单位,线程中处理数据会有问题如果是上位和下位之间的数据交互单位转换,就不存在这个问题 12345678910111213141516private void UnitCombox_SelectionChanged(object sender, SelectionChangedEventArgs e)&#123; //单位换算 SpeedUnitSelectMode = UnitCombox.SelectedIndex; for (int i = 0; i &lt; 4; ++i) &#123; string name = \"Input\" + (i + 1).ToString(); TextBox box = Application.Current.MainWindow.FindName(name) as TextBox; if (box != null) &#123; string speed = HMIUnitConvert(box.Text.Trim()); box.Text = ConvertSpeedUnit(Convert.ToDouble(speed)).ToString(); &#125; &#125; preindex = UnitCombox.SelectedIndex;&#125; 效果演示 2020-7-31更新 添加了常用的四种速度单位,并且mm/s转inch/min之后转回去的也不会有误差","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"VSCode调试QT项目","slug":"VSCode-DebugQT","date":"2020-07-26T16:00:00.000Z","updated":"2020-07-27T06:57:05.000Z","comments":true,"path":"2020/07/27/VSCode-DebugQT/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/27/VSCode-DebugQT/","excerpt":"搭建QT环境 构建QT项目 launch.json和task.json 结果 关于QT的小问题","text":"搭建QT环境 构建QT项目 launch.json和task.json 结果 关于QT的小问题 搭建QT环境安装好CPP环境,control+shift+p,打开命令窗口,输入C/C++选择Config配置(json),然后在includepath下将QT的头文件目录全部加入 构建QT项目经过上一步的操作,输入QT的代码因为已经可以有自动补全的功能了,然后写好cpp,h文件,打开QT的命令行工具 然后进入项目路径,输入qmake -project此时,项目文件夹下会生成一个以项目名为前缀的.pro文件 执行qmake,项目中会生成Makefile.Debug和Makefile.Release 我自己的环境下我执行make会找不到命令,设置了环境变量且重启后依旧没解决,网上查找的解决方法是使用mingw32-make,所以输入命令mingw32 -make -f Makefile.Debug,Debug目录中应该有.exe 但是,一开始我并没有成功!!! 至此,我个人的情况是,项目中Debug目录为空,然后我把Makefile.Debug去掉了,在执行一遍发现Release目录下有.exe,然后运行了一遍发现Debug目录下也有.exe了 然后进入Debug目录,执行windeployqt xx.exe,xx指的是exe程序名 此时项目目录如下 launch.json和task.jsonmiDebuggerPath替换成自己的编译器路径program替换成自己的Debug下的exe路径 1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"(gdb) Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"$&#123;workspaceFolder&#125;/debug/qt.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;workspaceFolder&#125;\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"C:/MinGW/bin/gdb.exe\", \"setupCommands\": [ &#123; \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true &#125; ], \"preLaunchTask\": \"Build\" &#125; ]&#125; 12345678910&#123; \"version\": \"2.0.0\", \"tasks\": [ &#123; \"label\": \"Build\", // build任务 \"type\": \"shell\", \"command\": \"mingw32-make -f Makefile.Debug\" &#125; ]&#125; 结果 关于QT的小问题以上的QT的文件目录exe代码是我从csdn上找的,不是原创代码作者博客,代码的Git链接文内有QDirModel会造成主线程阻塞作者也知道,然后我改成QFileSystemModel之后发现了一个问题 界面依旧会卡顿,网上查了半天说是FileIconProvider导致主线程调用了所以卡着,按照网上说的重写了那个方法并且给Model也设置了IconProvider,未能解决 但是,我发现,在家里的电脑上并没有发现这个问题,网上其他人好像也都没有类似情况! 终于我发现了区别, 公司的这两个磁盘,G盘是空的驱动器,Z盘是一个共享盘,服务器不开是打不开的,QTCreator中运行显示信息SHGetFileInfo()超时,家里的电脑没有这种磁盘,不存在这个问题,所以我想问题是不是出在这里呢? 暂未解决,留待以后更新","categories":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.lubaobao.xyz/categories/VsCode/"}],"tags":[]},{"title":"WPF的ComboBox的联动","slug":"WPF-ComboBoxGanged","date":"2020-07-17T16:00:00.000Z","updated":"2020-07-18T06:25:40.000Z","comments":true,"path":"2020/07/18/WPF-ComboBoxGanged/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/18/WPF-ComboBoxGanged/","excerpt":"ComboBox的联动通常有两种,一种是第一个ComboBox选择省份,第二个ComboBox的Item出现该省所有的城市,另一种就是Item选一个少一个的那种 我现在的需求是做出第二种效果,其实两种思路都一样,只是不一样的效果而已","text":"ComboBox的联动通常有两种,一种是第一个ComboBox选择省份,第二个ComboBox的Item出现该省所有的城市,另一种就是Item选一个少一个的那种 我现在的需求是做出第二种效果,其实两种思路都一样,只是不一样的效果而已 思路 MVVM的数据绑定使用ViewModel建立一个ObservableCollection的列表或者用一个普通的list然后数据类继承INotifyPropertyChanged 数据类的定义除了有需要显示在ComboBox里的内容外,还需要一个bool类型的变量,表示是否可以被选中 样式中IsEnabled和Visibility的绑定如果需要该项被选择之后其余ComboBox不可选中,就只需要把bool类型的变量绑定到IsEnabled如果需要该项被选择之后其余ComboBox不显示该项,只需要把bool类型的变量使用转换器绑定到Visibility不可以把Item移除!会影响到其余的ComboBox,数据源不要修改!! 实现12345678&lt;ComboBox x:Name=\"combox1\" Width=\"150\" Height=\"35\" ItemsSource=\"&#123;Binding NowIOList&#125;\" DisplayMemberPath=\"Index\"&gt; &lt;ComboBox.ItemContainerStyle&gt; &lt;Style TargetType=\"ComboBoxItem\"&gt; &lt;Setter Property=\"IsEnabled\" Value=\"&#123;Binding CanSelected&#125;\"&gt;&lt;/Setter&gt; &lt;Setter Property=\"Visibility\" Value=\"&#123;Binding CanSelected,Converter=&#123;StaticResource YourConverter&#125;&#125;\"&gt;&lt;/Setter&gt; &lt;/Style&gt; &lt;/ComboBox.ItemContainerStyle&gt;&lt;/ComboBox&gt; ItemSource就是ViewModel下的列表,DisplayMenberPath是要展示在ComboBox里的成员变量的名称 12345678910public List&lt;IOData&gt; _NowIOList;public List&lt;IOData&gt; NowIOList&#123; get &#123; return _NowIOList; &#125; set &#123; _NowIOList = value; RaisePropertyChanged(\"NowIOList\"); &#125;&#125; 12345678910111213141516171819202122232425262728public class IOData : INotifyPropertyChanged&#123; public int index; public int Index &#123; get &#123; return index; &#125; set &#123; index = value; if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(\"Index\")); &#125; &#125; public bool canSelected; public bool CanSelected &#123; get &#123; return canSelected; &#125; set &#123; canSelected = value; if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(\"CanSelected\")); &#125; &#125; public event PropertyChangedEventHandler PropertyChanged;&#125; 如果数据类不继承INotifyPropertyChanged会有什么结果请自己尝试 1234567891011121314151617181920212223private void Window_Loaded(object sender, RoutedEventArgs e)&#123; for (int i = 0; i &lt; 3; ++i) &#123; string name = \"combox\" + (i + 1).ToString(); ComboBox box = this.FindName(name) as ComboBox; box.DropDownOpened += Box_DropDownOpened; &#125;&#125;private void Box_DropDownOpened(object sender, EventArgs e)&#123; for (int i = 0; i &lt; viewModel.NowIOList.Count; ++i) viewModel.NowIOList[i].CanSelected = true; for (int i = 0; i &lt; 3; ++i) &#123; string name = \"combox\" + (i + 1).ToString(); ComboBox box = this.FindName(name) as ComboBox; if (box.SelectedItem == null) continue; viewModel.NowIOList.Find((a) =&gt; a.Index == (box.SelectedItem as IOData).Index).CanSelected = false; &#125;&#125; Unloaded事件里还需要写-= 这里面的3是Demo里ComboBox的数量,具体可以根据页面的ComboBox数量多少自己修改,思路是展开ConboBox时,将已选中的Item的CanSelected置为false,那么转换之后对应Item的Visibility就是Collapsed 问题使用ComboBox打开作为更新的触发会造成大量无用的重复操作,我只是打开ComboBox并没有修改选中项,不应该更新List触发时机应该修改为SelectionChanged 1234567891011121314151617181920212223private void Window_Loaded(object sender, RoutedEventArgs e)&#123; for (int i = 0; i &lt; 3; ++i) &#123; string name = \"combox\" + (i + 1).ToString(); ComboBox box = this.FindName(name) as ComboBox; box.SelectionChanged += Box_SelectionChanged; &#125;&#125;private void Box_SelectionChanged(object sender, SelectionChangedEventArgs e)&#123; for (int i = 0; i &lt; viewModel.NowIOList.Count; ++i) viewModel.NowIOList[i].CanSelected = true; for (int i = 0; i &lt; 3; ++i) &#123; string name = \"combox\" + (i + 1).ToString(); ComboBox box = this.FindName(name) as ComboBox; if (box.SelectedItem == null) continue; viewModel.NowIOList.Find((a) =&gt; a.Index == (box.SelectedItem as IOData).Index).CanSelected = false; &#125;&#125; 效果","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"WPF的后台数据绑定","slug":"WPF-BackstageBinding","date":"2020-07-16T16:00:00.000Z","updated":"2020-07-21T01:44:45.000Z","comments":true,"path":"2020/07/17/WPF-BackstageBinding/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/17/WPF-BackstageBinding/","excerpt":"有很多时候,自定义控件是由多个不同的系统提供的控件组合起来的,那么在Xaml前端界面上,实例化对象之后,是没有办法访问到内部的控件的(哪怕你命了名),但是又想给他绑定数据源怎么办呢? 2020-07-21更新TextBox绑定List某项","text":"有很多时候,自定义控件是由多个不同的系统提供的控件组合起来的,那么在Xaml前端界面上,实例化对象之后,是没有办法访问到内部的控件的(哪怕你命了名),但是又想给他绑定数据源怎么办呢? 2020-07-21更新TextBox绑定List某项 情景1234567891011121314151617181920212223&lt;ProgressBar Grid.Row=\"0\" x:Name=\"progressBar\" x:FieldModifier=\"public\" Style=\"&#123;StaticResource ProgressBarStyle2&#125;\" local:EllipseClipper.IsClipping=\"True\" HorizontalAlignment=\"Center\" Height=\"100\" VerticalAlignment=\"Top\" Width=\"100\" Value=\"50\" RenderTransformOrigin=\"0.5,0.5\" Foreground=\"&#123;DynamicResource BodorBkColor&#125;\"&gt; &lt;ProgressBar.Effect&gt; &lt;DropShadowEffect BlurRadius=\"7\" Direction=\"-500\" Color=\"#FF3E3E3E\" RenderingBias=\"Quality\" FrameworkElement.FlowDirection=\"LeftToRight\" ShadowDepth=\"1\" /&gt; &lt;/ProgressBar.Effect&gt; &lt;ProgressBar.Background&gt; &lt;RadialGradientBrush&gt; &lt;GradientStop Color=\"#363636\" Offset=\"1\" /&gt; &lt;GradientStop Color=\"#656666\" /&gt; &lt;/RadialGradientBrush&gt; &lt;/ProgressBar.Background&gt; &lt;ProgressBar.RenderTransform&gt; &lt;TransformGroup&gt; &lt;ScaleTransform/&gt; &lt;SkewTransform/&gt; &lt;RotateTransform Angle=\"-90\"/&gt; &lt;TranslateTransform/&gt; &lt;/TransformGroup&gt; &lt;/ProgressBar.RenderTransform&gt; &lt;/ProgressBar&gt; &lt;Label Grid.Row=\"1\" x:Name=\"labelModelName\" x:FieldModifier=\"public\" Content=\"功率(KW)\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Foreground=\"&#123;StaticResource NormalForeground&#125;\" FontSize=\"15\"/&gt; &lt;Label Grid.Row=\"0\" x:Name=\"labelValue\" x:FieldModifier=\"public\" Content=\"&#123;Binding Value, ElementName=progressBar,Converter=&#123;StaticResource ValueConverter&#125;&#125;\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Foreground=\"&#123;StaticResource NormalForeground&#125;\" FontSize=\"15\" SizeChanged=\"labelValue_SizeChanged\"/&gt; 这段xaml的代码不保证有效,只是举个例子随便截取的一段,这个自定义控件由一个ProgreeBar和两个Label组成,其中Label1的Content绑定的是ProgressBar的Value,那么在外部调用这个自定义控件时 1&lt;local:LocalUserControl x:Name=\"localUserControl\" Grid.Column=\"0\" Width=\"120\" /&gt; 这个时候已经访问不到内部的ProgressBar了,怎么绑定数据就是一个问题了 也不可能在控件里就绑定,那所有的控件绑定的都是一个数据源了 后台绑定之前说xaml里哪怕内部的控件命了名也访问不了,那么命名干什么呢?是为了让后台代码可以访问到 1234567//绑定当前速度CurrentSpeedBall.progressBar.Maximum = 100;SetBindings(CurrentSpeedBall.progressBar, viewModel.motionStatus, \"Data\", BindingMode.OneWay, ProgressBar.ValueProperty);//绑定和初始化进给倍率viewModel.motionStatus.feedRate = BusinessLayerService.CommonControlStatus.FeedRate = 100;SetBindings(FeedRateSlider.slider, viewModel.motionStatus, \"feedRate\", BindingMode.TwoWay, Slider.ValueProperty); 后台是可以通过命名+.+命名的方式访问到内部的控件的 SetBinding &amp; BindingOperations这两者没什么大的区别,只是使用方法略微不同如果需要封装成函数,控件的类型写UserControl会无法转换,所以应该写FrameWorkElement SetBinding使用:UserControl.SetBinding(DependcyProperty dp,BindingBase binding) BindingOperations使用:BindingOperations.SetBinding(Obj, DepProperty, binding); Binding.Source数据源,一般都是一个类 Binding.Path双向绑定的时候或者数据源是类的时候会需要,如果数据源是类,path就是成员变量的名称 Binding.Mode绑定的方式,和xaml里一致,one way/two way/…之类的,UpdateTrigger也是一样的设置方法 12345678910public void SetBindings(FrameworkElement Obj, Object Source, string PropertyPath, BindingMode Mode, DependencyProperty DepProperty)&#123; Binding binding = new Binding(); binding.Source = Source; binding.Path = new PropertyPath(PropertyPath); binding.Mode = Mode; if (Mode == BindingMode.TwoWay) binding.UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged; BindingOperations.SetBinding(Obj, DepProperty, binding);&#125; 可能遇到的问题如果绑定之后,界面UI没有变化,有可能是因为数据源没有通知UI发生了变化数据源的类应该继承INotifyPropertyChanged,并且实现接口 123456789101112131415public class DataSource : INotifyPropertyChanged &#123; private double _Data; public double Data &#123; get &#123; return _Data; &#125; set &#123; _Data = value; if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(\"Data\")); &#125; &#125; public event PropertyChangedEventHandler PropertyChanged; &#125; 效果 TextBox绑定List某项如果遇到那种参数很多，但是有共同项的，挨个在viewModel里定义的话既不优雅工作量也很大，我们可以将共同的参数提取出来建一个类，然后new出来对象放入List里，可以减少很多工作量 比如现在有三根轴x，y，z，三根轴都有参数MaxSpeed，那么定义Axis0MaxSpeed,Axis1MaxSpeed,Axis2MaxSpeed就会巨麻烦 1234567891011121314public class AxisData : INotifyPropertyChanged&#123; private string maxSpeed; public string MaxSpeed &#123; get &#123; return maxSpeed; &#125; set &#123; maxSpeed = value; if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(\"MaxSpeed\")); &#125; &#125;&#125; 然后使用一个List,初始化三个对象,分别更新他们的值即可 1public List&lt;AxisData&gt; AxisDataList = new List&lt;AxisData&gt;() &#123; new AxisData(), new AxisData(), new AxisData() &#125;; 123456789101112131415161718192021222324public AxisConfigViewModel()&#123; Task task = new Task(() =&gt; &#123; UpdateData(); &#125;); task.Start();&#125;private void UpdateData()&#123; try &#123; #region 0号轴 AxisDataList[0].Number = BusinessLayerParamterService.Instance.AxisConfig.AxisList[0].Number; AxisDataList[0].MaxSpeed = BusinessLayerParamterService.Instance.AxisConfig.AxisList[0].MotionParms.MaxSpeed; #endregion #region 1号轴 AxisDataList[1].Number = BusinessLayerParamterService.Instance.AxisConfig.AxisList[1].Number; AxisDataList[1].MaxSpeed = BusinessLayerParamterService.Instance.AxisConfig.AxisList[1].MotionParms.MaxSpeed; #endregion &#125; catch&#123;&#125;&#125; List的数据,绑定某项到TextBox,xaml里我写的Binding不知道为啥不生效,所以我只能放在后台写了,Axis0MaxSpeed是前端TextBox的名字 123//最大速度Axis0MaxSpeed.SetBinding(TextBox.TextProperty, new Binding(\"[0].MaxSpeed\")&#123; Source = viewModel.AxisDataList, Mode = BindingMode.TwoWay, UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged &#125;);","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"HTML制作个人简介页面","slug":"HTML-About","date":"2020-07-14T16:00:00.000Z","updated":"2020-07-15T07:06:52.000Z","comments":true,"path":"2020/07/15/HTML-About/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/15/HTML-About/","excerpt":"我的博客是看的大神教程一步步做的,然后所以我的about界面,也准备仿着大佬的做，之前根本没学过web的前端，只接触过xaml这种带标签的设计语言…","text":"我的博客是看的大神教程一步步做的,然后所以我的about界面,也准备仿着大佬的做，之前根本没学过web的前端，只接触过xaml这种带标签的设计语言… 布局设计这个东西还是比较难得,我就直接没有设计,布局是照着别人的抄的,虽然实现是自己实现的，但是如果还是侵权的话，联系我删除大佬的about界面 最上层,旋转的头像、昵称、生日等信息 中间左半部分，技能和占比 中间右半部分，个人的简介 底部，图片链接 最底部，版权信息、博客链接 确定好每个区域的位置，背景色和透明度，颜色我不会弄成渐变的，暂且纯色代替，css我也没学过，写法如果错误请见谅.. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;style&gt; .center &#123; position: fixed; left: 20%; right: 20%; top: 10%; width: 60%; height: 15%; opacity: 0.95; float: left; background-color: white; &#125; .centerAfterLeft &#123; position: fixed; left: 20%; top: 26%; width: 29.5%; height: 50%; opacity: 0.95; float: left; background-color: white; &#125; .centerAfterRight &#123; position: fixed; right: 20%; top: 26%; width: 29.5%; height: 50%; opacity: 0.95; float: left; background-color: white; &#125; .footer &#123; position: fixed; left: 20%; right: 20%; top: 77%; width: 60%; height: 15%; opacity: 0.95; background-color: white; &#125; .lastfooter &#123; position: fixed; left: 20%; right: 20%; top: 93%; width: 60%; height: 30px; vertical-align: middle; text-align: center; background-color: transparent; &#125; body &#123; background-color: rgb(81, 77, 85); font-family: 楷体; &#125; &lt;/style&gt; 头像旋转遇到不会的就要多百度一下，然后我惊讶的发现了大佬也是查询的这篇博客，还留了言..HTML图片旋转 基本上博客上的内容复制过去就直接能用，然后我就不求甚解了.. 文字排版拿最上层举例,昵称和后面的文字是需要在一行的,标签p需要设置display:inline-block;然后空格我也不知道为啥HTML默认不显示,我查到的方法是&amp;nbsp,好像markdown里也是这样的 123456&lt;div style=\"float: left;margin-left: 20px;\"&gt; &lt;p style=\"margin-bottom: 10px;display: inline-block;font-weight: bold;\"&gt;昵称:&lt;/p&gt; &lt;p style=\"margin-bottom: 10px;display: inline-block;\"&gt;&amp;nbsp&amp;nbsp染墨灬若流云&lt;/p&gt;&lt;br&gt; &lt;p style=\"margin-bottom: 15px;display: inline-block;font-weight: bold;\"&gt;最爱:&lt;/p&gt; &lt;p style=\"margin-bottom: 15px;display: inline-block;\"&gt;&amp;nbsp&amp;nbsp迷人又可爱的鹿宝宝~&lt;/p&gt; &lt;/div&gt; 我知道这样写会有问题,如果是xaml布局,我会考虑竖屏下的情况,避免分辨率变化造成的页面显示异常,但是html实在是无能为力… 中间的右半部分,那个黑色的点很容易让人想到markdown的-,那么是不是html可以用markdown语法呢?很遗憾不可以,但是可以把markdown转换成html,Typora或者CSDN的编辑器都支持这个功能 1234567&lt;ul&gt; &lt;li&gt;学历: &lt;/li&gt;&lt;br&gt; &lt;li&gt;现况: &lt;/li&gt;&lt;br&gt; &lt;li&gt;目标: &lt;/li&gt;&lt;br&gt; &lt;li&gt;博客: &lt;/li&gt;&lt;br&gt; &lt;li&gt;兴趣: &gt;&lt;br&gt;&lt;/ul&gt; 导出后最后是没有&lt;br&gt;标签的,我是为了和左边对齐 绘制矩形这个我查了很多,都是用js来做,可惜js我也没学过,我觉得我在window_load事件中写会导致刷新的时候明显感觉矩形闪烁,大佬的博客about界面就没这个问题,所以我觉得这个方法不太对.. 123456789101112/*技能条*/var canvas = document.getElementById(\"SkillCanvas\");if (canvas == null) return;var t = new Array(12, 39, 64, 89, 114);var y = new Array(\"#4AB480\", \"#E1AB3E\", \"#DC595#7390F2\", \"#747DC5\");var l = new Array(120, 150, 40, 60, 30);var content = canvas.getContext(\"2d\");for (var i = 0; i &lt; 5; ++i) &#123; content.fillStyle = y[i]; content.fillRect(0, t[i], l[i], 15);&#125; 这样写维护性很差很差,但是考虑到这个界面过很久很久才可能更新,所以先只追求效果,不追求代码规范(给自己的菜找一找借口) 技能的百分比就还是之前的方法,移到合适的位置就好排版的话我毕竟没学过,追求效果类似我用的margin-left,直接偏移过去,不知道更优雅的做法是怎么样的..大佬的这个界面是禁用左右键和F12的.. 禁用左右键和F12大佬这样做的目的可能是保护自己的代码或者不让自己的界面被人改动,既然我们是仿照大佬的做,这个功能我们也要有 JS也可以禁用左右键,但是网上说禁用JS脚本后这招就没用了,所以这里用html自带的属性 123&lt;body topmargin=\"0\" oncontextmenu=\"return false\" ondragstart=\"return false\" onselectstart=\"return false\" onselect=\"document.selection.empty()\" oncopy=\"document.selection.empty()\" onbeforecopy=\"return false\" onmouseup=\"document.selection.empty()\"&gt; 将这段放入body标签中即可生效 禁用F12我只找到了JS的方法,不知道大佬是怎么做的.. 1234567window.onkeydown = window.onkeyup = window.onkeypress = function (event) &#123; // 判断是否按下F12，F12键码为123 if (event.keyCode = 123) &#123; event.preventDefault(); // 阻止默认事件行为 window.event.returnValue = false; &#125; &#125; 图片链接链接是&lt;a&gt;标签,图片链接就是在这个标签里加入一个&lt;img&gt;标签 1234&lt;a href=\"https://blog.csdn.net/Austin_Yan\" target=\"-blank\" title=\"CSDN\"&gt; &lt;img id=\"blog\" style=\"margin-top: 0px;left: 75%;position: absolute;\" src=\"https://cdn.jsdelivr.net/gh/AustinYANyh/Image@1.1.1/CSDN.png\"&gt; &lt;/a&gt; target设置为-blank表示在浏览器新标签页打开 title替换文字,鼠标移到上方显示的文字 唤醒微信的我没查到,查到的也不能用,但是QQ的可以跳转链接为http://wpa.qq.com/msgrd?v=3 &amp;uin=1241528539 &amp;site=qq&amp;menu=yes里面有空格是因为我不加空格我跳转之后啥也不发生…加了空格貌似发送了点什么但是不太对的样子… 飘雪飘雪的代码来源于大佬的教程https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 将js代码拷贝到script标签下,然后window_load事件调用即可 1234window.onload = function StartSnow() &#123; /* 调用及控制方法 */ var snow = new snowFall(&#123; maxFlake: 60 &#125;); snow.start(); 效果一些小细节比如说,中间左右部分之间的间隔和上下的不一致..背景图没有找用纯色代替..还有大佬的模块背景和技能条的颜色都是渐变的..这些我都没处理好,不过还是先记录下来先做到这个样子吧..","categories":[{"name":"HTML","slug":"HTML","permalink":"https://www.lubaobao.xyz/categories/HTML/"}],"tags":[]},{"title":"WPF的按行高亮显示文本框","slug":"WPF-HightLightTextBox","date":"2020-07-09T16:00:00.000Z","updated":"2020-07-11T06:27:08.000Z","comments":true,"path":"2020/07/10/WPF-HightLightTextBox/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/10/WPF-HightLightTextBox/","excerpt":"之前做Winform的防QQ的通讯程序的时候，用到了文本框高亮显示，现在试试在WPF里试着实现","text":"之前做Winform的防QQ的通讯程序的时候，用到了文本框高亮显示，现在试试在WPF里试着实现 RichTextBox实现思路 利用TextPointer使用GetPositionAtOffst(double offset)方法获取需要高亮的文字开始位置的索引和结尾位置的索引 获取偏移量RichTextBox行结尾处的偏移量为开头的偏移量+文本长度+4,这里的4是”\\r\\n”的长度 利用TextRange内的ApplyPropertyValue方法新建一个TextRange,参数就是刚才的两个索引(TextPointer),然后修改TextElement的附加属性 代码12345678910111213141516171819202122232425262728293031TextRange textrange = new TextRange(OrderShow.Document.ContentStart, OrderShow.Document.ContentEnd);string[] str = textrange.Text.Split(new string[] &#123; \"\\r\\n\" &#125;, StringSplitOptions.RemoveEmptyEntries);int index = 0;for (int i = 0; i &lt; str.Count(); ++i)&#123; Dispatcher.BeginInvoke(new Action(() =&gt; &#123; textrange = new TextRange(OrderShow.Document.ContentStart, OrderShow.Document.ContentEnd); textrange.ApplyPropertyValue(TextElement.ForegroundProperty, System.Windows.Media.Brushes.Black); textrange.ApplyPropertyValue(TextElement.FontWeightProperty, FontWeights.Regular); &#125;)); TextPointer p1 = OrderShow.Selection.Start; p1 = p1.GetPositionAtOffset(index); index += str[i].Length; TextPointer p2 = OrderShow.Selection.Start; p2 = p2.GetPositionAtOffset(index); Dispatcher.BeginInvoke(new Action(() =&gt; &#123; textrange = new TextRange(p1, p2); textrange.ApplyPropertyValue(TextElement.ForegroundProperty, System.Windows.Media.Brushes.Blue); textrange.ApplyPropertyValue(TextElement.FontWeightProperty, FontWeights.Bold); &#125;)); index += 4; Thread.Sleep(1000);&#125;Dispatcher.BeginInvoke(new Action(() =&gt;&#123; textrange = new TextRange(OrderShow.Document.ContentStart, OrderShow.Document.ContentEnd); textrange.ApplyPropertyValue(TextElement.ForegroundProperty, System.Windows.Media.Brushes.Black); textrange.ApplyPropertyValue(TextElement.FontWeightProperty, FontWeights.Regular);&#125;)); 然而有个最严重的问题,RichTextBox的ScollViewer的方法除了ScrollToEnd和ScrollToHome外只有设置水平和垂直的偏移量,根据高亮内容的变化,不太方便控制滚动条到合适的位置..(我不会而已,不代表不可以实现) 效果只改了前景色没修改背景色高亮显示前光标必须在ContentStart,不然之后的index计算不准 TextBox实现思路为了解决上面的问题,所以又想用最开始的这个控件,优点是TextBox有ScrollToLine(int LineIndex)方法,滚动条的位置不需要管,只需要给行号即可,行号可以把TextBox的文本内容按”\\r\\n”分割获得,缺点是,高亮显示没有RichTextBox那么方便 Select(int start,int length)方法使用Select方法,可以选中start位置开始长度为length的字符要有显示效果需要TextBox获得焦点 SelectionBrush(System.Windows.Media.Brush)使用这个方法可以改变文本被选中的颜色,效果肯定不如既可以修改Foreground又可以修改Background的,其他方式我没查出来..(暂且先这样做) 获取偏移量方法和上面的一样,区别是TextBox计算时末尾加的是2,只有”\\n” 代码12345678910111213141516171819string txt = string.Empty;txt = OrderShow.Text;OrderShow.Focus();string[] str = txt.Split(new string[] &#123; \"\\r\\n\" &#125;, StringSplitOptions.None);int index = 0;for (int i = 0; i &lt; str.Count(); ++i)&#123; OrderShow.Focus(); OrderShow.CaretIndex = 0; OrderShow.Select(index, str[i].Length); OrderShow.ScrollToLine(i); Thread t = new Thread(o =&gt; Thread.Sleep(200)); t.Start(this); while (t.IsAlive) System.Windows.Forms.Application.DoEvents(); index += str[i].Length + 2;&#125;Importbtn.Focus(); 遇到的问题之前都是新建了一个线程去做高亮的事情,因为Thread.Sleep()在主线程调用会让界面UI假死,然后遇到了各种什么可能是CLR错误之类的东西,而且换到TextBox之后居然只有调试进断点才能看到效果,直接运行界面没任何变化 避免界面假死在Winform的时候用过DoEvents,所以想了一下直接不使用线程了,就在主线程延时操作 1234Thread t = new Thread(o =&gt; Thread.Sleep(200));t.Start(this);while (t.IsAlive) System.Windows.Forms.Application.DoEvents(); 线程只需要延时即可 文本内容如果有空行,那么在分割的时候StringSplitOptiions选择None,不然索引位置会计算错误造成高亮的不是想要的内容 效果2020-07-11更新 综合两种方法的优缺点,但是又有了新的问题 ListView实现思路TextBox的滚动条可以精确到行,RichTextBox的字体高亮,把这两个结合起来 TextBlock作为Item使用TextBlock的原因是因为他有Forceground、Background、FontWeight和FontSize属性 ScrollToView(Item item)这个方法可以精确的将滚动条跳转到ListView中的控件,与TextBox的ScrollToLine不同的是这个的滚动条位置是将控件显示在最下方 优点ListView本身就有行的概念,放入的TextBlock就是按行排布的,所以不需要计算index来找到需要高亮的文本内容 代码1234567891011121314151617for (int i = 0; i &lt; str.Count(); ++i)&#123; listview.ScrollIntoView(listview.Items[i]); (listview.Items[i] as TextBlock).Foreground = Brushes.Red; (listview.Items[i] as TextBlock).Background = Brushes.Yellow; (listview.Items[i] as TextBlock).FontWeight = FontWeights.Bold; (listview.Items[i] as TextBlock).FontSize = 16; Thread t = new Thread(o =&gt; Thread.Sleep(100)); t.Start(this); while (t.IsAlive) System.Windows.Forms.Application.DoEvents(); (listview.Items[i] as TextBlock).Foreground = Brushes.White; (listview.Items[i] as TextBlock).Background = Brushes.Transparent; (listview.Items[i] as TextBlock).FontWeight = FontWeights.Regular; (listview.Items[i] as TextBlock).FontSize = 13; t.Abort();&#125; 遇到的问题ListView默认的MouseOver和Selected会有巨丑的深蓝色背景Bodor,我们按行高亮只需要演示,不需要这个东西重写样式将对应的Background修改为Transparent 12345678910111213141516171819202122232425262728293031323334&lt;Style TargetType=\"&#123;x:Type ListViewItem&#125;\"&gt; &lt;Setter Property=\"Template\"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=\"&#123;x:Type ListViewItem&#125;\"&gt; &lt;Border Name=\"Bd\" Background=\"&#123;TemplateBinding Background&#125;\" BorderBrush=\"&#123;TemplateBinding BorderBrush&#125;\" BorderThickness=\"&#123;TemplateBinding BorderThickness&#125;\" Padding=\"&#123;TemplateBinding Padding&#125;\" SnapsToDevicePixels=\"true\"&gt; //用于显示本身的Content &lt;ContentPresenter HorizontalHorizontalContentAlignment&#125;\" VerticalAlignment=\"&#123;TemplateBinding VerticalContentAlignment&#125;\" SnapsToDevicePixels=\"&#123;TemplateBinding SnapsToDevicePixels&#125;\"/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;Setter Property=\"FocusVisualStyle\" Value=\"&#123;x:Null&#125;\"/&gt; &lt;Setter Property=\"BorderThickness\" Value=\"0\"/&gt; &lt;Setter Property=\"Foreground\" Value=\"Black\"/&gt; &lt;Setter Property=\"Background\" Value=\"Transparent\"/&gt; &lt;Setter Property=\"VerticalAlignment\" Value=\"Top\"/&gt; &lt;Setter Property=\"FontSize\" Value=\"14\"/&gt; &lt;Style.Triggers&gt; &lt;!--触发器--&gt; &lt;Trigger Property=\"IsMouseOver\" Value=\"True\"&gt; &lt;Setter Property=\"Background\" Value=\"Transparent\"/&gt; &lt;Setter Property=\"BorderBrush\" Value=\"Transparent\"/&gt; &lt;/Trigger&gt; &lt;Trigger Property=\"IsSelected\" Value=\"true\"&gt; &lt;Setter Property=\"Background\" Value=\"Transparent\"/&gt; &lt;Setter Property=\"Foreground\" Value=\"White\"/&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt;&lt;/Style&gt; 但是,如果有编辑需求的就麻烦了,TextBlock不可以编辑,而且ListView也不可以像文本框一样选择一片所以,需要编辑的时间将ListView隐藏,显示一个等大的TextBox去编辑吧#doge (下下策,好的方法我也不会) 效果","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"培养Vim使用习惯，Chrome安装Vimium插件","slug":"Chrome-Vimium","date":"2020-07-07T16:00:00.000Z","updated":"2020-07-08T01:52:06.000Z","comments":true,"path":"2020/07/08/Chrome-Vimium/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/08/Chrome-Vimium/","excerpt":"为了让自己更快的熟练各种快捷键，但是仅仅在日常写代码的情况下，很明显是不够的，于是我在chrome上装了这个插件，使自己无论何时都在使用vim的过程中，达到迅速上手改变自己操作习惯的目的(尽量不使用鼠标)..","text":"为了让自己更快的熟练各种快捷键，但是仅仅在日常写代码的情况下，很明显是不够的，于是我在chrome上装了这个插件，使自己无论何时都在使用vim的过程中，达到迅速上手改变自己操作习惯的目的(尽量不使用鼠标).. Chrome WebStore首先在谷歌的插件商店中搜索Vimium,然后找到下载量最多的那个就是,直接下载安装即可,至于怎么翻墙,以后再写一篇 Vimium常用命令 滚动 j:与Vim一致,向下滚动 k:与Vim一致,向上滚动 d:向下滚动一个屏幕的距离 u:向上滚动一个屏幕的距离 gg:与Vim一致,到达页面顶部 G:与Vim一致,到达页面底部 标签页 J:切换到上一个标签页(为什么J变成向上切换??) K:切换到下一个标签页 页面操作 x:关闭当前页面 X:恢复刚刚关闭的页面 r:重新加载页面 L:与Vim一致,前进 H:与Vim一致,后退 t:打开新标签页，直接可以输入网址 常用的命令好像暂时就这么多,但是如何想要打开某一个连接进去查看怎么办呢? 上面的快捷键只是一些很简单的常用的快捷键,还有很多没有列举,比如Vim是不用鼠标的,那么怎么点击链接就成了问题,我们也不可能不点击链接,所以快捷键f就是专门处理链接的问题的 虽然看上去很傻,而且效率肯定不如鼠标点击快,但是我的目的不是为了操作快,而且为了改变我的使用习惯,等到Vim随心所欲的时候,浏览器Vim插件的作用也就不存在了 突然想到为了发博客的图片能够显示居然还需要先发到CSDN上,CSDN居然变成了图床一样的用法,还是应该把自己以前做的图片服务器搭起来,也当作是复习了","categories":[],"tags":[]},{"title":"WPF的Command传入多参和快捷键设置","slug":"WPF-ShortCutKey","date":"2020-07-06T16:00:00.000Z","updated":"2020-07-08T07:58:07.000Z","comments":true,"path":"2020/07/07/WPF-ShortCutKey/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/07/WPF-ShortCutKey/","excerpt":"多活动活动脖子，多运动运动，拒绝颈椎病，从我做起！","text":"多活动活动脖子，多运动运动，拒绝颈椎病，从我做起！ 多路绑定+转换器使用MVVM模式的时候,多半将view中产生的操作通过command绑定到viewModel下处理,可以使用commandparameter将需要的参数传递过去,但是如果需要的参数超过一个的情况下,该怎么处理呢? 1234567891011121314151617181920212223242526&lt;Button x:Name=\"btyAutoUp\" Content=\"Y+\" Height=\"50\" Canvas.Left=\"101\" Width=\"50\" VerticalContentAlignment=\"Center\" Canvas.Top=\"195\" Margin=\"0,10,210,0\" VerticalAlignment=\"Top\" HorizontalAlignment=\"Right\"&gt; &lt;i:Interaction.Triggers&gt; &lt;i:EventTrigger EventName=\"PreviewMouseDown\"&gt; &lt;i:InvokeCommandAction Command=\"&#123;Binding JogCommand&#125;\"&gt; &lt;i:InvokeCommandAction.CommandParameter&gt; &lt;MultiBinding Converter=\"&#123;StaticResource YourConveter&#125;\"&gt; &lt;Binding ElementName=\"btyAutoUp\" Path=\"Content\"&gt;&lt;/Binding&gt; &lt;Binding ElementName=\"stepbtn\" Path=\"State\"&gt;&lt;/Binding&gt; &lt;Binding ElementName=\"StepDistance\" Path=\"Text\"&gt;&lt;/Binding&gt; &lt;Binding ElementName=\"IncrSpeed\" Path=\"Text\"&gt;&lt;/Binding&gt; &lt;/MultiBinding&gt; &lt;/i:InvokeCommandAction.CommandParameter&gt; &lt;/i:InvokeCommandAction&gt; &lt;/i:EventTrigger&gt; &lt;i:EventTrigger EventName=\"PreviewMouseUp\"&gt; &lt;i:InvokeCommandAction Command=\"&#123;Binding JogStopCommand&#125;\"&gt; &lt;i:InvokeCommandAction.CommandParameter&gt; &lt;MultiBinding Converter=\"&#123;StaticResource YourConveter&#125;\"&gt; &lt;Binding ElementName=\"btyAutoUp\" Path=\"Content\"&gt;&lt;/Binding&gt; &lt;Binding ElementName=\"stepbtn\" Path=\"State\"&gt;&lt;/Binding&gt; &lt;/MultiBinding&gt; &lt;/i:InvokeCommandAction.CommandParameter&gt; &lt;/i:InvokeCommandAction&gt; &lt;/i:EventTrigger&gt; &lt;/i:Interaction.Triggers&gt; &lt;/Button&gt; MultiBinding中可以写很多个Binding,但是标签中必须要有一个转换器,转换器其实也很好写,就是把传入的参数备份一遍,不然传入下一个参数的时候上一个就消失了 与转换器不同的是,多路绑定转换继承的是iMultiValueConverter普通绑定转换继承的iValueConverter 1234567891011public class MultiBindingConverter:iMultiValueConverter&#123; public object Convert(object[] values,Type targetType,object parameter,CultureInfo culture) &#123; return values.Clone(); &#125; public object[] ConverterBack(object[] values,Type targetType,object parameter,CultureInfo culture) &#123; throw new NotlmplementedException(); &#125;&#125; 快捷键设置快捷键可以使用keydown事件也可以使用InputBinding,一个是写在xaml.cs里一个是写在viewModel里,我觉得没啥影响,看个人喜好博客里写Binding的方式 123&lt;Window.InputBindings&gt; &lt;KeyBinding Getsture&#x3D;&quot;Control+Shift+B&quot; Command&#x3D;&quot;&#123;Binding DebugCommand&#125;&quot;&gt;&lt;&#x2F;Window.InputBindings&gt; 123456789101112131415public DelegateCommand DebugCommand &#123;get;set;&#125;public MainWindowViewModel()&#123; DebugCommand = new DelegateCommand(()=&gt; &#123; if(Keyboard.IsKeyDown(Key.LeftCtrl) &amp;&amp; Keyboard.IsKeyDown(Key.LeftShift) &amp;&amp; Keyboard.IsKeyDown(Key.B)) &#123; var window = Application.Current.MainWindow; MainWindow mainWindow = new MainWindow(window); MainWindow.IsOpen = true; mainWindow.Show(); &#125; &#125;);&#125; 但是有个问题暂时解决不了,微软的输入法Ctrl+Shift+B是表情,中文状态下会优先触发微软的输入法快捷键,英文就没问题 2020-07-08更新,问题解决 以下代码和资料来源于:http://www.cppcns.com/ruanjian/csharp/92519.html 先定义一个类,用来调用API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HotKey&#123; /// &lt;summary&gt; /// 如果函数执行成功，返回值不为0。 /// 如果函数执行失败，返回值为0。要得到扩展错误信息，调用GetLastError。.NET方法:Marshal.GetLastWin32Error() /// &lt;/summary&gt; /// &lt;param name=\"hWnd\"&gt;要定义热键的窗口的句柄&lt;/param&gt; /// &lt;param name=\"id\"&gt;定义热键ID（不能与其它ID重复） &lt;/param&gt; /// &lt;param name=\"fsModifiers\"&gt;标识热键是否在按Alt、Ctrl、Shift、Windows等键时才会生效&lt;/param&gt; /// &lt;param name=\"vk\"&gt;定义热键的内容,WinForm中可以使用Keys枚举转换， /// WPF中Key枚举是不正确的,应该使用System.Windows.Forms.Keys枚举，或者自定义正确的枚举或int常量&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [DllImport(\"user32.dll\", SetLastError = true)] public static extern bool RegisterHotKey(IntPtr hWnd, int id, KeyModifiers fsModifiers, int vk); /// &lt;summary&gt; /// 取消注册热键 /// &lt;/summary&gt; /// &lt;param name=\"hWnd\"&gt;要取消热键的窗口的句柄&lt;/param&gt; /// &lt;param name=\"id\"&gt;要取消热键的ID&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [DllImport(\"user32.dll\", SetLastError = true)] public static extern bool UnregisterHotKey( IntPtr hWnd, int id ); /// &lt;summary&gt; /// 向全局原子表添加一个字符串，并返回这个字符串的唯一标识符,成功则返回值为新创建的原子ID,失败返回0 /// &lt;/summary&gt; /// &lt;param name=\"lpString\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [DllImport(\"kernel32\", SetLastError = true)] public static extern short GlobalAddAtom(string lpString); [DllImport(\"kernel32\", SetLastError = true)] public static extern short GlobalDeleteAtom(short nAtom); /// &lt;summary&gt; /// 定义了辅助键的名称（将数字转变为字符以便于记忆，也可去除此枚举而直接使用数值） /// &lt;/summary&gt; [Flags()] public enum KeyModifiers &#123; None = 0, Alt = 1, Ctrl = 2, Shift = 4, WindowsKey = 8 &#125; /// &lt;summary&gt; /// 热键的对应的消息ID /// &lt;/summary&gt; public const int WM_HOTKEY = 0x312; &#125; WPF的处理方法与Winform略微不一致,需要使用HwndSource拦截Window消息,说的简单点也就是自己定义一个消息处理的方法,拦截到的消息如果是定义的快捷键,就执行自己定义的消息处理方法 如果是Contorl+B这种的直接调用即可,Control+Shift+B这种的KeyModifiers需要使用|连接 12345678910private void Window_Loaded(object sender, RoutedEventArgs e)&#123; HwndSource hWndSource; WindowInteropHelper wih = new WindowInteropHelper(this); hWndSource = HwndSource.FromHwnd(wih.Handle); //添加处理程序 hWndSource.AddHook(MainWindowProc); alts = HotKey.GlobalAddAtom(\"Control-Shift-B\"); HotKey.RegisterHotKey(wih.Handle, alts, HotKey.KeyModifiers.Ctrl | HotKey.KeyModifiers.Shift, (int)System.Windows.Forms.Keys.B);&#125; 1234567891011121314151617private IntPtr MainWindowProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)&#123; switch (msg) &#123; case HotKey.WM_HOTKEY: &#123; int sid = wParam.ToInt32(); if (sid == alts) &#123; //按下快捷键需要做的事情 &#125; handled = true; break; &#125; &#125; return IntPtr.Zero;&#125; 现在就已经可以无论中英文状态,按下快捷键都会响应","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"Blend与Ps的交互","slug":"WPF-Blend&Ps","date":"2020-07-03T16:00:00.000Z","updated":"2020-07-04T03:07:46.000Z","comments":true,"path":"2020/07/04/WPF-Blend&Ps/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/04/WPF-Blend&Ps/","excerpt":"每天都学习一点WPF相关的知识，虽然我不太想从事CS前端类的工作，但是其实我也不知道自己想干什么…","text":"每天都学习一点WPF相关的知识，虽然我不太想从事CS前端类的工作，但是其实我也不知道自己想干什么… 获取PS文件的Path1&lt;Path Stroke=\"Black\" StrokeThickness=\"2\" Margin=\"450,20,0,0\" Data=\"M 0,0 C 250,0 50,200 300,200 M 50,50 A 20,20 0 1 0 70,70\"&gt; Path好用,但是Data难求,只要有Data就可以很容易画出复杂图形,虽然自从2015之后的Blend取消了导入Psd文件,但是可以从图层中复制svg,然后粘贴到文本编辑器中,就可以获取Path数据 1234567&lt;svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"3.44cm\" height=\"0.406cm\"&gt;&lt;path fill-rule=\"evenodd\" stroke=\"rgb(0, 0, 0)\" stroke-width=\"1px\" stroke-linecap=\"butt\" stroke-linejoin=\"miter\" fill=\"none\" d=\"M6.500,0.500 L91.500,0.500 C98.873,0.500 97.421,10.500 91.500,10.500 L6.500,10.500 C0.079,10.943 -2.443,1.118 6.500,0.500 Z\"/&gt;&lt;/svg&gt; 前提是PS中图形是使用矩形工具这类路径操作画出来的，不然是没有path的 WPF中使用Data将刚才svg中的标签首字母大写,d改为Data,就是取我们想要的信息然后复制,在WPF下直接放入Grid等容器中即可 1&lt;Path x:Name=\"PART_Track\" Stroke=\"Black\" StrokeThickness=\"1\" Data=\"M18,0 L18,0 137,0 M137,0 A2.5,2.5 0 0 1 130,30 L13,30 A1,1 0 0 1 18,0z\"&gt; 这是用代码画的，两条直线，两个圆弧，结果…不明白为什么L画出的直线和A画出的圆弧粗细不一样PS中画好复制Path在WPF中使用的结果好吧，这类工作还是应该交给专业的设计师来做，没有美工基础画出来的都是垃圾…自己画画简单的不复杂的还行…","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"WPF的DataTrigger遇到的问题","slug":"WPF-DataTrigger","date":"2020-06-30T16:00:00.000Z","updated":"2020-07-01T07:39:18.000Z","comments":true,"path":"2020/07/01/WPF-DataTrigger/","link":"","permalink":"https://www.lubaobao.xyz/2020/07/01/WPF-DataTrigger/","excerpt":"DataTrigger这种在xaml里的东西,因为打不了断点,所以很难找出错误到底在哪里,问题点很难定位,所以只能采取避免的方法暂时规避掉,等以后弄明白了再修改…","text":"DataTrigger这种在xaml里的东西,因为打不了断点,所以很难找出错误到底在哪里,问题点很难定位,所以只能采取避免的方法暂时规避掉,等以后弄明白了再修改… DataTrigger不触发12345678910&lt;TabItem x:Name&#x3D;&quot;Cutfilm_param_item&quot; Style&#x3D;&quot;&#123;DynamicResource VerticalTabItemStyle&#125;&quot; Visibility&#x3D;&quot;Collapsed&quot;&gt; &lt;i:Interaction.Triggers&gt; &lt;ei:DataTrigger Binding&#x3D;&quot;&#123;Binding ElementName&#x3D;EnableCutFilm,Path&#x3D;IsChecked&#125;&quot; Value&#x3D;&quot;true&quot;&gt; &lt;ei:ChangePropertyAction TargetName&#x3D;&quot;Cutfilm_param_item&quot; PropertyName&#x3D;&quot;Visibility&quot; Value&#x3D;&quot;Visible&quot;&gt;&lt;&#x2F;ei:ChangePropertyAction&gt; &lt;&#x2F;ei:DataTrigger&gt; &lt;ei:DataTrigger Binding&#x3D;&quot;&#123;Binding ElementName&#x3D;EnableCutFilm,Path&#x3D;IsChecked&#125;&quot; Value&#x3D;&quot;false&quot;&gt; &lt;ei:ChangePropertyAction TargetName&#x3D;&quot;Cutfilm_param_item&quot; PropertyName&#x3D;&quot;Visibility&quot; Value&#x3D;&quot;Collapsed&quot;&gt;&lt;&#x2F;ei:ChangePropertyAction&gt; &lt;&#x2F;ei:DataTrigger&gt; &lt;&#x2F;i:Interaction.Triggers&gt;&lt;&#x2F;TabItem&gt; 上面这部分xaml的目的是,通过一个名为EnableCutFilm的CheckBox的IsChecked属性控制一个名为Cutfilm_param_item的TabItem的显示与隐藏,但是很尴尬,界面初始化结束后,DataTrigger没有触发,再此后切换Tab页,然后DataTrigger才可以正常被触发 解决方法这个问题以前并不存在,但是在我弄了一个数据缓冲区使得点击确定之后(没有保存),下次界面上显示的是上次确定的数据(底层的数据被没有被修改)之后,这个DataTrigger就有问题了,解决办法是写一个转换器直接绑定&lt;TabItem x:Name=&quot;Cutfilm_param_item&quot; Style=&quot;{DynamicResource VerticalTabItemStyle}&quot; Visibility=&quot;{Binding ElementName=EnableCutFilm,Path=IsChecked,Converter={StaticResource FilmCuttingConverter}}&quot;&gt; 123456789101112131415161718public class FilmCuttingConverter : IValueConverter &#123; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; if ((bool)value == true) return Visibility.Visible; else return Visibility.Collapsed; &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; if (Visibility.Visible == (Visibility)value) return true; else return false; &#125; &#125; 这样界面初始化结束,就会根据从下面读到的状态直接控制TabItem的显示隐藏,不会出现不触发的情况","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"WPF绘制坐标系,实现折线编辑","slug":"WPF-CoordinateSystem","date":"2020-06-29T16:00:00.000Z","updated":"2020-06-30T01:30:44.000Z","comments":true,"path":"2020/06/30/WPF-CoordinateSystem/","link":"","permalink":"https://www.lubaobao.xyz/2020/06/30/WPF-CoordinateSystem/","excerpt":"三个月之前做的一个控件,功能是实现曲线编辑(折线,光滑未实现),因为开发经验不足并且那个控件的位置大小几乎都是确定的,所以当时没考虑到移到别的地方,很多地方都是写死的,后期修改工作量太大…所以现在将其修改为大小可变的坐标系…","text":"三个月之前做的一个控件,功能是实现曲线编辑(折线,光滑未实现),因为开发经验不足并且那个控件的位置大小几乎都是确定的,所以当时没考虑到移到别的地方,很多地方都是写死的,后期修改工作量太大…所以现在将其修改为大小可变的坐标系… 绘制坐标轴和刻度WPF的坐标系是从左上角为原点,向右的方向为x轴,向下的方向为y轴,所以使用canvas容器布局需要进行旋转,将坐标系旋转为正常的笛卡尔坐标系…因为要动态的修改大小,所以刻度和刻度线就不可以都画在xaml里… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/// &lt;summary&gt;/// 绘制坐标轴和刻度/// &lt;/summary&gt;private void DrawAxisAndText()&#123; for (int i = 0; i &lt; 10; ++i) &#123; //左右两条线xaml里面画 if (i != 0 || i != 9) &#123; //坐标线 Line lineX = new Line() &#123; Stroke = new SolidColorBrush(Colors.White), StrokeDashArray = new DoubleCollection(6), StrokeThickness = 1, &#125;; Canvas.SetZIndex(lineX, 0); Line lineY = new Line() &#123; Stroke = new SolidColorBrush(Colors.White), StrokeDashArray = new DoubleCollection(6), StrokeThickness = 1, &#125;; Canvas.SetZIndex(lineY, 0); lineX.X1 = (double)((decimal)CanvasInPath.Width / 10) * i; lineX.X2 = (double)((decimal)CanvasInPath.Width / 10) * i; lineX.Y1 = 0; lineX.Y2 = CanvasInPath.Height; lineY.X1 = 0; lineY.X2 = CanvasInPath.Width; lineY.Y1 = (double)((decimal)CanvasInPath.Height / 10) * i; lineY.Y2 = (double)((decimal)CanvasInPath.Height / 10) * i; CanvasInPath.Children.Add(lineX); CanvasInPath.Children.Add(lineY); &#125; //刻度 if (i &lt; 9) &#123; TextBlock xblock = new TextBlock(); xblock.Foreground = new SolidColorBrush(Colors.White); xblock.FontSize = 10; TranslateTransform translateTransform = new TranslateTransform(0, xblock.ActualHeight); ScaleTransform scaleTransform = new ScaleTransform(); scaleTransform.ScaleY = -1; TransformGroup transformGroup = new TransformGroup(); transformGroup.Children.Add(translateTransform); transformGroup.Children.Add(scaleTransform); xblock.RenderTransform = transformGroup; xblock.Text = (i + 1) * 10 + \"%\"; Canvas.SetLeft(xblock, TransFromX((i + 1) * 10)); Canvas.SetTop(xblock, 15); CanvasInPath.Children.Add(xblock); Canvas.SetZIndex(xblock, 1); TextBlock yblock = new TextBlock(); yblock.Foreground = new SolidColorBrush(Colors.White); yblock.FontSize = 10; translateTransform = new TranslateTransform(0, yblock.ActualHeight); scaleTransform = new ScaleTransform(); scaleTransform.ScaleY = -1; transformGroup = new TransformGroup(); transformGroup.Children.Add(translateTransform); transformGroup.Children.Add(scaleTransform); yblock.RenderTransform = transformGroup; yblock.Text = (i + 1) * 10 + \"%\"; Canvas.SetLeft(yblock, 5); Canvas.SetTop(yblock, TransFromY((i + 1.5) * 10)); CanvasInPath.Children.Add(yblock); Canvas.SetZIndex(yblock, 1); &#125; &#125;&#125; 把整个画布的宽和高分成十份,均匀的画线,然后在线的中间画上刻度… 效果图 坐标转换输入小球对应的刻度,转换为canvas容器里对应的坐标,也就是leftproperty和topproperty,另外left和top属性设置的位置是小球的左下角,想设置为小球正中心需要减去小球的长度的1/2 12345678910111213/// &lt;summary&gt;/// 转换Canvas坐标/// &lt;/summary&gt;/// &lt;param value=\"坐标轴的刻度\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private double TransFromX(double value)&#123; return (double)(((decimal)value / 10) * (decimal)(CanvasInPath.Width) / 10 - (decimal)XOffset);&#125;private double TransFromY(double value)&#123; return (double)(((decimal)value / 10) * (decimal)(CanvasInPath.Height) / 10 - (decimal)YOffset);&#125; 如果需要DataGrid实时显示小球的位置,需要将小球的对应的刻度更新到ViewModel,所以还需要根据小球对象获取小球对应的刻度 1234567891011/// &lt;summary&gt;/// 获取小球的坐标轴刻度/// &lt;/summary&gt;/// &lt;param dot=\"小球对象\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private double[] GetValueOfAxis(Ellipse dot)&#123; double x1 = (double)((decimal)(Canvas.GetLeft(dot) + XOffset) / (decimal)(CanvasInPath.Width / 100)); double y1 = (double)((decimal)(Canvas.GetTop(dot) + YOffset) / (decimal)(CanvasInPath.Height / 100)); return new double[2] &#123; x1, y1 &#125;;&#125; 根据上面的方法,封装一个设置小球位置的函数,这里小球我直接用的Ellipse,正确做法应该是做成一个单独的控件,以后要想改小球的大小和颜色只需要改动小球控件 12345678910111213/// &lt;summary&gt;/// 设置点的位置/// &lt;/summary&gt;/// &lt;param dot=\"小球对象\"&gt;&lt;/param&gt;/// &lt;param x=\"x轴刻度\"&gt;&lt;/param&gt;/// &lt;param y=\"y轴刻度\"&gt;&lt;/param&gt;private void SetDotPosition(Ellipse dot, double x, double y)&#123; double xpoint = TransFromX(x); double ypoint = TransFromY(y); Canvas.SetLeft(dot, xpoint); Canvas.SetTop(dot, ypoint);&#125; 然后加上小球的拖动,更新线段的位置,就实现了小球在坐标系里的移动,然后实现窗口大小改变,坐标轴更新,小球位置更新,线段更新即可 改变窗口大小①保存改变之前小球对应的刻度(位置)②canvas内所有元素移除③canvas的大小根据改变后的窗口大小重新赋值,坐标轴最大值也根据窗口大小赋值④canvas加入小球和线段⑤画坐标系,根据保存的刻度设置小球位置,更新线段 1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 尺寸改变,重绘/// &lt;/summary&gt;private void Window_SizeChanged(object sender, SizeChangedEventArgs e)&#123; if (this.Width != 500 || this.Height != 600) &#123; double[] dot1value = GetValueOfAxis(DutyCycleCurveDot1); double[] dot2value = GetValueOfAxis(DutyCycleCurveDot2); CanvasInPath.Children.Clear(); CanvasInPath.Height = this.ActualHeight - 100; CanvasInPath.Width = this.ActualWidth; MaxCoordinateAxisX = this.ActualWidth; MaxCoordinateAxisY = this.ActualHeight - 100; CanvasInPath.Children.Add(DutyCycleCurveDot1); CanvasInPath.Children.Add(DutyCycleCurveDot2); CanvasInPath.Children.Add(DutyCycleLineList[0]); CanvasInPath.Children.Add(DutyCycleLineList[1]); CanvasInPath.Children.Add(DutyCycleLineList[2]); DrawAxisAndText(); SetDotPosition(DutyCycleCurveDot1, dot1value[0], dot1value[1]); SetDotPosition(DutyCycleCurveDot2, dot2value[0], dot2value[1]); UpdateLineAndDot(DutyCycleDotList, DutyCycleLineList); &#125;&#125; 效果演示","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"C#三维坐标转换为二维坐标","slug":"CSharp-translate","date":"2020-03-09T16:00:00.000Z","updated":"2020-06-22T12:54:32.000Z","comments":true,"path":"2020/03/10/CSharp-translate/","link":"","permalink":"https://www.lubaobao.xyz/2020/03/10/CSharp-translate/","excerpt":"刚开始学习图形跟随模块的时候,观察不仔细,只想着平面实现,导致以后的实现越来越困难,代码量越来越多,其实本来不需要那么麻烦,输入的都是三维的坐标,呈现上界面上的才是二维坐标…","text":"刚开始学习图形跟随模块的时候,观察不仔细,只想着平面实现,导致以后的实现越来越困难,代码量越来越多,其实本来不需要那么麻烦,输入的都是三维的坐标,呈现上界面上的才是二维坐标… 三维坐标转换为二维坐标矩阵变换什么的最烦了…我先写下来以防以后忘记… 123456mixtrl是一个矩阵[1 0 0 0 1 0 0 0 1]下面这个函数是我用来画三维坐标系的 1234567891011121314151617181920public POINT2D Transform3DTo2D(POINT3D pt3d)&#123; POINT2D result = new POINT2D(); double x = pt3d.x; double y = pt3d.y; double z = pt3d.z; double xTOx = (mixtrl[0] * x + mixtrl[1] * y + mixtrl[2] * z) * needXReverxe; double yTox = (mixtrl[3] * x + mixtrl[4] * y + mixtrl[5] * z) * needYReverxe; double zTox = (mixtrl[6] * x + mixtrl[7] * y + mixtrl[8] * z) * needZReverxe; double xx = -1 * Math.Cos(150 * 0.017453) * xTOx - Math.Cos(150 * 0.017453) * yTox; double yy = Math.Sin(150 * 0.017453) * xTOx - Math.Sin(150 * 0.017453) * yTox - zTox; result.x = orginPoint.X + xx; result.y = orginPoint.Y + yy; return result;&#125; 三维坐标(或二维坐标)的旋转以某个轴为旋转轴,实际上,只在垂直于坐标轴的平面做二维旋转 二维12x &#x3D; xcosα - ysinαy &#x3D; xsinα + ycosα 三维1234567891011121314绕x轴旋转x1 &#x3D; x;y1 &#x3D; ycosα - zsinα;z1 &#x3D; zcosα + ysinα;绕y轴旋转x1 &#x3D; xcosα - zsinα;y1 &#x3D; y;z1 &#x3D; zcosα + xsinα;绕z轴旋转x1 &#x3D; xcosα - ysinα;y1 &#x3D; ycosα + xsinα;z1 &#x3D; z; 角度自己设定,我自己设置每次转20° C#中的三角函数计算传入的参数为弧度… 1234567891011121314151617181920212223242526272829303132333435363738394041424344public POINT3D TransRoll(POINT3D pt3d,int RollFlag,double angle)&#123; POINT3D result = new POINT3D(); double x = pt3d.x; double y = pt3d.y; double z = pt3d.z; double cos = Math.Cos(angle * (Math.PI / 180)); double sin = Math.Sin(angle * (Math.PI / 180)); //绕x轴 if (RollFlag == 0) &#123; double x1 = x; double y1 = y * cos - z * sin; double z1 = z * cos + y * sin; result.x = x1; result.y = y1; result.z = z1; &#125; else if(RollFlag == 1) &#123; double x1 = x * cos - z * sin; double y1 = y; double z1 = z * cos + x * sin; result.x = x1; result.y = y1; result.z = z1; &#125; else &#123; double x1 = x * cos - y * sin; double y1 = y * cos + x * sin; double z1 = z; result.x = x1; result.y = y1; result.z = z1; &#125; return result;&#125; 绘制椎体一条由坐标原点到空间某点的线段，绕某个轴旋转一周，就形成了一个圆锥体 画圆同理，BresenHam画圆算法也可以 12345678910111213141516171819202122232425262728public void paintCone(POINT3D pt3d)&#123; POINT2D pt2d = new POINT2D(); Graphics graphics = this.CreateGraphics(); Pen pen = new Pen(Color.Yellow, 2); for (double i = 1; i &lt;= 360; ++i) &#123; pt2d = Transform3DTo2D(TransRoll(pt3d, 2, i)); graphics.DrawLine(pen, orginPoint, new Point((int)pt2d.x, (int)pt2d.y)); &#125; pen = new Pen(Color.Red, 2); POINT3D circlePT3D = new POINT3D(0, pt3d.y, pt3d.z); POINT2D circlePT2D = new POINT2D(); circlePT2D = Transform3DTo2D(circlePT3D); for (double i = 1; i &lt;= 360; ++i) &#123; pt2d = Transform3DTo2D(TransRoll(circlePT3D, 2, i)); graphics.DrawLine(pen, new Point((int)circlePT2D.x, (int)circlePT2D.y), new Point((int)pt2d.x, (int)pt2d.y)); &#125; graphics.Dispose();&#125; 最终效果x，y轴反向 绕z轴旋转20°和绕z轴旋转-20° 三角形绕z轴旋转z轴反向（带椎体）","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"C#聊天气泡框","slug":"CSarp-chatmessagebox","date":"2020-02-22T16:00:00.000Z","updated":"2020-07-22T02:56:42.000Z","comments":true,"path":"2020/02/23/CSarp-chatmessagebox/","link":"","permalink":"https://www.lubaobao.xyz/2020/02/23/CSarp-chatmessagebox/","excerpt":"气泡虽然是用的别人写好的方法,自己做的东西很少,大多是学习但是完成了学习编程以来一直的梦想,做一个好看点的聊天界面…","text":"气泡虽然是用的别人写好的方法,自己做的东西很少,大多是学习但是完成了学习编程以来一直的梦想,做一个好看点的聊天界面… 思路：借鉴自C# winform socket 初学者示例大佬的示例下载链接: https://pan.baidu.com/s/1i6r0Sa1JNp0-BCMEX1L6Hw 提取码:v751 注释及说明:https://www.cnblogs.com/qiaoke/p/6358050.html 界面组成：头像+气泡头像使用PictureBox，绘制成圆形图片气泡使用圆角矩形+尖角，创建panel使用bitemap填充 最终效果： 界面布局：panel+pictureBox 主要方法:绘制圆角矩形和圆图片:(学习自上面示例)12345678910111213141516171819202122232425262728public static GraphicsPath DrawRoundRect(int x, int y, int width, int height, int radius)&#123; //四边圆角 GraphicsPath gp = new GraphicsPath(); gp.AddArc(x, y, radius, radius, 180, 90); gp.AddArc(width - radius, y, radius, radius, 270, 90); gp.AddArc(width - radius, height - radius, radius, radius, 0, 90); gp.AddArc(x, height - radius, radius, radius, 90, 90); gp.CloseAllFigures(); return gp;&#125; //绘制圆图片private Image CutEllipse(Image img, Rectangle rec, Size size)&#123; Bitmap bitmap = new Bitmap(size.Width, size.Height); using (Graphics g = Graphics.FromImage(bitmap)) &#123; using (TextureBrush br = new TextureBrush(img, System.Drawing.Drawing2D.WrapMode.Clamp, rec)) &#123; br.ScaleTransform(bitmap.Width / (float)rec.Width, bitmap.Height / (float)rec.Height); g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias; g.FillEllipse(br, new Rectangle(Point.Empty, size)); &#125; &#125; return bitmap;&#125; 搜索框界面思路:窗体的resize属性修改窗体大小根据目前的窗体大小调整 窗体大小先设置为不可更改,以后在完善 12345678910111213141516171819202122232425262728private void button2_Click(object sender, EventArgs e) &#123; if(Form1.form1.Size.Width == 654) &#123; Form1.form1.Size = new System.Drawing.Size(954, 558); Form1.form1.REDI_HISTORY.Visible = true; Form1.form1.LAB_SEARCH.Visible = true; Form1.form1.EDI_SEARCH.Visible = true; Form1.form1.BTN_SEARCH.Visible = true; Form1.form1.EDI_SEARCH.Focus(); //显示在最下方 Form1.form1.REDI_HISTORY.Select(Form1.form1.REDI_HISTORY.TextLength, 0); Form1.form1.REDI_HISTORY.ScrollToCaret(); &#125; else &#123; Form1.form1.REDI_HISTORY.Visible = false; Form1.form1.LAB_SEARCH.Visible = false; Form1.form1.EDI_SEARCH.Visible = false; Form1.form1.BTN_SEARCH.Visible = false; Form1.form1.Size = new System.Drawing.Size(654, 558); EDI_SEARCH.Clear(); Form1.form1.REDI_MESSAGE.Focus(); &#125; &#125; 搜索框界面布局: 搜索框最终效果:服务端使用mono放在Linux下文字搜索数字搜索 搜索框代码实现:倒排索引什么的不会弄,所以只能用正则将就一下了… 数字的搜素区别不大,只是正则表达式变一下“\\w{3}:\\d{4}/\\d{1,2}/\\d{1,2} \\d{1,2}:\\d{2}:\\d{2}” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152List&lt;string&gt; info = new List&lt;string&gt;(); //string pattern = @\"\\w&#123;0,&#125;[\" + searchInfo + @\"]&#123;\" + searchInfo.Length + @\"&#125;\\w&#123;0,&#125;\"; string pattern = @\"\\w&#123;0,&#125;\" + searchInfo + @\"\\w&#123;0,&#125;\"; foreach (Match each in Regex.Matches(history, pattern)) &#123; info.Add(each.Value); &#125; //获取索引 List&lt;int&gt; indexList = new List&lt;int&gt;(); for (int i=0;i&lt;info.Count;++i) &#123; indexList.Add(getIndex(info[i], history)); &#125; //获取用户名和时间信息 ArrayList nameAndTime = new ArrayList(); ArrayList tempList = new ArrayList(); for (int i = 0; i &lt; indexList.Count; ++i) &#123; if((int)indexList[i] == -1) &#123; continue; &#125; string temp = history.Substring(0, (int)indexList[i]); foreach (Match each in Regex.Matches(temp, @\"\\w&#123;3&#125;\\:\\d&#123;4&#125;\\/\\d&#123;1,2&#125;\\/\\d&#123;1,2&#125; \\d&#123;2&#125;\\:\\d&#123;2&#125;\\:\\d&#123;2&#125;\")) &#123; tempList.Add(each.Value); &#125; nameAndTime.Add(tempList[tempList.Count - 1]); tempList.Clear(); &#125; //刷新历史记录框 REDI_HISTORY.Clear(); for(int i=0;i&lt;info.Count;++i) &#123; REDI_HISTORY.AppendText(nameAndTime[i].ToString() + \"\\r\\n\"); REDI_HISTORY.AppendText(info[i] + \"\\r\\n\"); if (nameAndTime[i].ToString().Substring(0, 3) == user.username) &#123; chatm.changeColorHistory(nameAndTime[i].ToString(), Color.Green); &#125; else &#123; chatm.changeColorHistory(nameAndTime[i].ToString(), Color.Blue); &#125; chatm.changeColorHistory(searchInfo, Color.Red); &#125;","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"C#中调用C++dll","slug":"CSarp-interaction","date":"2019-12-19T16:00:00.000Z","updated":"2020-06-23T10:27:24.000Z","comments":true,"path":"2019/12/20/CSarp-interaction/","link":"","permalink":"https://www.lubaobao.xyz/2019/12/20/CSarp-interaction/","excerpt":"校招是肯定没戏了..19年是20界的校招…","text":"校招是肯定没戏了..19年是20界的校招… C#中调用C++dll C++代码 123456789101112131415161718192021222324252627282930313233343536#ifdef MATH_EXPORTS#define MATH_API __declspec(dllexport)#else#define MATH_API __declspec(dllimport)#endifextern \"C\"&#123; class MATH_API CMath &#123; public: CMath(void); int Math_Add(int a, int b) &#123; return a + b; &#125; int Math_Sub(int a, int b) &#123; return a - b; &#125; int Math_Col(int a, int b) &#123; return a * b; &#125; int Math_Dev(int a, int b) &#123; return a / b; &#125; &#125;;&#125;extern MATH_API int nMath;MATH_API int fnMath(void); C#代码 1234567891011121314151617181920212223242526272829303132333435363738using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Runtime.InteropServices;using System.Threading.Tasks;namespace test&#123; public class func &#123; [DllImport(@\"C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll\",EntryPoint=\"?Math_Add@CMath@@QAEHHH@Z\")] public static extern int Math_Add(int a,int b); [DllImport(@\"C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll\", EntryPoint = \"?Math_Sub@CMath@@QAEHHH@Z\")] public static extern int Math_Sub(int a, int b); [DllImport(@\"C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll\", EntryPoint = \"?Math_Col@CMath@@QAEHHH@Z\")] public static extern int Math_Col(int a, int b); [DllImport(@\"C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll\", EntryPoint = \"?Math_Dev@CMath@@QAEHHH@Z\")] public static extern int Math_Dev(int a, int b); &#125; class Program &#123; static void Main(string[] args) &#123; int a = func.Math_Add(5, 6); Console.WriteLine(a); a = func.Math_Sub(6, 5); Console.WriteLine(a); a = func.Math_Col(6, 5); Console.WriteLine(a); a = func.Math_Dev(12, 3); Console.WriteLine(a); &#125; &#125;&#125; 遇到的问题 dll引用添加不成功,报错如下：无法加载DLL”**.dll”:找不到指定的模块 建议使用vs 2013创建win32程序—&gt;下一步—&gt;dll,然后编辑,不要创建windows控制台程序然后修改配置类型为动态库,如果不成功,调到第三个问题 找不到程序入口点 使用dumpbin工具查看C++中函数编译之后的名称,C#中EntryPoint中填入 引用添加不成功 有效解决办法就是使用DllImport,不要添加引用了[DllImport(@”C:\\Users\\Austin_Yan\\Documents\\Visual Studio 2013\\Projects\\Math\\Debug\\Math.dll”,EntryPoint=”?Math_Add@CMath@@QAEHHH@Z”)]正常应该放在bin目录下,这里是错误的编码习惯,懒 很久没写了,偶尔来两篇吧,都懒得改颜色了,想想以前,唉","categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"}],"tags":[]},{"title":"【反思与总结】在线OJ中的不定长数组输入问题","slug":"OJ-Skill","date":"2019-10-18T16:00:00.000Z","updated":"2020-07-22T02:49:24.000Z","comments":true,"path":"2019/10/19/OJ-Skill/","link":"","permalink":"https://www.lubaobao.xyz/2019/10/19/OJ-Skill/","excerpt":"OJ练习题遇到的不定长数组输入问题…","text":"OJ练习题遇到的不定长数组输入问题… 按照正常套路出题的要求，应该是第一行输入一个正整数N，表示数组有几个数 第二行则是输入数组的数据 比如 41 2 3 4 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int N; while(cin&gt;&gt;N) &#123; vector&lt;int&gt; v(N); for(int i=0;i&lt;N;++i) &#123; cin&gt;&gt;v[i]; &#125; &#125; return 0;&#125; 有了那个N，可以初始化数组长度，也可以设置循环的次数，输入就变得很简单 但是，有些出题者不告诉那个N是多少，直接说输入两组数据，空格隔开 比如， 1 2 3 44 3 2 1 这种不定长的数组，数组长度取决于输入的数据有多少，所以不能自己设置（设置太多浪费空间，设置太少会越界），只能使用push_back，让编译器自动扩容 不告知数据有多少个带来的主要问题就是输入的循环如何结束，cin从流中提取数据会跳过空格，所以只要输入的最后一个字符不是空格，说明输入结束了 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; char c; int value1; int value2; while (cin &gt;&gt; value1) &#123; v1.push_back(value1); c = cin.get(); if (c != ' ') &#123; break; &#125; &#125; while (cin &gt;&gt; value2) &#123; v2.push_back(value2); c = cin.get(); if (c != ' ') &#123; break; &#125; &#125; return 0；&#125; 这样就可以达到空格间隔，回车结束的不定长数组输入 效果图：","categories":[{"name":"ReView","slug":"ReView","permalink":"https://www.lubaobao.xyz/categories/ReView/"}],"tags":[]},{"title":"【针对性复习】数据结构","slug":"DS-Review","date":"2019-09-04T16:00:00.000Z","updated":"2020-07-22T02:41:12.000Z","comments":true,"path":"2019/09/05/DS-Review/","link":"","permalink":"https://www.lubaobao.xyz/2019/09/05/DS-Review/","excerpt":"学完数据结构后的一个整体的复习…","text":"学完数据结构后的一个整体的复习… 二分查找123456789101112131415161718192021222324252627bool BinFind(int* array, int data, int size)&#123; int left = 0; int right = size - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (data&lt;array[mid]) &#123; right = mid - 1; &#125; else if (data&gt;array[mid]) &#123; left = mid + 1; &#125; else &#123; cout &lt;&lt; data &lt;&lt; \" 存在!\" &lt;&lt; endl; return true; &#125; &#125; cout &lt;&lt; data &lt;&lt; \" 不存在!\" &lt;&lt; endl; return false;&#125; 链表面试题前面已经写过博客了,这次是复习,多敲代码总没坏处 在带头节点的链表中头结点存放节点个数不合理，char的表示范围不够-128~127 面试题不特殊说明，就是不带头结点的单链表 不需要给出节点的定义 123456789101112131415161718192021//写一个尾插void PushBack(ListNode*&amp; pHead, int data)&#123; if (pHead == nullptr) &#123; pHead = new ListNode(data); &#125; else &#123; ListNode* pCur = pHead; while (pCur-&gt;pNext != nullptr) &#123; pCur = pCur-&gt;pNext; &#125; pCur-&gt;pNext = new ListNode(data); &#125;&#125; 1234567891011121314151617//写一个链表(不带环)逆置ListNode* reverseList(ListNode* pHead)&#123; ListNode* result = nullptr; ListNode* pCur = pHead; while (pCur != nullptr) &#123; ListNode* next = pCur-&gt;pNext; pCur-&gt;pNext = result; result = pCur; pCur = next; &#125; return result;&#125; 1234567891011121314151617181920//找链表的中间节点ListNode* FindMidNode(ListNode* pHead)&#123; if (pHead == nullptr) &#123; return nullptr; &#125; ListNode* pFast = pHead; ListNode* pSlow = pHead; while (pFast!= nullptr &amp;&amp; pFast-&gt;pNext != nullptr) &#123; pFast = pFast-&gt;pNext-&gt;pNext; pSlow = pSlow-&gt;pNext; &#125; return pSlow;&#125; 12345678910111213141516171819202122232425262728293031//找倒数第K个节点ListNode* FindLastKNode(ListNode* pHead,size_t k)&#123; if (pHead == nullptr) &#123; return nullptr; &#125; ListNode* pFast = pHead; ListNode* pSlow = pHead; while (k--) &#123; //K大于链表长度 if (pFast == nullptr) &#123; return nullptr; &#125; pFast = pFast-&gt;pNext; &#125; while (pFast != nullptr &amp;&amp; pFast-&gt;pNext != nullptr) &#123; pFast = pFast-&gt;pNext-&gt;pNext; pSlow = pSlow-&gt;pNext; &#125; return pSlow;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//合并两个有序链表ListNode* MergeList(ListNode* pHead1, ListNode* pHead2)&#123; if (pHead1 == nullptr) &#123; return pHead2; &#125; if (pHead2 == nullptr) &#123; return pHead1; &#125; ListNode* result = nullptr; ListNode* last = nullptr; ListNode* pCur1 = pHead1; ListNode* pCur2 = pHead2; while (pCur1 != nullptr &amp;&amp; pCur2 != nullptr) &#123; if (pCur1-&gt;_data &lt; pCur2-&gt;_data) &#123; if (result == nullptr) &#123; result = last = pCur1; &#125; else &#123; last-&gt;pNext = pCur1; last = pCur1; &#125; pCur1 = pCur1-&gt;pNext; &#125; else &#123; if (result == nullptr) &#123; result = last = pCur2; &#125; else &#123; last-&gt;pNext = pCur2; last = pCur2; &#125; pCur2 = pCur2-&gt;pNext; &#125; &#125; if (pCur1 != nullptr) &#123; last-&gt;pNext = pCur1; &#125; if (pCur2 != nullptr) &#123; last-&gt;pNext = pCur2; &#125; return result;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//找两个链表相交的节点(不带环) ListNode* getIntersectionNode(ListNode* pHead1, ListNode* pHead2) &#123; if (pHead1 == nullptr || pHead2 == nullptr) &#123; return nullptr; &#125; ListNode* pCur1 = pHead1; ListNode* pCur2 = pHead2; size_t size1 = 1; size_t size2 = 1; while (pCur1 != nullptr) &#123; size1++; pCur1 = pCur1-&gt;next; &#125; while (pCur2 != nullptr) &#123; size2++; pCur2 = pCur2-&gt;next; &#125; pCur1 = pHead1; pCur2 = pHead2; if (size1 &gt; size2) &#123; while (size1 &gt; size2) &#123; pCur1 = pCur1-&gt;next; size1--; &#125; &#125; else &#123; while (size2 &gt; size1) &#123; pCur2 = pCur2-&gt;next; size2--; &#125; &#125; while (pCur1 != nullptr &amp;&amp; pCur2 != nullptr) &#123; if (pCur1 == pCur2) &#123; return pCur1; &#125; pCur1 = pCur1-&gt;next; pCur2 = pCur2-&gt;next; &#125; return nullptr; &#125; 慢指针:L+X快指针:L+X+nr 2*(L+X)=L+X+nr L=nr-X,n=1,2,3… 复杂链表的复制 在每个节点后面插入值相同的新节点 给新节点的随机指针域赋值 p2放在p1的next,p2指向p1随机指针域的next p1放在p2的next,p2放在p1的next 把新链表拆分出去 p1-&gt;next指向p2-&gt;next p1放在p2,p2指向p1-&gt;next 顺序表和链表的区别 空间: 一段连续的空间 插入可能需要扩容 底层空间不连续(逻辑顺序通过指针连接顺序) 不需要扩容(New节点) 效率: 插入和删除效率低(需要搬移元素,O(N)) 插入和删除效率高(O(1)) 空间利用率: 一整块空间 小的节点 内存碎片,效率低,额外空间浪费(保存的有结构体) 应用场景: 插入和删除操作不多 插入和删除操作频繁 缓存利用率: 利用率高 利用率低 vector和list的区别 底层结构 动态顺序表,一段连续的空间 带头结点的双向循环链表 随机访问能力 支持,访问某个元素O(1) 不支持,访问某个元素O(N) 插入和删除 插入和删除需要搬移元素,时间复杂度O(N),可能还需要增容,开辟新空间,拷贝元素,释放旧空间 插入和删除方便,时间复杂度O(1) 空间利用率 底层是连续的空间,不容易造成内存碎片,空间利用率高,缓存利用率高 底层节点动态开辟,容易造成内存碎片,空间利用率低,缓存利用率低 迭代器 原生态指针 对原生态指针的封装 迭代器失效 插入时,要给所有的迭代器重新赋值(因为插入有可能会导致扩容),删除时,当前迭代器失效,需要重新赋值 插入时,不会导致迭代器失效,删除时,只会导致当前迭代器失效,其他迭代器不受影响 应用场景 需要高效存储,支持随机访问,不关心插入删除效率低 大量插入和删除操作,不关心随机访问 环形队列队满和队空 空链表: front==rear 标记 flag == 0 &amp;&amp; rear==front,队列空 flag == 1 &amp;&amp; rear==front,队列满 少存一个元素 (rear+1)%capacity==front,可能会越界 取模 rear%=capacity,效率不高 if(rear==capacity){rear=0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//队列模拟实现栈//最好按照模板来写template &lt;typename T&gt;class StackByQueue&#123;public: void push(const T&amp; data) &#123; if (q1.empty() == true) &#123; q2.push(data); &#125; else &#123; q1.push(data); &#125; &#125; void pop() &#123; while (q1.size() &gt; 1) &#123; q2.push(q1.front()); q1.pop(); &#125; q1.pop(); &#125; T&amp; top() &#123; if (q1.empty() == true) &#123; return q2.back(); &#125; else &#123; return q1.back(); &#125; &#125; bool empty() &#123; if (q1.empty() == true &amp;&amp; q2.empty() == true) &#123; return true; &#125; return false; &#125;private: queue&lt;T&gt; q1; queue&lt;T&gt; q2;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//写一个最小栈//1.使用两个栈//2.一次存两个值,一个正常插入的一个最小值#include&lt;stack&gt;class MinStack&#123;public: MinStack() &#123;&#125; //使用方法二，一次存入两个元素 void Push(int data) &#123; //插入数据到s中 if(s.empty()==true) &#123; s.push(data); s.push(data); &#125; else &#123; int a=s.top(); s.pop(); int Min=s.top(); if(data&lt;=Min) &#123; s.push(a); s.push(data); s.push(data); &#125; else &#123; s.push(a); s.push(Min); s.push(data); &#125; &#125; &#125; void Pop() &#123; s.pop(); s.pop(); &#125; int Top() &#123; return s.top(); &#125; int GetMin() &#123; int a=s.top(); s.pop(); int Min=s.top(); s.push(a); return Min; &#125; bool empty() &#123; if(s.empty()==true) &#123; return true; &#125; return false; &#125;private: stack&lt;int&gt; s;&#125;; 123//逆波兰表达式(Reverse Polish Notation)//(1+2)*(3+4)---&gt;12+34+* 二叉树 树相关的概念: 双亲:若一个节点含有子节点,则这个节点是这个子节点的双亲节点 高度:树中节点的最大层次 兄弟:有相同双亲节点的被称为兄弟节点 节点的度:结点子树的个数 叶子节点:度为0的节点被称为叶节点 表示方式: 孩子表示法 双亲表示法 孩子双亲表示法 孩子兄弟表示法 二叉树概念: 空树，根+根的左子树+根的右子树 特殊二叉树: 满二叉树:每一层节点都达到了最大值 完全二叉树:前N个节点与满二叉树的前N个节点分布形式完全相同 二叉树的五条性质: 1.若规定根节点的层次为1,则一颗非空二叉树的第i层最多有2^(i-1)个节点 2.若规定只有根节点的二叉树深度为1,则深度为k的二叉树最大节点数是2^k-1 3.对任意一颗二叉树,如果其叶节点个数为n0,度为2的非叶节点个数为n2,则有n0=n2+1 4.具有n个节点的完全二叉树的深度k为log2(n+1)向上取整 5.对于有n个节点的完全二叉树,如果按照从上至下从左至右的顺序对所有节点从0进行编号 则对于序号为i的节点有: &lt;1&gt;.若i&gt;0,双亲序号:(i-1)/2i=0,i为根节点编号,无双亲节点 &lt;2&gt;.若2i+1&lt;n,左孩子序号:2i+1,否则无左孩子 &lt;3&gt;.若2i+2&lt;n,右孩子序号:2i+2,否则无右孩子 一个完全二叉树1000个节点,____个叶子节点,____个非叶子节点,____个只有左孩子,____个只有右孩子 假设二叉树总共有N个节点,n0,n1,n2,N=n0+n1+n2 完全二叉树—&gt;n0+1+n2=1000—&gt;2*n2=998—&gt;n2=499—&gt;n0=500 1个只有左孩子,0个只有右孩子 二叉树的存储https://blog.csdn.net/Austin\\_Yan/article/details/97931649 顺序结构 堆,只适合完全二叉树,否则空间会大量浪费 向下调整 看是否调整到最后一个节点,while (child &lt; size) 优先找到左孩子 左右孩子中较小的(右孩子必须存在),用child标记 双亲与孩子交换,swap(C++标准库提供) parent放在child位置,child重新计算 如果随机数组一开始就不满足堆的性质,先找到倒数第一个非叶子节点 lastleaf = (size - 2) &gt;&gt; 1; 在处理上一个叶子节点,直到全处理完 向上调整(插入) 通过孩子找双亲,parent=(child-1)&gt;&gt;1 孩子如果比双亲小,交换位置swap(C++标准库提供) child放在parent位置,parent重新计算 看是否调整到第一个节点,while (child != 0) 堆的删除 把堆顶元素和最后一个元素互换 更新元素个数,size–; 使用向下调整 堆排 创建堆(向下调整),从倒数第一个叶子节点 首末元素交换,size– 重复过程 链式结构 获取树的高度 空树,返回0 只有根节点,返回1 返回根的左子树的高度+根的右子树高度 获取叶子节点的个数 空树,返回0 只有根节点,返回1 返回根的左子树叶子节点个数+根的右子树叶子节点个数 获取K层的节点数 如果空树,或者K=0,返回0 如果只有K=1,只有根节点,返回1 返回K-1的左子树作为根节点的节点个数+K-1的右子树作为根节点的节点个数 获取节点的双亲 树不存在,或者节点为根节点,返回nullptr 节点若是根节点左孩子或者右孩子,返回根节点 去根的左子树中查找,存在就返回,否则去根的右子树中查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344//写一个堆排(向下调整)template&lt;typename T,typename Compare&gt;void HeapAdjust(T* array, int size, int parent,Compare com)&#123; int child = parent * 2 + 1; while (child &lt; size) &#123; if (child + 1 &lt; size &amp;&amp; com(array[child + 1] , array[child])) child += 1; if (com(array[child] , array[parent])) &#123; swap(array[child], array[parent]); parent = child; child = parent * 2 + 1; &#125; else &#123; return; &#125; &#125;&#125;template&lt;typename T,typename Compare&gt;void HeapSort(T* array, int size,Copmare com)&#123; int root = ((size - 1 - 1) &gt;&gt; 1); for (root; root &gt;= 0; --root) &#123; HeapAdjust(array, size, root,com); &#125; int end = size - 1; while (end != 0) &#123; swap(array[0], array[end]); HeapAdjust(array, end, 0); end--; &#125;&#125; 二叉树的创建12345678910111213141516171819202122232425262728293031#include&lt;vector&gt;struct BTNode&#123; BTNode(int data):_data(data),_pLeft(nullptr),_pRight(nullptr) &#123; &#125; BTNode* _pLeft; BTNode* _pRight; int _data;&#125;;BTNode* CreateBinTree(vector&lt;int&gt; v,int&amp; index,int mark)&#123; if(index&gt;=v.size() || v[index]==mark) &#123; return nullptr; &#125; BTNode* pRoot=new BTNode(v[index]); index++; pRoot-&gt;_pLeft=CreateBinTree(v,index,mark); index++; pRoot-&gt;_pRight=CreateBinTree(v,index,mark); return pRoot;&#125; 非递归前、中、后序遍历 前序遍历 检测栈是否为空 获取栈顶元素,遍历 如果有左右子树,压栈先放入右子树,在放入左子树 中序遍历 找到根节点最左侧的待遍历节点 保存路径上所有节点 获取栈顶元素,遍历,pop出栈 把最左侧节点的右子树当成一棵单独的树处理 后序遍历 找到根节点最左侧的待遍历节点 保存路径上所有节点 获取栈顶元素,最左侧节点,如果其没有右孩子,或者右孩子被遍历过(判断ptop-&gt;right==prev),遍历此节点 如果有右孩子,pcur=ptop-&gt;right,循环继续 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stack&gt;void PreOrderNor(BTNode* pRoot)&#123; if(pRoot==nullptr) &#123; return; &#125; stack&lt;BTNode*&gt; s; s.push(pRoot); while(s.empty()!=true) &#123; BTNode* pCur=s.top(); cout&lt;&lt;pCur-&gt;_data&lt;&lt;\" \"; s.pop(); if(pCur-&gt;_pRight!=nullptr) &#123; s.push(pCur-&gt;_pRight); &#125; if(pCur-&gt;_pLeft!=nullptr) &#123; s.push(pCur-&gt;_pLeft); &#125; &#125; cout&lt;&lt;endl;&#125;void InorderNor(BTNode* pRoot)&#123; if(pRoot==nullptr) &#123; return; &#125; stack&lt;BTNode*&gt; s; BTNode* pCur=pRoot; while(s.empty()!=true || pCur!=nullptr) &#123; while(pCur!=nullptr) &#123; s.push(pCur); pCur=pCur-&gt;_pLeft; &#125; pCur=s.top(); cout&lt;&lt;pCur-&gt;_data&lt;&lt;\" \"; s.pop(); pCur=pCur-&gt;_pRight; &#125; cout&lt;&lt;endl;&#125;void PostOrderNor(BTNode* pRoot)&#123; if(pRoot==nullptr) &#123; return; &#125; stack&lt;BTNode*&gt; s; BTNode* pCur=pRoot; BTNode* pPrev=nullptr; while(s.empty()!=true || pCur!=nullptr) &#123; while(pCur!=nullptr) &#123; s.push(pCur); pCur=pCur-&gt;_pLeft; &#125; BTNode* pTop=s.top(); if(pTop-&gt;_pRight==nullptr || pTop-&gt;_pRight==pPrev) &#123; cout&lt;&lt;pTop-&gt;_data&lt;&lt;\" \"; pPrev=pTop; s.pop(); &#125; else &#123; pCur=pTop-&gt;_pRight; &#125; &#125; cout&lt;&lt;endl;&#125; 重建二叉树 从前序遍历结果拿到根节点 从中序遍历结果确认根的左右子树 建立区间,[left,Inindex),[Inindex+1,right) 前段区间递归建立左子树,后段区间递归建立右子树 递归前注意++index,根节点创建完之后索引朝后走 注意Inindex防止越界,if(left&lt;Inindex),if(Inindex+1&lt;right) 123456789101112131415161718192021222324252627BTNode* ReBuildBinTree(const vector&lt;int&gt;&amp; pre, const vector&lt;int&gt;&amp; in, int&amp; index, int left, int right)&#123; if (left &gt;= right) &#123; return nullptr; &#125; BTNode* pRoot = new BTNode(pre[index]); int Inindex = 0; while (in[Inindex] != pre[index]) &#123; Inindex++; &#125; if (left &lt; Inindex) &#123; pRoot-&gt;_pLeft = ReBuildBinTree(pre, in, ++index, left, Inindex); &#125; if (Inindex + 1 &lt; right) &#123; pRoot-&gt;_pRight = ReBuildBinTree(pre, in, ++index, Inindex + 1, right); &#125; return pRoot;&#125;","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"VSCodeRemote SSH公钥免密登录，远离xshell，摆脱vim","slug":"VSCode-remotessh","date":"2019-08-30T16:00:00.000Z","updated":"2020-06-24T09:30:25.000Z","comments":true,"path":"2019/08/31/VSCode-remotessh/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/31/VSCode-remotessh/","excerpt":"比起VIM的纯键盘操作,我更喜欢鼠标加键盘的操作方式…所以能想办法替代VIM就想办法替代..虽然我也不是服务器开发..","text":"比起VIM的纯键盘操作,我更喜欢鼠标加键盘的操作方式…所以能想办法替代VIM就想办法替代..虽然我也不是服务器开发.. 安装插件：微软的宇宙第一IDE让人使用之后欲罢不能，那么Linux编程有没有好用的IDE呢？ 最近VS Code出了一个插件，对我这种vim使用很不舒服的人来说简直是爱极了！~ 注意： 要想完全不使用xshell，vs code必须安装编译器 否则写完代码无法编译，毕竟vs code只是编辑器 要想让vs code的C/C++自动补全更加智能，需要安装llvm 但是，萝卜青菜，各有所爱，vs code对我而言只是一款编辑代码的工具，我不想为了编译代码再花更多时间，我只是不喜欢vim而已，xshell上使用gcc和g++那么方便为什么不呢？ 首先，搜索Remote SSH，安装然后左下角多了一个按钮 生成公钥：配置好之后，就可以连接服务器了，但是问题来了，每次都要输入两次密码很烦 所以我们使用ssh生成一份公钥，openssh组件是windows 1809之后的版本推出的 如果不想升级系统，也不想安装openssh，那么请往下看~ 使用过github的小伙伴看到下面这个东西是不是很亲切？ git 安装完后，bash 、 ssh 、 ssh-keygen 等一些常用的 linux 命令工具都已经安装 打开Git Bash Here进入命令行 切换到目录 cd C:/Users/你电脑的用户名/.ssh/ 生成密钥 ssh-keygen -t rsa -b 4096，回车表示存到当前文件夹 pub文件就是生成的公钥 到这个时候，就快要和vim说拜拜了~ 服务器操作：rz或者直接拖动，将公钥上传到服务器，然后cat显示在屏幕上，复制 然后在服务器键入如下命令：(来源于：https://blog.csdn.net/zhangpeterx/article/details/97375233） 123456789mkdir -p ~&#x2F;.ssh chmod 700 ~&#x2F;.ssh nano ~&#x2F;.ssh&#x2F;authorized_keys 在nano界面 ctrl+v，然后ctrl+x退出，回车表示不更改文件名chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys 可以把xshell关闭了，打开vs code，就会连接服务器，不需要手动输密码 效果截图：","categories":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.lubaobao.xyz/categories/VsCode/"}],"tags":[]},{"title":"【Linux小项目---1】jsonCpp库和数据库接口的使用","slug":"LinuxProject-1","date":"2019-08-28T16:00:00.000Z","updated":"2020-07-22T02:54:05.000Z","comments":true,"path":"2019/08/29/LinuxProject-1/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/29/LinuxProject-1/","excerpt":"学习Linux下的jsonCpp库和MySql数据库的接口的使用…","text":"学习Linux下的jsonCpp库和MySql数据库的接口的使用… Insert: selectAll: selectOne(1): Delete(6):","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lubaobao.xyz/categories/Linux/"}],"tags":[]},{"title":"【C++小项目---6】庄周:啦啦啦啦啦~","slug":"C++Project-6","date":"2019-08-21T16:00:00.000Z","updated":"2020-07-22T02:56:29.000Z","comments":true,"path":"2019/08/22/C++Project-6/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/22/C++Project-6/","excerpt":"对于程序的逻辑进行完善…","text":"对于程序的逻辑进行完善… 完善登陆界面逻辑:我发现,在用户不输入用户名和密码的情况下,依次弹窗提醒,但是提醒结束之后,程序还是往下执行了,导致登陆界面隐藏了,这与正常情况不符,正常的应该是弹窗完登陆按钮响应完毕,等待用户继续输入 完善售货员界面OK按钮的逻辑:购买商品的数量大于库存,应该提示购买失败,清空输入的商品数量编辑框,保留查询的商品名称和库存数量,同时应该把商品的库存正确数量再次显示,避免用户再次点击查询才能看到正确的库存数量 库存为2,但是购买数量为3,虽然现实中不可能存在,但是软件中一切皆有可能 重新显示库存数量,并且商品数量编辑框置零 这里直接调用SelectGood方法的前提是输入的商品名称不清空 完善售货员界面+ -按钮的逻辑:商品数量为0时,不可以-号操作,弹窗提示,置零商品数量编辑框 商品数量大于等于1的时候,-号按钮才可以操作,否则报错 庄周表示,未完待续!~","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]},{"title":"【针对性复习】选择排序和归并排序","slug":"Cpp-sort1","date":"2019-08-14T16:00:00.000Z","updated":"2020-06-24T09:30:18.000Z","comments":true,"path":"2019/08/15/Cpp-sort1/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/15/Cpp-sort1/","excerpt":"之前相关内容的博客,只有简略的思路和代码,起不到复习的作用…现在把思路整理清楚,过程图示也画出来,再把代码重新写一遍,争取把排序遗留的问题彻底解决…","text":"之前相关内容的博客,只有简略的思路和代码,起不到复习的作用…现在把思路整理清楚,过程图示也画出来,再把代码重新写一遍,争取把排序遗留的问题彻底解决… 选择排序的思路:从头到尾遍历,找最大的元素的下标,找到之后把最大的元素和最后一个位置的元素交换 易错点: max作为保存最大元素下标的存在,每次使用完应该清零 找到值去交换,最大的元素位置是没有发生变化的 过程图示: 代码示例:1234567891011121314151617181920212223//普通的未经过优化的选择排序void selectSort(int* array, int size)&#123; int end = size - 1; while (end != 0) &#123; int max = 0; int begin =0; for (begin; begin &lt;= end; ++begin) &#123; if (array[max] &lt; array[begin]) &#123; max = begin; &#125; continue; &#125; swap(array[max], array[end]); end--; &#125;&#125; 优化后的选择排序:将一次选择一个最大值变为一次选择一个最大值和最小值 最大值放在最后面的end位置,最小值放在最前面的begin位置 普通选择排序缺陷: 存在大量的重复比较 易错点: index的值每次遍历查找前要重置 minpos和maxpos使用完之后的值也要重置 过程图示: 代码示例:1234567891011121314151617181920212223242526272829303132333435363738void selectSortD(int* array, int size)&#123; int begin = 0; int end = size - 1; while (begin &lt; end) &#123; int index = begin + 1; int minpos = begin; int maxpos = begin; for (index; index &lt;= end; ++index) &#123; if (array[index]&gt;array[maxpos]) &#123; maxpos = index; &#125; if (array[index] &lt; array[minpos]) &#123; minpos = index; &#125; &#125; //如果minpos在最后的位置,把minpos的位置与maxpos互换即可 if (minpos == end) &#123; minpos = maxpos; &#125; swap(array[begin], array[minpos]); swap(array[end], array[maxpos]); begin++; end--; &#125;&#125; 归并排序(递归)的思路:对一组数据,一直均分到一组只有一个元素,然后将其归并,逐步变为有序 易错点: 只有元素有序才可以归并 begin2是以mid开始,如果以mid+1开始,会越界 先处理左半部分,在处理右半部分,都有序之后,归并,写回原数组 归并的时候申请辅助空间如果是在函数里,函数调用结束会释放,所以使用参数传递进去 空间只需要一份,所以不能当作mergeData的参数,因为递归进来每次都会创建 归并数据过程图示:长短不一时,一方写完,另一方还未完,直接把另一方直接写入到后面 归并数据思路: 使用两个指针来依次对比左半部分和右半部分的第一个元素,先把小的放进去 放进去的那部分指针后移,继续比较,一直比到放完为止,长度不一致的情况循环结束单独处理 1234567891011121314151617181920212223242526272829303132333435363738394041void mergeData(int* array,int left,int mid,int right,int* tmp)&#123; int begin1 = left; int end1 = mid; int begin2 = mid; int end2 = right; int index = left; while (begin1 &lt; end1 &amp;&amp; begin2&lt;end2) &#123; if (array[begin1] &lt; array[begin2]) &#123; tmp[index] = array[begin1]; begin1++; index++; &#125; else &#123; tmp[index] = array[begin2]; begin2++; index++; &#125; &#125; //处理长度不一致的情况 while (begin1 &lt; end1) &#123; tmp[index] = array[begin1]; begin1++; index++; &#125; while (begin2&lt;end2) &#123; tmp[index] = array[begin2]; begin2++; index++; &#125;&#125; 为了方便调用,进行一下封装,其实不封装也无所谓,那时候还没学C++所以用malloc,现在自然用new 12345678void mergeSort(int* array, int size)&#123; int* tmp = new int[size]; _mergeSort(array, 0, size, tmp); delete[] tmp;&#125; 说真的,我不是很喜欢递归的归并排序代码,我觉得memcpy那里需要加left真的很难理解 123456789101112131415void _mergeSort(int* array, int left, int right,int* tmp)&#123; if (right - left &gt; 1) &#123; int mid = left + ((right - left) &gt;&gt; 1); _mergeSort(array, left, mid, tmp); _mergeSort(array, mid, right, tmp); mergeData(array, left, mid, right, tmp); memcpy(array + left, tmp + left, sizeof(int)*(right - left)); &#125;&#125; 不加left每次拷贝都会拷贝到左半部分,右半部分永远是空的 0-5这一整体,分组0-1 2-5,处理右边的部分的时候left是2,如果处理完了往回拷贝的时候不加left array默认指向数组第一个元素,等于2-5这边的数据没有接在前两个元素后面,而是有两个把之前的左半部分覆盖了 归并排序(递归)过程图示:其实应该34一组,291一组,但是看思路就行了,这里画的严格按照代码来说是有问题的 归并排序(循环)的思路:与递归不同的是,循环不需要先分组了,因为每个元素都是单独的,可以看作已经分好组了,直接开始归并 易错点: 需要在循环里手动赋予left的值 i应该+=2*gap gap可以看作一组元素的个数,所以left,mid,right的值用gap表示 mid和right有可能会超出size的范围造成越界,需要单独处理 归并排序(循环)过程图示: 归并排序(循环)代码:12345678910111213141516171819202122232425262728293031323334void mergeSortN(int* array, int size)&#123; int* tmp = new int[size]; int gap = 1; while (gap &lt; size) &#123; for (int i = 0; i &lt; size; i += 2 * gap) &#123; int left = i; int mid = left + gap; int right = mid + gap; if (mid &gt; size) &#123; mid = size; &#125; if (right &gt; size) &#123; right = size; &#125; mergeData(array, left, mid, right, tmp); &#125; memcpy(array, tmp, sizeof(int)*size); gap *= 2; &#125; delete[] tmp;&#125; 至此,排序所有的内容基本都搞清楚了,短时间也不太可能会忘,忘了再过来看看就行了,开始新的篇章~","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]},{"title":"【C++小项目---3】连接数据库检测用户名密码、实现登录","slug":"C++Project-3","date":"2019-08-08T16:00:00.000Z","updated":"2020-07-22T02:56:23.000Z","comments":true,"path":"2019/08/09/C++Project-3/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/09/C++Project-3/","excerpt":"C++小项目学习数据库读取密码和实现登录窗口（学习多窗口的创建）…","text":"C++小项目学习数据库读取密码和实现登录窗口（学习多窗口的创建）… 数据库中插入信息： 实现检测功能：利用DuiLib库中的方法,拿到编辑框中的用户名和密码,想办法转为string类型 CDuistring类方法中GetData()可以将Cduistring类型转为LPCTSTR 再写一个转换函数,将为string类型,函数我不会写,我是百度查的,代码如下: 1234567891011121314151617std::string StringFromLPCTSTR(LPCTSTR str) &#123;#ifdef _UNICODE int size_str = WideCharToMultiByte(CP_UTF8, 0, str, -1, 0, 0, NULL, NULL); char* point_new_array = new char[size_str]; WideCharToMultiByte(CP_UTF8, 0, str, -1, point_new_array, size_str, NULL, NULL); std::string return_string(point_new_array); delete[] point_new_array; point_new_array = NULL; return return_string;#else return std::string(str);#endif&#125; 然后连接数据库,拿到用户名和密码,使用mysql_query在数据库中查询 MYSQL_RES* result = mysql_store_result(_mySql); 保存结果集,在判断是否在数据库中能查到用户名和对应的密码 12345if(mysql_num_rows(result))&#123; return true;&#125;return false; 代码运行测试图：输入用户名123，密码123，登录失败输入用户名1,密码123登陆成功:","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]},{"title":"【C++小项目---2】C++连接MySQL数据库、DuLib绘制登录界面","slug":"C++Project-2","date":"2019-08-06T16:00:00.000Z","updated":"2020-07-22T02:56:18.000Z","comments":true,"path":"2019/08/07/C++Project-2/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/07/C++Project-2/","excerpt":"C++小项目的数据库的连接（本地）学习，学习界面的绘制…","text":"C++小项目的数据库的连接（本地）学习，学习界面的绘制… 连接MySQL数据库：将常用的操作封装起来,方便调用 环境:VS 2013 数据库版本8.0.7,使用C++接口 MySQL.h 1234567891011121314151617181920212223242526272829#pragma once#include &lt;iostream&gt;#include&lt;WinSock2.h&gt;#include&lt;mysql.h&gt;#include&lt;vector&gt;using namespace std;class MySQL&#123;public: MySQL(); bool ConnectMysql(const char* host, const char* user, const char* password, const char* dbname); ~MySQL(); vector&lt;string&gt; Select(const string&amp; strSQL); bool Insert(const string&amp; strSQL); bool Delete(const string&amp; strSQL); bool UpDate(const string&amp; strSQL);private: MYSQL* _mySql;&#125;; MySQL.cpp Select写的目前还存在问题,日后修改 Insert目前没测,但想必也不可能是对的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include\"MySQL.h\"#include&lt;string&gt;using namespace std;MySQL::MySQL()&#123; _mySql = mysql_init(nullptr); //设置数据库编码方式 mysql_options(_mySql, MYSQL_SET_CHARSET_NAME, \"gbk\");&#125;MySQL::~MySQL()&#123; mysql_close(_mySql);&#125;bool MySQL::ConnectMysql(const char* host, const char* user, const char* password, const char* dbname)&#123; if (mysql_real_connect(_mySql, host, user, password, dbname, 3306, nullptr, 0) == nullptr) &#123; cout &lt;&lt; \"数据库连接失败!\" &lt;&lt; endl; return false; &#125; return true;&#125;vector&lt;string&gt; MySQL::Select(const string&amp; strSQL)&#123; vector&lt;string&gt; vRet; if (mysql_query(_mySql, strSQL.c_str())) &#123; cout &lt;&lt; mysql_error(_mySql) &lt;&lt; endl; return vRet; &#125; //获取查询的记录集 MYSQL_RES* mySQLRES = mysql_store_result(_mySql); if (mySQLRES == nullptr) &#123; cout &lt;&lt; mysql_error(_mySql) &lt;&lt; endl; return vRet; &#125; //获取字段 int itemCount = mysql_num_fields(mySQLRES); MYSQL_ROW mySQLROW; while (mySQLROW = mysql_fetch_row(mySQLRES)) &#123; for (size_t i = 0; i &lt; itemCount; ++i) &#123; //vRet.push_back(mySQLROW[i]); cout &lt;&lt; mySQLROW[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; mysql_free_result(mySQLRES); return vRet;&#125;bool MySQL::Insert(const string&amp; strSQL)&#123; if (mysql_query(_mySql, strSQL.c_str())) &#123; cout &lt;&lt; mysql_error(_mySql) &lt;&lt; endl; return false; &#125; return true;&#125;//bool MySQL::Delete(const string&amp; strSQL)//&#123;////&#125;//bool MySQL::UpDate(const string&amp; strSQL)//&#123;////&#125; Main.cpp 1234567891011121314151617#include&lt;iostream&gt;#include \"MySQL.h\"using namespace std;int main()&#123; MySQL mysql; mysql.ConnectMysql(\"localhost\", \"root\", \"123123\", \"supmarket\"); mysql.Select(\"select * from employee;\"); system(\"pause\"); return 0;&#125; 代码运行测试图: 绘制登录界面：注意水平布局和垂直布局的层次关系，不然会出现编辑框无法鼠标选中等问题 而且，使用中文的最小化和关闭好low的感觉，等找到素材之后把它换掉 消息响应：登录窗口只有三个按钮，分别是最小化，关闭以及登录 最小化调用win32的函数::SendMessage完成，要加作用域限定符 关闭直接调用Close函数完成 登录的话，触发响应调用Login函数，**Login函数的主要功能是判断用户输入是否合** 法，以及登录成功后隐藏登录界面创建主界面 12345678910111213141516171819void LoginWind::Notify(TNotifyUI&amp; msg)&#123; if (msg.sType == _T(\"click\")) &#123; if (msg.pSender-&gt;GetName() == _T(\"btnClose\")) &#123; Close(); &#125; else if (msg.pSender-&gt;GetName() == _T(\"btnMin\")) &#123; //MessageBox(NULL, _T(\"最小化\"), _T(\"提示信息\"), IDOK); ::SendMessage(m_hWnd,WM_SYSCOMMAND,SC_MINIMIZE,0); &#125; else if (msg.pSender-&gt;GetName() == _T(\"btnLogin\")) &#123; LoginWind::Login(); &#125; &#125;&#125; 代码运行测试图:虽说丑到极致,弱到爆炸…但是毕竟也是人生中第一个界面程序,总算脱离控制台了… 更换图标:用户名和密码来自QQ登陆界面,最小化和关闭来自QQ聊天窗口,选中后图标颜色变化也来自聊天窗口 目前标题栏还是无法拖动…有待解决… 修改window属性:通过修改caption和sizebox两项属性可以解决标题栏无法拖动的问题,也可以使得窗口大小可以调整 千万不要手动往xml文件里写入,否则你的图片会全部失效 未完待续~","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]},{"title":"【C++小项目---1】windows版本MySQL安装、DuiLib界面库编译及配置","slug":"C++Project-1","date":"2019-08-05T16:00:00.000Z","updated":"2020-07-22T02:56:08.000Z","comments":true,"path":"2019/08/06/C++Project-1/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/06/C++Project-1/","excerpt":"C++的小项目的前期环境搭建和准备工作…","text":"C++的小项目的前期环境搭建和准备工作… 下载MySQL：下载传送门：MySQL8.07版本 也可以去百度搜索5.7版本，反正结果都是一样的 安装MySQL：推荐使用用户自定义安装，开发者选项仅适合网络速度良好的小伙伴，下载实在太慢了… 之后的选择产品界面，选择MySQL SERVER8.0.7，添加到右边 剩下的就是一路下一步，保持默认，直到安装结束 使用方法：8.07版本的MySQL自带客户端工具 如果其他版本，或者因为意外什么的导致没有这个东西，也可以使用cmd命令行操作 先使用命令进入MySQL安装的文件夹下的bin目录，才可以使用mysql的命令进入数据库 在这里输入mysql的命令就可以识别了，登录成功如下图： 编译DuiLib：找到文件夹中的DuiLib文件，类型为sln，双击打开，如果是2013的编译器直接点迁移项目即可 中途遇到已存在需要覆盖的直接点确定 项目加载完毕之后，不需要其他操作，直接点击：项目—&gt;批生成—&gt;全选—&gt;生成 全部重新生成成功之后，原来的文件夹会多出一个lib文件夹，用于存放静态库文件 同时，bin文件夹下也会生成dll动态库文件 至此，所有需要的东西应该是一个都不少了 环境配置：这个就不用多说了，无论是官方github还是百度上都太多了，直接贴图，照着操作就可以了 测试DuiLib：从网上找一段代码，测试是否可以生成界面，本质还是win32的，DuiLib只是进行封装操作 代码来源： https://www.cnblogs.com/Alberl/p/3343579.html 如果遇到dll文件找不到的，把bin生成的dll文件拷贝到工程的Debug目录下 不是里层的Debug目录 ，是有着exe程序的那个ok，到这里，借鉴着前人经验，总算是把环境弄好了，可以进行自己的小程序的界面开发了…","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]},{"title":"【针对性复习】选择排序和归并排序","slug":"Cpp-sort0","date":"2019-08-02T16:00:00.000Z","updated":"2020-06-24T09:33:13.000Z","comments":true,"path":"2019/08/03/Cpp-sort0/","link":"","permalink":"https://www.lubaobao.xyz/2019/08/03/Cpp-sort0/","excerpt":"针对选择题中排序过程的复习","text":"针对选择题中排序过程的复习 快排递归框架：123456789void QuickDSort(int* array, int left, int right)&#123; if (right - left &gt; 1) &#123; int div = partion(array, left, right); QuickDSort(array, left, div); QuickDSort(array, div + 1, right); &#125;&#125; 划分区间:先想办法拿到一个基准值,进而才可以划分,但是直接把right-1的位置的元素作为基准值有可能极端情况下性能爆炸差,所以引入特殊的取值方法 三值取中法:顾名思义,就是取三个值,选出一个中间值作为基准值,能极大程度避免取的基准值太极端 a b,如果c比a还小,那a就是中间值 a b,如果c比b还大,那b就是中间值 如果都不是,说明c就是中间值 b a,情况同上处理 12345678910111213141516171819202122232425262728293031323334353637383940int GetMidIndex(int* array, int left, int right)&#123; int mid = left + ((right - left) &gt;&gt; 1); //a b if (array[left] &lt; array[right - 1]) &#123; //c&lt;a ,a就是mid if (array[mid] &lt; array[left]) &#123; return left; &#125; //c&gt;b,b就是mid else if (array[mid]&gt;array[right - 1]) &#123; return right - 1; &#125; else &#123; return mid; &#125; &#125; else &#123; //b a,c&lt;b,b就是mid if (array[mid] &lt; array[right - 1]) &#123; return right - 1; &#125; //b a,c&gt;a,a就是mid else if (array[mid]&gt;array[left]) &#123; return left; &#125; else &#123; return mid; &#125; &#125;&#125; 取好基准值之后,就可以进行元素的比较了,把左侧元素调整为都比基准值小,右侧都比基准值大 比较方法:定义两个指针,一个在前,一个在后,因为对数组操作,所以可以用数组下标代替 begin从前找比基准值大的元素,没有就begin++,直到找到 end同理,从后找比基准值小的元素,没有就end–,直到找到 找到的话,begin和end的位置如果不一样,就交换元素 最终将基准值放好(因为一开始把基准值和right-1位置的元素互换了) 要和right-1位置换,因为end是变化的 12345678910111213141516171819202122232425262728293031323334353637383940int partion(int* array, int left, int right)&#123; int mid = GetMidIndex(array, left, right); swap(array[mid], array[right - 1]); int begin = left; int end = right - 1; int key = array[right - 1]; while (begin&lt;end) &#123; //从左往右找比基准值大的元素 while (begin &lt; end&amp;&amp;array[begin] &lt;= key) &#123; begin++; &#125; //从右往左找比基准值小的元素 while (begin &lt; end&amp;&amp;array[end] &gt;= key) &#123; end--; &#125; //找到之后 if (begin != end) &#123; swap(array[begin], array[end]); &#125; &#125; //放置基准值 if (begin != right - 1) &#123; swap(array[begin], array[right - 1]); &#125; return begin;&#125; 流程示意图:","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"}],"tags":[]},{"title":"【数据结构---30】鸽巢原理---计数排序","slug":"DS-PigeonholePrinciple","date":"2019-05-31T16:00:00.000Z","updated":"2020-07-22T02:47:46.000Z","comments":true,"path":"2019/06/01/DS-PigeonholePrinciple/","link":"","permalink":"https://www.lubaobao.xyz/2019/06/01/DS-PigeonholePrinciple/","excerpt":"学习基础排序算法中的计数排序…","text":"学习基础排序算法中的计数排序… 思路分析: &lt;1&gt;巧妙地借助数组下标&lt;2&gt;如果没有给出范围的话,第一步先找出数据范围&lt;3&gt;统计每个元素出现的次数&lt;4&gt;按照统计的计数对元素进行回收 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void CountSort(int* array, int size)&#123; //未告知范围的情况下,先找出数据范围 int minPos = 0; int maxPos = 0; for (int i = 1; i &lt; size; ++i) &#123; if (array[minPos]&gt;array[i]) &#123; minPos = array[i]; &#125; if (array[maxPos] &lt; array[i]) &#123; maxPos = array[i]; &#125; &#125; int range = maxPos - minPos + 1; int* a = (int*)malloc(sizeof(int)*range); memset(a, 0, sizeof(int)*range); for (int i = 0; i &lt; size; ++i) &#123; a[array[i]-minPos]++; &#125; int count = 0; for (int j = 0; j &lt; range; ++j) &#123; while (a[j]) &#123; array[count++]=j+minPos; a[j]--; &#125; &#125; free(a); a = NULL;&#125;void PrintAll(int* array, int size)&#123; for (int i = 0; i &lt; size; ++i) &#123; printf(\"%d \",array[i]); &#125; printf(\"\\n\");&#125;int main()&#123; int array[] = &#123; 0, 1, 5, 3, 3, 4, 2, 5, 0, 9 &#125;; CountSort(array, sizeof(array) / sizeof(array[0])); PrintAll(array, sizeof(array) / sizeof(array[0])); system(\"pause\"); return 0;&#125; 代码运行测试图:","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"【数据结构---29】简单排序方法（下）","slug":"DS-SimpleSort2","date":"2019-05-28T16:00:00.000Z","updated":"2020-07-22T02:51:24.000Z","comments":true,"path":"2019/05/29/DS-SimpleSort2/","link":"","permalink":"https://www.lubaobao.xyz/2019/05/29/DS-SimpleSort2/","excerpt":"学习基础排序算法… 对快速排序的优化: 方法一代码实现: 方法二代码实现: 快速排序的循环写法: 代码实现: 归并排序: 归并的代码实现： 递归框架: 循环写法: 代码测试运行图:","text":"学习基础排序算法… 对快速排序的优化: 方法一代码实现: 方法二代码实现: 快速排序的循环写法: 代码实现: 归并排序: 归并的代码实现： 递归框架: 循环写法: 代码测试运行图: 对快速排序的优化:快排需要设置基准值,基准值的选取会出现两种极端情况,导致排序算法的性能变差 ①针对基准值的选取做出优化②针对递归的深度做出优化 方法一:三值取中法 &lt;1&gt;顾名思义就是取出三个基准值,选择值为中间的那一个&lt;2&gt;三个基准值分为是最左边,最右边以及中间,中间位置为left+((right-left)&gt;&gt;1);&lt;3&gt;之前的代码基于基准值key的设定为right-1,为了不做较大改动,将mid位置的元素和right-1位置元素互换 方法一代码实现:1234567891011121314151617181920212223242526272829303132333435int GetMiddleIndex(int* array, int left, int right)&#123; int mid = left + ((right - left) &gt;&gt; 1); if (array[left] &lt; array[right - 1]) &#123; if (array[mid] &lt; array[left]) &#123; return left; &#125; else if (array[mid]&gt;array[right - 1]) &#123; return right - 1; &#125; else &#123; return mid; &#125; &#125; else &#123; if (array[mid] &gt; array[left]) &#123; return left; &#125; else if (array[mid] &lt; array[right - 1]) &#123; return right - 1; &#125; else &#123; return mid; &#125; &#125;&#125; 方法二:调整递归深度 &lt;1&gt;不需要递归到只剩下一个元素才返回&lt;2&gt;设置为元素个数小于16的时候,使用适合数据小,接近有序的直接插入排序 方法二代码实现:12345678910if (right - left &gt; 16)&#123; InsertSort(array,right);&#125;else&#123; int div = partion3(array, left, right);QuickSort(array, left, div);QuickSort(array, div + 1, right);&#125; 快速排序的循环写法: &lt;1&gt;递归的函数调用和数据结构的栈很类似,所以使用栈来辅助完成递归转变为循环&lt;2&gt;首先将右边界压入栈中,在将左边界压入,这样左就在上,右就在下&lt;3&gt;获取栈顶元素的顺序就是先left在right,如果栈中元素不唯一,就继续分组&lt;4&gt;将新的区间压入栈中,顺序和&lt;2&gt;一致 代码实现:12345678910111213141516171819202122232425262728293031void QucikSortNor(int* array, int size)&#123; int left = 0; int right = size; Stack s; StackInit(&amp;s); //栈的特性是先入后出,所以反过来压入元素,出栈的顺序就是对的 StackPush(&amp;s, right); StackPush(&amp;s, left); //栈若不空,就对左右部分继续分别分组 while (StackEmpty(&amp;s) != -1) &#123; left = StackTop(&amp;s); StackPop(&amp;s); right = StackTop(&amp;s); StackPop(&amp;s); if (right - left &gt; 1) &#123; int div = partion3(array, left, right); StackPush(&amp;s, right); StackPush(&amp;s, div + 1); StackPush(&amp;s, div); StackPush(&amp;s, left); &#125; &#125;&#125; 归并排序:递归写法先分组,在排序,有序之后再归并,然后写入临时空间,最后内存拷贝回去 &lt;1&gt;类似于二叉树的后序遍历&lt;2&gt;先对左侧进行递归排序,在对右边进行递归排序,然后归并&lt;3&gt;memcpy拷贝的时候注意参数array和tmp都要加上left,否则只能拷到左边&lt;4&gt;归并的操作就是左边分组和右边分组每个元素分别比大小,小的先放入临时空间&lt;5&gt;长度不一的话单独处理,把剩下的元素直接插到后面 归并的代码实现：12345678910111213141516171819202122232425262728293031323334353637383940void MergeData(int* array, int left, int mid, int right,int* tmp)&#123; int begin1 = left; int end1 = mid; int begin2 = mid; int end2 = right; int index = left; while (begin1 &lt; end1 &amp;&amp; begin2 &lt; end2) &#123; if (array[begin1] &lt; array[begin2]) &#123; tmp[index] = array[begin1]; begin1++; index++; &#125; else &#123; tmp[index] = array[begin2]; begin2++; index++; &#125; &#125; //长短不一样的情况,单独处理 while (begin1 &lt; end1) &#123; tmp[index] = array[begin1]; index++; begin1++; &#125; while (begin2 &lt; end2) &#123; tmp[index] = array[begin2]; index++; begin2++; &#125;&#125; 递归框架:1234567891011121314void _MergeSort(int* array, int left, int right,int* tmp)&#123; if (right - left &gt; 1) &#123; int mid = left + ((right - left) &gt;&gt; 1); _MergeSort(array, left, mid,tmp); _MergeSort(array, mid, right,tmp); MergeData(array, left, mid, right,tmp); memcpy(array+left, tmp+left, sizeof(int)*(right - left)); &#125;&#125; 为了方便调用,所以对其封装: 1234567891011121314void MergeSort(int* array, int size)&#123; int* tmp = (int*)malloc(sizeof(int)*size); if (tmp == NULL) &#123; assert(0); &#125; _MergeSort(array, 0, size, tmp); free(tmp); tmp = NULL;&#125; 循环写法: &lt;1&gt;循环的跳出条件是gap&lt;size,就是一组可以表示所有数据&lt;2&gt;right和mid的取值可能越界,需要单独处理&lt;3&gt;不需要分组,因为开始默认为单独存在,只需要把有序的元素整合为一组 123456789101112131415161718192021222324252627282930313233343536373839void MergeSortNor(int* array, int size)&#123; int* tmp = (int*)malloc(sizeof(int)*size); if (tmp == NULL) &#123; assert(0); &#125; int gap = 1; while (gap &lt; size) &#123; for (int i = 0; i &lt; size; i += 2 * gap) &#123; int left = i; int mid = left + gap; int right = mid + gap; if (right &gt;= size) &#123; right = size; &#125; if (mid &gt;= size) &#123; mid = size; &#125; MergeData(array, left, mid, right, tmp); &#125; memcpy(array, tmp, sizeof(int)*size); gap *= 2; &#125; free(tmp); tmp = NULL;&#125; 代码测试运行图:","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"【数据结构---26】树以及二叉树的基本概念","slug":"DS-BinaryTree","date":"2019-05-22T16:00:00.000Z","updated":"2020-07-22T02:45:48.000Z","comments":true,"path":"2019/05/23/DS-BinaryTree/","link":"","permalink":"https://www.lubaobao.xyz/2019/05/23/DS-BinaryTree/","excerpt":"树的概念： 与树相关的基本概念: 树的表示方式： 二叉树： 二叉树的五条特性: 二叉树的存储： 堆序堆的实现: 调整堆序: 堆的删除操作: 堆的插入操作: 扩容: 用堆的思想进行排序 TOP K问题(海量数据) 二叉树的链式存储方式 求二叉树的节点个数: 二叉树的创建方式: 二叉树的销毁方式: 二叉树的拷贝: 查看二叉树中的叶子节点:","text":"树的概念： 与树相关的基本概念: 树的表示方式： 二叉树： 二叉树的五条特性: 二叉树的存储： 堆序堆的实现: 调整堆序: 堆的删除操作: 堆的插入操作: 扩容: 用堆的思想进行排序 TOP K问题(海量数据) 二叉树的链式存储方式 求二叉树的节点个数: 二叉树的创建方式: 二叉树的销毁方式: 二叉树的拷贝: 查看二叉树中的叶子节点: 树的概念：一种非线性的数据结构,它是由n个(n&gt;=0)有限节点组成的一个具有层次关系的集合 与树相关的基本概念:123456789深度:树中节点的最大层次双亲:若一个节点含有子节点,则这个节点是这个子节点的双亲节点子节点:一个节点含有的子树的根节点被称为这个节点的子节点兄弟:具有相同双亲节点的被称为兄弟节点叶节点:度为0的节点被称为叶节点 树的表示方式：1孩子表示法，双亲表示法，孩子双亲表示法，孩子兄弟表示法 二叉树：1空树，根+根的左子树+根的右子树 特殊的二叉树： 123满二叉树:每一层的节点数都达到最大值,这个二叉树就是满二叉树完全二叉树:从上之下从左至右一次填满的二叉树,不可能存在只有右孩子没有左孩子 二叉树的五条特性:12345678910111213141516171.若规定根节点的层次为1,则一颗非空二叉树的第i层最多有2^(i-1)个节点2.若规定只有根节点的二叉树深度为1,则深度为k的二叉树最大节点数是2^k-13.对任意一颗二叉树,如果其叶节点个数为n0,度为2的非叶节点个数为n2,则有n0&#x3D;n2+14.具有n个节点的完全二叉树的深度k为log2(n+1)向上取整5.对于有n个节点的完全二叉树,如果按照从上至下从左至右的顺序对所有节点从0进行编号则对于序号为i的节点有: &lt;1&gt;.若i&gt;0,双亲序号:(i-1)&#x2F;2i&#x3D;0,i为根节点编号,无双亲节点 &lt;2&gt;.若2i+1&lt;n,左孩子序号:2i+1,否则无左孩子 &lt;3&gt;.若2i+2&lt;n,右孩子序号:2i+2,否则无右孩子 二叉树的存储：123顺序结构：完全二叉树（基本不会增加删除）链式结构：通过指针来表示节点与其孩子及双亲之间的关系,常用孩子表示法，孩子双亲表示法 二叉树顺序存储： 堆（是一棵完全二叉树），堆中的元素存储到一维数组中，对于任意节点如果该节点中小于（大于）其左右孩子，就把这种结构称为小堆（大堆） 堆的特性： 堆顶元素一定是堆中所有元素最大的（最小的） 堆序堆的实现:结构类似于顺序表 调整堆序:123456789101112131415int child&#x3D;parent*2+1；默认child标记parent的左孩子因为完全二叉树某个节点只有一个孩子，该孩子一定是其双亲的左孩子向下调整:(调整的是以parent为根的子树)找出较小的孩子---左右孩子比较（左右孩子必须都存在，child+1&lt;size）左孩子比右孩子大的话，child+&#x3D;1双亲比较小的孩子大的话，交换双亲和孩子的顺序更新parent&#x3D;child；chil&#x3D;parent*2+1；2i+1已经大于size（数组节点个数），说明孩子不存在 创建堆的时间复杂度Nlog2(N) 堆的删除操作:123456789堆里没有元素不删除有的话就删除堆顶元素-----堆顶元素和末尾元素交换size的值要更新-----对堆顶元素进行向下调整AdjustDown(heapdatatype*array,heapdatatype*size,0) 堆的插入操作:1234567考虑空间是否放得下-----插入之后需要调整堆序-----向上调整,传的参数是孩子孩子小于双亲,需要交换-----child&#x3D;parent;parent&#x3D;(child-1)&#x2F;2;循环终止条件child!&#x3D;0;AdjusUp(hp-&gt;array,hp-&gt;size,hp-&gt;size-1); 扩容:1申请新空间-----拷贝元素 用堆的思想进行排序1降序是小堆,升序是大堆-----HeapSort(array,sizeof(array)&#x2F;sizeof(array[0])) TOP K问题(海量数据)1234567冒泡和堆排的话必须一次拿到所有的数据-----100亿数据需要40G内存空间直接遍历K次,需要多次IO,性能太差-----堆-----取前K个数据,建小堆从剩余的N-K个数据一次与堆顶的元素进行比较,然后选择是否替换比堆顶元素大的替换掉,最后堆里的K个元素都是最大的 堆的应用需要做到正背如流!!!!!!!! 二叉树的链式存储方式 二叉树的遍历: 按照某种特定的规则,对二叉树中的每一个节点进行相应的操作,并且每个节点只能操作一次 12345前序遍历: 根---&gt;根的左子树---&gt;根的右子树中序遍历: 根的左子树---&gt;根---&gt;根的右子树后序遍历: 根的左子树---&gt;根的右子树---&gt;根 递归遍历,先遍历根,然后继续调用,传的参数是root根节点的左子树,然后继续调用,传root的右子树 求二叉树的节点个数:1(根据二叉树的概念) 空树---0个 非空就递归求解 12345678int Getsize(Node*Root)&#123; if(Root&#x3D;&#x3D;NULL) &#123; return 0; &#125; return Getsize(Root-&gt;left)+Getsize(Root-&gt;right)+1;&#125; 二叉树的创建方式:索引必须给地址,因为要把索引的值带出函数外!!!!!! 创建链式二叉树—&gt;递归跳出条件(*index&lt;size)—&gt;先创建根节点,在创建根的左子树,在创建根的右子树 1234567891011121314151617要把创建的二叉树补全ABDCEF---&gt;ABD###CE##F###是我们给的空的节点的标记 修改跳出条件为(*index&lt;size&amp;&amp;array[*index]!&#x3D;&#39;#&#39;)&#96;跳出条件有先后顺序,不可以写错!!!!!&#96;索引遇到#之后还需要往后面走&#x2F;&#x2F;创建根节点&#x2F;&#x2F;(*index++),创建根的左子树&#x2F;&#x2F;(*index++),创建根的右子树递归之后其实创建的都是根节点,所有根节点创建写(*index++); 把创建的函数封装起来,方便用户调用,参数加一个无效参数,避免你设置为#,他输入$ Q:根据两个遍历的结果,要求还原出来的二叉树A:TO DO 二叉树的销毁方式:12345最后才可以销毁根节点,所以采用后序遍历规则销毁完所有的节点之后要把Root节点置空函数体内部修改形参的值,要传形参的地址所以销毁函数中传Root的地址!!!!! 二叉树的拷贝: 根据二叉树的概念,和创建的方法一样 查看二叉树中的叶子节点:1左右子树没有孩子的节点称为叶子节点 123456789if(Root&#x3D;&#x3D;NULL)&#123; return 0;&#125;if(Root-&gt;left&#x3D;&#x3D;NULL&amp;&amp;Root-&gt;right&#x3D;&#x3D;NULL)&#123; return 1;&#125;return GetLeatCount(Root-&gt;left)+GetLeatCount(Root-&gt;right);","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"【数据结构---25】链式结构二叉树的前、中、后序遍历","slug":"DS-OJBinaryTree","date":"2019-05-22T16:00:00.000Z","updated":"2020-07-22T02:51:31.000Z","comments":true,"path":"2019/05/23/DS-OJBinaryTree/","link":"","permalink":"https://www.lubaobao.xyz/2019/05/23/DS-OJBinaryTree/","excerpt":"数据结构相关练习题…","text":"数据结构相关练习题… 前序遍历:题目描述：给定一个二叉树，返回它的前序遍历 示例: 输入: [1,null,2,3] 1\\2/3 输出: [1,2,3] 123456789101112/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; *//** * Note: The returned array must be malloced, assume caller calls free(). */ 思路分析: 1.首先使用递归的方法求出节点的个数,跳出条件是当root==NULL的时候,0个2.对形参的指针修改相当于修改外部实参3.把遍历好的元素存放到数组里,最后返回数组 代码实现:123456789101112131415161718192021222324252627282930313233343536typedef struct TreeNode Node;//这里的size必须传指针,不然size作为临时变量,作用域和生命周期只有函数段void PreOrder(Node* Root,int * Res,int * size)&#123; if(Root!=NULL) &#123; Res[*size]=Root-&gt;val; (*size)++; PreOrder(Root-&gt;left,Res,size); PreOrder(Root-&gt;right,Res,size); &#125;&#125;int Getsize(Node* Root)&#123; if(Root==NULL) &#123; return 0; &#125; return Getsize(Root-&gt;left)+Getsize(Root-&gt;right)+1;&#125;//对形参的指针修改,相当于修改外部实参int* preorderTraversal(struct TreeNode* root, int* returnSize)&#123; *returnSize=Getsize(root); int* Res=(int*)malloc(sizeof(int)* (*returnSize)); if(Res==NULL) &#123; assert(0); &#125; int size=0; PreOrder(root,Res,&amp;size); return Res;&#125; 对于中序和后序的处理:只需要修改遍历语句的顺序即可 中序遍历:题目描述:给定一个二叉树，返回它的中序遍历 示例: 输入: [1,null,2,3]1\\2/3 输出: [1,3,2] 代码实现:12345678910void inOrder(Node* Root,int * Res,int * size)&#123; if(Root!=NULL) &#123; inOrder(Root-&gt;left,Res,size); Res[*size]=Root-&gt;val; (*size)++; inOrder(Root-&gt;right,Res,size); &#125;&#125; 后序遍历:题目描述:给定一个二叉树，返回它的 后序遍历 示例: 输入: [1,null,2,3]1\\2/3 输出: [3,2,1] 代码实现:12345678910void PostOrder(Node* Root,int * Res,int * size)&#123; if(Root!=NULL) &#123; PostOrder(Root-&gt;left,Res,size); PostOrder(Root-&gt;right,Res,size); Res[*size]=Root-&gt;val; (*size)++; &#125;&#125;","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"【数据结构---22】循环队列的实现","slug":"DS-CircleList","date":"2019-05-21T16:00:00.000Z","updated":"2020-07-22T02:46:18.000Z","comments":true,"path":"2019/05/22/DS-CircleList/","link":"","permalink":"https://www.lubaobao.xyz/2019/05/22/DS-CircleList/","excerpt":"学习循环队列的实现…","text":"学习循环队列的实现… 题目描述:设计你的循环队列实现 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环.它也被称为“环形缓冲器” 循环队列的一个好处是我们可以利用这个队列之前用过的空间.在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间.但是使用循环队列，我们能使用这些空间去存储新的值. 你的实现应该支持如下操作： 1234567MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 示例： MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为 3 circularQueue.enQueue(1); // 返回 true circularQueue.enQueue(2); // 返回 true circularQueue.enQueue(3); // 返回 true circularQueue.enQueue(4); // 返回 false，队列已满 circularQueue.Rear(); // 返回 3 circularQueue.isFull(); // 返回 true circularQueue.deQueue(); // 返回 true circularQueue.enQueue(4); // 返回 true circularQueue.Rear(); // 返回 4 提示： 123所有的值都在 0 至 1000 的范围内；操作数将在 1 至 1000 的范围内；请不要使用内置的队列库。 思路分析: 1.front不动,后面依次覆盖,时间复杂度O(N),效率低2.front向后移动,时间复杂度O(1),但是存在假溢出3.区别队空和队满&lt;1&gt;少用一个存储空间,判定条件为rear+1=front,(r+)%capacity==front&lt;2&gt;使用标记,flag ==0 &amp;&amp; rear ==front空,flag ==1 &amp;&amp; rear ==front满 代码实现:123456789typedef int Qdatatype;typedef struct &#123; Qdatatype* array; int capacity; int head; int len; int tail;&#125; MyCircularQueue; 初始化循环队列: 12345678910/** Initialize your data structure here. Set the size of the queue to be k. */MyCircularQueue* myCircularQueueCreate(int k) &#123; MyCircularQueue* Q=(MyCircularQueue*)malloc(sizeof(MyCircularQueue)); Q-&gt;array=(Qdatatype*)malloc(k*sizeof(Qdatatype)); Q-&gt;capacity=k; Q-&gt;head=0; Q-&gt;len=0; Q-&gt;tail=-1; return Q;&#125; 插入一个元素,满队列返回false,能插入返回true: 1234567891011/** Insert an element into the circular queue. Return true if the operation is successful. */bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) &#123; if(obj-&gt;capacity == obj-&gt;len) &#123; return false; &#125; obj-&gt;tail=(obj-&gt;tail+1)%obj-&gt;capacity; obj-&gt;array[obj-&gt;tail]=value; ++obj-&gt;len; return true;&#125; 删除一个元素,空队列返回false,能删除返回true: 12345678910/** Delete an element from the circular queue. Return true if the operation is successful. */bool myCircularQueueDeQueue(MyCircularQueue* obj) &#123; if(obj-&gt;len==0) &#123; return false; &#125; obj-&gt;head=(obj-&gt;head+1)%obj-&gt;capacity; --(obj-&gt;len); return true;&#125; 获取队头元素: 12345678/** Get the front item from the queue. */int myCircularQueueFront(MyCircularQueue* obj) &#123; if(obj-&gt;len==0) &#123; return -1; &#125; return obj-&gt;array[obj-&gt;head];&#125; 获取队尾元素: 12345678/** Get the last item from the queue. */int myCircularQueueRear(MyCircularQueue* obj) &#123; if(obj-&gt;len==0) &#123; return -1; &#125; return obj-&gt;array[obj-&gt;tail];&#125; 检查是否是空队列: 12345678/** Checks whether the circular queue is empty or not. */bool myCircularQueueIsEmpty(MyCircularQueue* obj) &#123; if(obj-&gt;len==0) &#123; return true; &#125; return false;&#125; 检查是否是满队列: 12345678/** Checks whether the circular queue is full or not. */bool myCircularQueueIsFull(MyCircularQueue* obj) &#123; if(obj-&gt;capacity==obj-&gt;len) &#123; return true; &#125; return false;&#125; 销毁循环队列: 12345678910111213141516void myCircularQueueFree(MyCircularQueue* obj) &#123; free(obj-&gt;array); free(obj);&#125;/** * Your MyCircularQueue struct will be instantiated and called as such: * MyCircularQueue* obj = myCircularQueueCreate(k); * bool param_1 = myCircularQueueEnQueue(obj, value); * bool param_2 = myCircularQueueDeQueue(obj); * int param_3 = myCircularQueueFront(obj); * int param_4 = myCircularQueueRear(obj); * bool param_5 = myCircularQueueIsEmpty(obj); * bool param_6 = myCircularQueueIsFull(obj); * myCircularQueueFree(obj);*/","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"【数据结构---21】用栈实现队列的操作","slug":"DS-StackToList","date":"2019-05-21T16:00:00.000Z","updated":"2020-07-22T02:51:18.000Z","comments":true,"path":"2019/05/22/DS-StackToList/","link":"","permalink":"https://www.lubaobao.xyz/2019/05/22/DS-StackToList/","excerpt":"数据结构OJ练习题…","text":"数据结构OJ练习题… 题目描述:使用栈实现队列的下列操作： 1234push(x) -- 将一个元素放入队列的尾部pop() -- 从队列首部移除元素peek() -- 返回队列首部的元素empty() -- 返回队列是否为空 示例:MyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 说明: 1234你只能使用标准的栈操作 -- 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的你所使用的语言也许不支持栈你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 先把需要用到的栈构建好:C语言实现一个动态栈 思路分析: 1.使用两个栈来完成对队列的模拟2.一个栈用来辅助中转元素,一个栈主要用来存放数据3.入队操作全部对于s1进行,出队操作首先将s1中的元素压入s2,然后s2的栈顶就是队头,将值保存后删除,然后再把s2的元素全部转入s1,恢复原本的结构4.获取队头元素和出队操作一致,只是不删除s2的栈顶元素即可 代码实现:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788typedef struct &#123; Stack s1; Stack s2;&#125; MyQueue;/** Initialize your data structure here. */MyQueue* myQueueCreate() &#123; MyQueue* SQ=(MyQueue*)malloc(sizeof(MyQueue)); if(SQ==NULL) &#123; assert(0); &#125; StackInit(&amp;SQ-&gt;s1); StackInit(&amp;SQ-&gt;s2); return SQ;&#125;/** Push element x to the back of queue. */void myQueuePush(MyQueue* obj, int x) &#123; StackPush(&amp;obj-&gt;s1,x);&#125;/** Removes the element from in front of queue and returns that element. */int myQueuePop(MyQueue* obj) &#123; //队列的Pop是头删,删除栈底元素 while(obj-&gt;s1.top&gt;0) &#123; StackPush(&amp;obj-&gt;s2,StackTop(&amp;obj-&gt;s1)); StackPop(&amp;obj-&gt;s1); &#125; int a=StackTop(&amp;obj-&gt;s2); StackPop(&amp;obj-&gt;s2); //然后恢复本来的结构 while(obj-&gt;s2.top&gt;0) &#123; StackPush(&amp;obj-&gt;s1,StackTop(&amp;obj-&gt;s2)); StackPop(&amp;obj-&gt;s2); &#125; return a;&#125;/** Get the front element. */int myQueuePeek(MyQueue* obj) &#123; while(obj-&gt;s1.top&gt;0) &#123; StackPush(&amp;obj-&gt;s2,StackTop(&amp;obj-&gt;s1)); StackPop(&amp;obj-&gt;s1); &#125; int a=StackTop(&amp;obj-&gt;s2); //然后恢复本来的结构 while(obj-&gt;s2.top&gt;0) &#123; StackPush(&amp;obj-&gt;s1,StackTop(&amp;obj-&gt;s2)); StackPop(&amp;obj-&gt;s2); &#125; return a;&#125;/** Returns whether the queue is empty. */bool myQueueEmpty(MyQueue* obj) &#123; if(StackEmpty(&amp;obj-&gt;s2) == -1 &amp;&amp; StackEmpty(&amp;obj-&gt;s1) == -1) &#123; return true; &#125; return false;&#125;void myQueueFree(MyQueue* obj) &#123; free(obj); obj=NULL;&#125;/** * Your MyQueue struct will be instantiated and called as such: * MyQueue* obj = myQueueCreate(); * myQueuePush(obj, x); * int param_2 = myQueuePop(obj); * int param_3 = myQueuePeek(obj); * bool param_4 = myQueueEmpty(obj); * myQueueFree(obj);*/","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"【数据结构---18】基于栈的括号匹配检测","slug":"DS-StackBrackets","date":"2019-05-17T16:00:00.000Z","updated":"2020-07-22T02:48:51.000Z","comments":true,"path":"2019/05/18/DS-StackBrackets/","link":"","permalink":"https://www.lubaobao.xyz/2019/05/18/DS-StackBrackets/","excerpt":"数据结构OJ练习题…","text":"数据结构OJ练习题… 题目描述：给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串，判断字符串是否有效 有效字符串需满足： 左括号必须用相同类型的右括号闭合左括号必须以正确的顺序闭合 注意空字符串可被认为是有效字符串 示例 1: 输入: “()”输出: true 示例 2: 输入: “()[]{}”输出: true 示例 3: 输入: “(]”输出: false 示例 4: 输入: “([)]”输出: false 示例 5: 输入: “{[]}”输出: true 先把需要用到的栈构建好:c语言实现动态栈 思路分析: 1.求出字符串的长度对其遍历,遍历到左括号时,往栈里压入对应的右括号2.遍历到右括号时获取栈顶元素对比,一致就继续,不一致就返回false3.如果遍历到空字符,continue4.最终遍历完毕,判断匹配的依据是栈为空栈注意:栈对应的Push操作中对top已经操作过了,不需要再对top操作 代码实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344bool isValid(char * s)&#123; Stack S; StackInit(&amp;S); int n=strlen(s); for(int i=0;i&lt;n;++i) &#123; if(s[i]=='(') &#123; StackPush(&amp;S,')'); &#125; if(s[i]=='[') &#123; StackPush(&amp;S,']'); &#125; if(s[i]=='&#123;') &#123; StackPush(&amp;S,'&#125;'); &#125; if(s[i]==' ') &#123; continue; &#125; if(s[i]==')'||s[i]==']'||s[i]=='&#125;') &#123; if(StackTop(&amp;S)==s[i]) &#123; StackPop(&amp;S); &#125; else &#123; return false; &#125; &#125; &#125; if(S.top==0) &#123; return true; &#125; else &#123; return false; &#125;&#125;","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"【数据结构---17】C语言实现一个链表队列","slug":"DS-CTOList","date":"2019-05-15T16:00:00.000Z","updated":"2020-07-22T02:46:45.000Z","comments":true,"path":"2019/05/16/DS-CTOList/","link":"","permalink":"https://www.lubaobao.xyz/2019/05/16/DS-CTOList/","excerpt":"学习C语言实现链表…","text":"学习C语言实现链表… Queue.h123456789101112131415161718192021222324252627282930313233#pragma oncetypedef int QDataType;typedef struct QNode&#123; struct QNode* _pNext; QDataType _data;&#125;QNode;typedef struct Queue&#123; QNode* _front; // 指向队头元素 QNode* _back; // 指向队尾元素 &#125;Queue;void QueueInit(Queue* q);void QueuePush(Queue* q, QDataType data);void QueuePop(Queue* q);QDataType QueueFront(Queue* q);QDataType QueueBack(Queue* q);int QueueSize(Queue* q);int QueueEmpty(Queue* q);void QueueDestroy(Queue* q);void QueueTest(); Queue.c12345678910111213141516#include \"queue.h\"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;QNode* BuyNode(QDataType data)&#123; QNode* newnode = (QNode*)malloc(sizeof(QNode)); if (newnode == NULL) &#123; assert(0); &#125; newnode-&gt;_data = data; newnode-&gt;_pNext = NULL; return newnode;&#125; 初始化操作:12345void QueueInit(Queue* q)&#123; assert(q); q-&gt;_front = q-&gt;_back = NULL;&#125; 入队:1234567891011121314void QueuePush(Queue* q, QDataType data)&#123; assert(q); QNode* node = BuyNode(data); if (q-&gt;_front == NULL ) &#123; q-&gt;_front = q-&gt;_back = node; &#125; else &#123; q-&gt;_back-&gt;_pNext = node; q-&gt;_back = node; &#125;&#125; 出队:1234567891011121314151617181920void QueuePop(Queue* q)&#123; assert(q); if (q-&gt;_front == NULL) &#123; return; &#125; QNode* newhead = q-&gt;_front; //队列中只有一个元素 if (q-&gt;_front-&gt;_pNext == NULL) &#123; q-&gt;_front = q-&gt;_back = NULL; &#125; else &#123; q-&gt;_front = newhead-&gt;_pNext; free(newhead); newhead = NULL; &#125;&#125; 获取队头元素:12345678QDataType QueueFront(Queue* q)&#123; if (q-&gt;_front == NULL) &#123; return -1; &#125; return q-&gt;_front-&gt;_data;&#125; 获取队尾元素:12345678QDataType QueueBack(Queue* q)&#123; if (q-&gt;_front == NULL) &#123; return -1; &#125; return q-&gt;_back-&gt;_data;&#125; 查看当前元素个数:1234567891011int QueueSize(Queue* q)&#123; QNode* pCur = q-&gt;_front; int count = 0; while (pCur != NULL) &#123; pCur = pCur-&gt;_pNext; count++; &#125; return count;&#125; 检测队列是否为空:12345678int QueueEmpty(Queue* q)&#123; if (q-&gt;_front == NULL) &#123; return -1; &#125; return 1;&#125; 销毁队列:1234567891011121314151617void QueueDestroy(Queue* q)&#123; assert(q); if (q-&gt;_front == NULL) &#123; return; &#125; QNode* pCur = q-&gt;_front; while (pCur != NULL) &#123; q-&gt;_front= pCur-&gt;_pNext; free(pCur); pCur = NULL; pCur = q-&gt;_front; &#125; q-&gt;_front = q-&gt;_back = NULL;&#125; 测试队列的实现:1234567891011121314151617void QueueTest()&#123; Queue s; QueueInit(&amp;s); QueuePush(&amp;s, 1); QueuePush(&amp;s, 2); QueuePush(&amp;s, 3); QueuePush(&amp;s, 4); //出队列 QueuePop(&amp;s); QueuePop(&amp;s); QueuePop(&amp;s); //查看当前元素个数 printf(\"size=%d\\n\",QueueSize(&amp;s));&#125; 主函数:12345int main()&#123; QueueTest(); return 0;&#125; 代码运行测试图:","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"【数据结构---7】以给定值x为基准将链表分割成两部分","slug":"DS-CutList","date":"2019-05-01T16:00:00.000Z","updated":"2020-07-22T02:47:11.000Z","comments":true,"path":"2019/05/02/DS-CutList/","link":"","permalink":"https://www.lubaobao.xyz/2019/05/02/DS-CutList/","excerpt":"数据结构相关练习题…","text":"数据结构相关练习题… 题目描述:编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前给定一个链表的头指针 ,请返回重新排列后的链表的头指针 注意：分割以后保持原来的数据顺序不变 123456/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;*/ 思路分析: 1.创建两个结果链表,分为1和2,一个用来保存小于基准值的节点,另一个用来保存大于基准值的节点2.对原先的链表进行遍历,如果比基准值小,用尾插的方法插入第一个结果链表,反之,插入第二个3.插入完毕之后进行两个链表的合并,将第一个链表的最后一个节点的next指向第二个链表4.注意极端情况:1.保存大于基准值的链表的最后一个节点不一定指向空,所以最后我们记得处理!!2.有可能给出的基准值比其中一整条链表保存的数都大,所以这时直接返回另一条链表 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Partition &#123;public: ListNode* partition(ListNode* pHead, int x) &#123; ListNode* result1 = NULL; ListNode* last1 = NULL; ListNode* last2 = NULL; ListNode* result2 = NULL; ListNode* pCur = pHead; while (pCur != NULL) &#123; if (pCur-&gt;val &lt; x) &#123; if (result1 == NULL) &#123; result1 = last1 = pCur; &#125; else &#123; last1-&gt;next = pCur; last1 = pCur; &#125; &#125; else &#123; if (result2 == NULL) &#123; result2 = last2 = pCur; &#125; else &#123; last2-&gt;next = pCur; last2 = pCur; &#125; &#125; pCur=pCur-&gt;next; &#125; if(last1!=NULL) &#123; last1-&gt;next = result2; &#125; if (last2 != NULL) &#123; last2-&gt;next = NULL; &#125; if(last1!=NULL) &#123; return result1; &#125; else &#123; return result2; &#125; &#125;&#125;;","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]},{"title":"【数据结构---6】将两个有序链表合并为一个新的有序链表并返回","slug":"DS-MergeList","date":"2019-05-01T16:00:00.000Z","updated":"2020-07-22T02:51:10.000Z","comments":true,"path":"2019/05/02/DS-MergeList/","link":"","permalink":"https://www.lubaobao.xyz/2019/05/02/DS-MergeList/","excerpt":"数据结构相关练习题…","text":"数据结构相关练习题… 题目描述:将两个有序链表合并为一个新的有序链表并返回,新链表是通过拼接给定的两个链表的所有节点组成的 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 1234567/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */ 思路分析: 1.创建一个结果链表,同时对两个链表进行遍历2.如果第一个链表第一个节点的值比第二个链表的第一个节点的值小,那么就把第一个链表的第一个节点指向结果链表3.注意极端情况:1.第一个或第二个链表有一个为空,那就直接返回另一个链表2.两个链表长短不一时,一方遍历完而另一个没有,最后把结果链表的last指向还没有遍历完的链表4.最后返回结果链表 代码实现:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)&#123; if (l1 == NULL) &#123; return l2; &#125; if (l2 == NULL) &#123; return l1; &#125; struct ListNode *c1 = l1; struct ListNode *c2 = l2; struct ListNode *result = NULL; struct ListNode *last = NULL; while (c1 != NULL &amp;&amp; c2 != NULL) &#123; struct ListNode* next1=c1-&gt;next; struct ListNode* next2=c2-&gt;next; if (c1-&gt;val &lt;= c2-&gt;val) &#123; if (result == NULL) &#123; result = last = c1; &#125; else &#123; last-&gt;next = c1; last = c1; &#125; c1=next1; &#125; else &#123; if (result == NULL) &#123; result = last =c2 ; &#125; else &#123; last-&gt;next = c2; last = c2; &#125; c2 = next2; &#125; &#125; if (c1 != NULL) &#123; last-&gt;next = c1; &#125; if (c2 != NULL) &#123; last-&gt;next = c2; &#125; return result;&#125;","categories":[{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"}],"tags":[]}],"categories":[{"name":"C#","slug":"C","permalink":"https://www.lubaobao.xyz/categories/C/"},{"name":"Cpp","slug":"Cpp","permalink":"https://www.lubaobao.xyz/categories/Cpp/"},{"name":"VsCode","slug":"VsCode","permalink":"https://www.lubaobao.xyz/categories/VsCode/"},{"name":"HTML","slug":"HTML","permalink":"https://www.lubaobao.xyz/categories/HTML/"},{"name":"ReView","slug":"ReView","permalink":"https://www.lubaobao.xyz/categories/ReView/"},{"name":"DS","slug":"DS","permalink":"https://www.lubaobao.xyz/categories/DS/"},{"name":"Linux","slug":"Linux","permalink":"https://www.lubaobao.xyz/categories/Linux/"}],"tags":[]}